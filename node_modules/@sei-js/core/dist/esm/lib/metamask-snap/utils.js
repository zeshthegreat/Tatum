'use strict';

var _interopRequireDefault = require('@babel/runtime/helpers/interopRequireDefault');
Object.defineProperty(exports, '__esModule', {
	value: true
});
exports.sendReqToSnap = exports.getSnapEthereumProvider = void 0;
var _regenerator = _interopRequireDefault(require('@babel/runtime/regenerator'));
var _asyncToGenerator2 = _interopRequireDefault(require('@babel/runtime/helpers/asyncToGenerator'));
function _createForOfIteratorHelper(o, allowArrayLike) {
	var it = (typeof Symbol !== 'undefined' && o[Symbol.iterator]) || o['@@iterator'];
	if (!it) {
		if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || (allowArrayLike && o && typeof o.length === 'number')) {
			if (it) o = it;
			var i = 0;
			var F = function F() {};
			return {
				s: F,
				n: function n() {
					if (i >= o.length) return { done: true };
					return { done: false, value: o[i++] };
				},
				e: function e(_e) {
					throw _e;
				},
				f: F
			};
		}
		throw new TypeError('Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.');
	}
	var normalCompletion = true,
		didErr = false,
		err;
	return {
		s: function s() {
			it = it.call(o);
		},
		n: function n() {
			var step = it.next();
			normalCompletion = step.done;
			return step;
		},
		e: function e(_e2) {
			didErr = true;
			err = _e2;
		},
		f: function f() {
			try {
				if (!normalCompletion && it['return'] != null) it['return']();
			} finally {
				if (didErr) throw err;
			}
		}
	};
}
function _unsupportedIterableToArray(o, minLen) {
	if (!o) return;
	if (typeof o === 'string') return _arrayLikeToArray(o, minLen);
	var n = Object.prototype.toString.call(o).slice(8, -1);
	if (n === 'Object' && o.constructor) n = o.constructor.name;
	if (n === 'Map' || n === 'Set') return Array.from(o);
	if (n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
	if (len == null || len > arr.length) len = arr.length;
	for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	return arr2;
}
/**
 * The fool proof version of getting the ethereum provider suggested by
 * https://github.com/Montoya/snap-connect-test/blob/0dad2dd53ab2ecbf4b4369230d3aaaeca08c6dae/index.html#L41
 *
 * @returns the ethereum provider which supports snaps
 */
var getSnapEthereumProvider = (exports.getSnapEthereumProvider = /*#__PURE__*/ (function () {
	var _ref = (0, _asyncToGenerator2['default'])(
		/*#__PURE__*/ _regenerator['default'].mark(function _callee() {
			var mmFound, _iterator, _step, provider, _iterator2, _step2, _provider;
			return _regenerator['default'].wrap(
				function _callee$(_context) {
					while (1)
						switch ((_context.prev = _context.next)) {
							case 0:
								mmFound = false;
								if (!('detected' in window.ethereum)) {
									_context.next = 27;
									break;
								}
								_iterator = _createForOfIteratorHelper(window.ethereum.detected);
								_context.prev = 3;
								_iterator.s();
							case 5:
								if ((_step = _iterator.n()).done) {
									_context.next = 19;
									break;
								}
								provider = _step.value;
								_context.prev = 7;
								_context.next = 10;
								return provider.request({
									method: 'wallet_getSnaps'
								});
							case 10:
								// enforces MetaMask as provider
								window.ethereum.setProvider(provider);
								mmFound = true;
								// @ts-ignore
								return _context.abrupt('return', provider);
							case 15:
								_context.prev = 15;
								_context.t0 = _context['catch'](7);
							case 17:
								_context.next = 5;
								break;
							case 19:
								_context.next = 24;
								break;
							case 21:
								_context.prev = 21;
								_context.t1 = _context['catch'](3);
								_iterator.e(_context.t1);
							case 24:
								_context.prev = 24;
								_iterator.f();
								return _context.finish(24);
							case 27:
								if (!(!mmFound && 'providers' in window.ethereum)) {
									_context.next = 53;
									break;
								}
								_iterator2 = _createForOfIteratorHelper(window.ethereum.providers);
								_context.prev = 29;
								_iterator2.s();
							case 31:
								if ((_step2 = _iterator2.n()).done) {
									_context.next = 45;
									break;
								}
								_provider = _step2.value;
								_context.prev = 33;
								_context.next = 36;
								return _provider.request({
									method: 'wallet_getSnaps'
								});
							case 36:
								// @ts-ignore
								window.ethereum = _provider;
								mmFound = true;
								// @ts-ignore
								return _context.abrupt('return', _provider);
							case 41:
								_context.prev = 41;
								_context.t2 = _context['catch'](33);
							case 43:
								_context.next = 31;
								break;
							case 45:
								_context.next = 50;
								break;
							case 47:
								_context.prev = 47;
								_context.t3 = _context['catch'](29);
								_iterator2.e(_context.t3);
							case 50:
								_context.prev = 50;
								_iterator2.f();
								return _context.finish(50);
							case 53:
								return _context.abrupt('return', window.ethereum);
							case 54:
							case 'end':
								return _context.stop();
						}
				},
				_callee,
				null,
				[
					[3, 21, 24, 27],
					[7, 15],
					[29, 47, 50, 53],
					[33, 41]
				]
			);
		})
	);
	return function getSnapEthereumProvider() {
		return _ref.apply(this, arguments);
	};
})());
var sendReqToSnap = (exports.sendReqToSnap = /*#__PURE__*/ (function () {
	var _ref2 = (0, _asyncToGenerator2['default'])(
		/*#__PURE__*/ _regenerator['default'].mark(function _callee2(method, params, snapId) {
			var provider;
			return _regenerator['default'].wrap(function _callee2$(_context2) {
				while (1)
					switch ((_context2.prev = _context2.next)) {
						case 0:
							_context2.next = 2;
							return getSnapEthereumProvider();
						case 2:
							provider = _context2.sent;
							return _context2.abrupt(
								'return',
								provider.request({
									method: 'wallet_invokeSnap',
									params: {
										snapId: snapId,
										request: {
											method: method,
											params: params
										}
									}
								})
							);
						case 4:
						case 'end':
							return _context2.stop();
					}
			}, _callee2);
		})
	);
	return function sendReqToSnap(_x, _x2, _x3) {
		return _ref2.apply(this, arguments);
	};
})());
//# sourceMappingURL=utils.js.map
