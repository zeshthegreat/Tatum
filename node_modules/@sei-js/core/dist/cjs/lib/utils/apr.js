'use strict';

var _interopRequireDefault = require('@babel/runtime/helpers/interopRequireDefault');
Object.defineProperty(exports, '__esModule', {
	value: true
});
exports.estimateStakingAPR = estimateStakingAPR;
exports.getMintParams = getMintParams;
exports.getPool = getPool;
exports.getUpcomingMintTokens = getUpcomingMintTokens;
var _regenerator = _interopRequireDefault(require('@babel/runtime/regenerator'));
var _asyncToGenerator2 = _interopRequireDefault(require('@babel/runtime/helpers/asyncToGenerator'));
var _moment = _interopRequireDefault(require('moment'));
function _createForOfIteratorHelper(o, allowArrayLike) {
	var it = (typeof Symbol !== 'undefined' && o[Symbol.iterator]) || o['@@iterator'];
	if (!it) {
		if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || (allowArrayLike && o && typeof o.length === 'number')) {
			if (it) o = it;
			var i = 0;
			var F = function F() {};
			return {
				s: F,
				n: function n() {
					if (i >= o.length) return { done: true };
					return { done: false, value: o[i++] };
				},
				e: function e(_e) {
					throw _e;
				},
				f: F
			};
		}
		throw new TypeError('Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.');
	}
	var normalCompletion = true,
		didErr = false,
		err;
	return {
		s: function s() {
			it = it.call(o);
		},
		n: function n() {
			var step = it.next();
			normalCompletion = step.done;
			return step;
		},
		e: function e(_e2) {
			didErr = true;
			err = _e2;
		},
		f: function f() {
			try {
				if (!normalCompletion && it['return'] != null) it['return']();
			} finally {
				if (didErr) throw err;
			}
		}
	};
}
function _unsupportedIterableToArray(o, minLen) {
	if (!o) return;
	if (typeof o === 'string') return _arrayLikeToArray(o, minLen);
	var n = Object.prototype.toString.call(o).slice(8, -1);
	if (n === 'Object' && o.constructor) n = o.constructor.name;
	if (n === 'Map' || n === 'Set') return Array.from(o);
	if (n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
	if (len == null || len > arr.length) len = arr.length;
	for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	return arr2;
}
function estimateStakingAPR(_x) {
	return _estimateStakingAPR.apply(this, arguments);
} // Helper function to query the staking pool.
function _estimateStakingAPR() {
	_estimateStakingAPR = (0, _asyncToGenerator2['default'])(
		/*#__PURE__*/ _regenerator['default'].mark(function _callee(queryClient) {
			var pool, bondedTokens, mintParams, mintSchedule, upcomingMintTokens;
			return _regenerator['default'].wrap(function _callee$(_context) {
				while (1)
					switch ((_context.prev = _context.next)) {
						case 0:
							_context.next = 2;
							return getPool(queryClient);
						case 2:
							pool = _context.sent;
							bondedTokens = Number(pool === null || pool === void 0 ? void 0 : pool.bonded_tokens); // Query mint schedule
							_context.next = 6;
							return getMintParams(queryClient);
						case 6:
							mintParams = _context.sent;
							mintSchedule = mintParams === null || mintParams === void 0 ? void 0 : mintParams.token_release_schedule;
							if (!(!mintSchedule || !pool)) {
								_context.next = 10;
								break;
							}
							throw new Error('Failed to query mintSchedule or pool');
						case 10:
							// Calculate number of tokens to be minted in the next year.
							upcomingMintTokens = getUpcomingMintTokens((0, _moment['default'])(), 365, mintSchedule); // APR estimate is the number of tokens to be minted / current number of bonded tokens.
							return _context.abrupt('return', upcomingMintTokens / bondedTokens);
						case 12:
						case 'end':
							return _context.stop();
					}
			}, _callee);
		})
	);
	return _estimateStakingAPR.apply(this, arguments);
}
function getPool(_x2) {
	return _getPool.apply(this, arguments);
} // Helper function to query the mint module params.
function _getPool() {
	_getPool = (0, _asyncToGenerator2['default'])(
		/*#__PURE__*/ _regenerator['default'].mark(function _callee2(queryClient) {
			var result;
			return _regenerator['default'].wrap(
				function _callee2$(_context2) {
					while (1)
						switch ((_context2.prev = _context2.next)) {
							case 0:
								_context2.prev = 0;
								_context2.next = 3;
								return queryClient.cosmos.staking.v1beta1.pool({});
							case 3:
								result = _context2.sent;
								return _context2.abrupt('return', result.pool);
							case 7:
								_context2.prev = 7;
								_context2.t0 = _context2['catch'](0);
								console.log(_context2.t0);
							case 10:
							case 'end':
								return _context2.stop();
						}
				},
				_callee2,
				null,
				[[0, 7]]
			);
		})
	);
	return _getPool.apply(this, arguments);
}
function getMintParams(_x3) {
	return _getMintParams.apply(this, arguments);
} // Gets the number of tokens that will be minted in the given window based on the given releaseSchedule.
// Assumes that releaseSchedule has no overlapping schedules.
function _getMintParams() {
	_getMintParams = (0, _asyncToGenerator2['default'])(
		/*#__PURE__*/ _regenerator['default'].mark(function _callee3(queryClient) {
			var result;
			return _regenerator['default'].wrap(
				function _callee3$(_context3) {
					while (1)
						switch ((_context3.prev = _context3.next)) {
							case 0:
								_context3.prev = 0;
								_context3.next = 3;
								return queryClient.seiprotocol.seichain.mint.params({});
							case 3:
								result = _context3.sent;
								return _context3.abrupt('return', result.params);
							case 7:
								_context3.prev = 7;
								_context3.t0 = _context3['catch'](0);
								console.log(_context3.t0);
							case 10:
							case 'end':
								return _context3.stop();
						}
				},
				_callee3,
				null,
				[[0, 7]]
			);
		})
	);
	return _getMintParams.apply(this, arguments);
}
function getUpcomingMintTokens(startDate, days, releaseSchedule) {
	// End date is the exclusive end date of the window to query.
	// Ie. if start date is 2023-1-1 and days is 365, end date here will be 2024-1-1 so rewards will be calculated from 2023-1-1 to 2023-12-31
	var endDate = startDate.clone().add(days, 'days');

	// Sort release schedule in increasing order of start time.
	var sortedReleaseSchedule = getSortedReleaseSchedule(releaseSchedule);
	var tokens = 0;
	var _iterator = _createForOfIteratorHelper(sortedReleaseSchedule),
		_step;
	try {
		for (_iterator.s(); !(_step = _iterator.n()).done; ) {
			var release = _step.value;
			// Skip all schedules that ended before today.
			if (release.endDate.isBefore(startDate)) {
				continue;
			}
			// If the start date is after end date, we have come to the end of all releases we should consider.
			if (release.startDate.isAfter(endDate)) {
				break;
			}
			// All releases from here are part of the window.
			// The case where this release started before today.
			if (release.startDate.isBefore(startDate)) {
				// Need to deduct 1 day from endDate to make it an inclusive end date.
				var earlierInclusiveEndDate = _moment['default'].min(endDate.clone().subtract(1, 'days'), release.endDate);

				// Number of days left in this release.
				var daysLeft = calculateDaysInclusive(startDate, earlierInclusiveEndDate);
				var totalPeriod = calculateDaysInclusive(release.startDate, release.endDate);
				tokens += (daysLeft / totalPeriod) * release.tokenReleaseAmount;
			}

			// The case where this release ends after our search window.
			else if (release.endDate.isAfter(endDate)) {
				var _daysLeft = Math.round(endDate.diff(release.startDate, 'days', true));
				var _totalPeriod = calculateDaysInclusive(release.startDate, release.endDate);
				tokens += (_daysLeft / _totalPeriod) * release.tokenReleaseAmount;
			}

			// In the final case, the entire period falls within our window.
			else {
				tokens += release.tokenReleaseAmount;
			}
		}
	} catch (err) {
		_iterator.e(err);
	} finally {
		_iterator.f();
	}
	return tokens;
}

// Converts the releaseSchedule into ReleaseSchedule[] and sorts it by start date.
function getSortedReleaseSchedule(releaseSchedule) {
	var releaseScheduleTimes = releaseSchedule.map(function (schedule) {
		return createReleaseSchedule(schedule.start_date, schedule.end_date, schedule.token_release_amount);
	});

	// Sort release schedule in increasing order of start time.
	var sortedReleaseSchedule = releaseScheduleTimes.sort(function (x, y) {
		if (x.startDate.isAfter(y.startDate)) {
			return 1;
		} else if (y.startDate.isAfter(x.startDate)) {
			return -1;
		}
		return 0;
	});
	return sortedReleaseSchedule;
}

// Returns the number of days in the window inclusive of the start and end date.
function calculateDaysInclusive(startDate, endDate) {
	return Math.round(endDate.diff(startDate, 'days', true)) + 1;
}
function createReleaseSchedule(start_date, end_date, token_release_amount) {
	return {
		startDate: (0, _moment['default'])(start_date),
		endDate: (0, _moment['default'])(end_date),
		tokenReleaseAmount: Number(token_release_amount)
	};
}
//# sourceMappingURL=apr.js.map
