import { Long } from "../../../helpers";
import * as _m0 from "protobufjs/minimal";
function createBaseContractInfo() {
    return {
        codeId: Long.UZERO,
        contractAddr: "",
        needHook: false,
        needOrderMatching: false,
        dependencies: [],
        numIncomingDependencies: Long.ZERO
    };
}
export const ContractInfo = {
    encode(message, writer = _m0.Writer.create()) {
        if (!message.codeId.isZero()) {
            writer.uint32(8).uint64(message.codeId);
        }
        if (message.contractAddr !== "") {
            writer.uint32(18).string(message.contractAddr);
        }
        if (message.needHook === true) {
            writer.uint32(24).bool(message.needHook);
        }
        if (message.needOrderMatching === true) {
            writer.uint32(32).bool(message.needOrderMatching);
        }
        for (const v of message.dependencies) {
            ContractDependencyInfo.encode(v, writer.uint32(42).fork()).ldelim();
        }
        if (!message.numIncomingDependencies.isZero()) {
            writer.uint32(48).int64(message.numIncomingDependencies);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseContractInfo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.codeId = reader.uint64();
                    break;
                case 2:
                    message.contractAddr = reader.string();
                    break;
                case 3:
                    message.needHook = reader.bool();
                    break;
                case 4:
                    message.needOrderMatching = reader.bool();
                    break;
                case 5:
                    message.dependencies.push(ContractDependencyInfo.decode(reader, reader.uint32()));
                    break;
                case 6:
                    message.numIncomingDependencies = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseContractInfo();
        message.codeId = object.codeId !== undefined && object.codeId !== null ? Long.fromValue(object.codeId) : Long.UZERO;
        message.contractAddr = object.contractAddr ?? "";
        message.needHook = object.needHook ?? false;
        message.needOrderMatching = object.needOrderMatching ?? false;
        message.dependencies = object.dependencies?.map(e => ContractDependencyInfo.fromPartial(e)) || [];
        message.numIncomingDependencies = object.numIncomingDependencies !== undefined && object.numIncomingDependencies !== null ? Long.fromValue(object.numIncomingDependencies) : Long.ZERO;
        return message;
    }
};
function createBaseContractInfoV2() {
    return {
        codeId: Long.UZERO,
        contractAddr: "",
        needHook: false,
        needOrderMatching: false,
        dependencies: [],
        numIncomingDependencies: Long.ZERO,
        creator: "",
        rentBalance: Long.UZERO,
        suspended: false,
        suspensionReason: ""
    };
}
export const ContractInfoV2 = {
    encode(message, writer = _m0.Writer.create()) {
        if (!message.codeId.isZero()) {
            writer.uint32(8).uint64(message.codeId);
        }
        if (message.contractAddr !== "") {
            writer.uint32(18).string(message.contractAddr);
        }
        if (message.needHook === true) {
            writer.uint32(24).bool(message.needHook);
        }
        if (message.needOrderMatching === true) {
            writer.uint32(32).bool(message.needOrderMatching);
        }
        for (const v of message.dependencies) {
            ContractDependencyInfo.encode(v, writer.uint32(42).fork()).ldelim();
        }
        if (!message.numIncomingDependencies.isZero()) {
            writer.uint32(48).int64(message.numIncomingDependencies);
        }
        if (message.creator !== "") {
            writer.uint32(58).string(message.creator);
        }
        if (!message.rentBalance.isZero()) {
            writer.uint32(64).uint64(message.rentBalance);
        }
        if (message.suspended === true) {
            writer.uint32(72).bool(message.suspended);
        }
        if (message.suspensionReason !== "") {
            writer.uint32(82).string(message.suspensionReason);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseContractInfoV2();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.codeId = reader.uint64();
                    break;
                case 2:
                    message.contractAddr = reader.string();
                    break;
                case 3:
                    message.needHook = reader.bool();
                    break;
                case 4:
                    message.needOrderMatching = reader.bool();
                    break;
                case 5:
                    message.dependencies.push(ContractDependencyInfo.decode(reader, reader.uint32()));
                    break;
                case 6:
                    message.numIncomingDependencies = reader.int64();
                    break;
                case 7:
                    message.creator = reader.string();
                    break;
                case 8:
                    message.rentBalance = reader.uint64();
                    break;
                case 9:
                    message.suspended = reader.bool();
                    break;
                case 10:
                    message.suspensionReason = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseContractInfoV2();
        message.codeId = object.codeId !== undefined && object.codeId !== null ? Long.fromValue(object.codeId) : Long.UZERO;
        message.contractAddr = object.contractAddr ?? "";
        message.needHook = object.needHook ?? false;
        message.needOrderMatching = object.needOrderMatching ?? false;
        message.dependencies = object.dependencies?.map(e => ContractDependencyInfo.fromPartial(e)) || [];
        message.numIncomingDependencies = object.numIncomingDependencies !== undefined && object.numIncomingDependencies !== null ? Long.fromValue(object.numIncomingDependencies) : Long.ZERO;
        message.creator = object.creator ?? "";
        message.rentBalance = object.rentBalance !== undefined && object.rentBalance !== null ? Long.fromValue(object.rentBalance) : Long.UZERO;
        message.suspended = object.suspended ?? false;
        message.suspensionReason = object.suspensionReason ?? "";
        return message;
    }
};
function createBaseContractDependencyInfo() {
    return {
        dependency: "",
        immediateElderSibling: "",
        immediateYoungerSibling: ""
    };
}
export const ContractDependencyInfo = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.dependency !== "") {
            writer.uint32(10).string(message.dependency);
        }
        if (message.immediateElderSibling !== "") {
            writer.uint32(18).string(message.immediateElderSibling);
        }
        if (message.immediateYoungerSibling !== "") {
            writer.uint32(26).string(message.immediateYoungerSibling);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseContractDependencyInfo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.dependency = reader.string();
                    break;
                case 2:
                    message.immediateElderSibling = reader.string();
                    break;
                case 3:
                    message.immediateYoungerSibling = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseContractDependencyInfo();
        message.dependency = object.dependency ?? "";
        message.immediateElderSibling = object.immediateElderSibling ?? "";
        message.immediateYoungerSibling = object.immediateYoungerSibling ?? "";
        return message;
    }
};
function createBaseLegacyContractInfo() {
    return {
        codeId: Long.UZERO,
        contractAddr: "",
        needHook: false,
        needOrderMatching: false,
        dependentContractAddrs: []
    };
}
export const LegacyContractInfo = {
    encode(message, writer = _m0.Writer.create()) {
        if (!message.codeId.isZero()) {
            writer.uint32(8).uint64(message.codeId);
        }
        if (message.contractAddr !== "") {
            writer.uint32(18).string(message.contractAddr);
        }
        if (message.needHook === true) {
            writer.uint32(24).bool(message.needHook);
        }
        if (message.needOrderMatching === true) {
            writer.uint32(32).bool(message.needOrderMatching);
        }
        for (const v of message.dependentContractAddrs) {
            writer.uint32(42).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseLegacyContractInfo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.codeId = reader.uint64();
                    break;
                case 2:
                    message.contractAddr = reader.string();
                    break;
                case 3:
                    message.needHook = reader.bool();
                    break;
                case 4:
                    message.needOrderMatching = reader.bool();
                    break;
                case 5:
                    message.dependentContractAddrs.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        const message = createBaseLegacyContractInfo();
        message.codeId = object.codeId !== undefined && object.codeId !== null ? Long.fromValue(object.codeId) : Long.UZERO;
        message.contractAddr = object.contractAddr ?? "";
        message.needHook = object.needHook ?? false;
        message.needOrderMatching = object.needOrderMatching ?? false;
        message.dependentContractAddrs = object.dependentContractAddrs?.map(e => e) || [];
        return message;
    }
};
