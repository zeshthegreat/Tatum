"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SpoofChecker = void 0;
const check_result_1 = require("./check-result");
const enums_1 = require("./enums");
const regexes_1 = require("./regexes");
const unicode_1 = require("./regexes/unicode");
const categories_1 = require("./regexes/unicode/categories");
const script_resolver_1 = require("./script-resolver");
class SpoofChecker {
    constructor() {
        this.status = enums_1.ErrorCode.ZERO_ERROR;
        this.checks = enums_1.SpoofChecks.ALL_CHECKS;
        this.restrictionLevel = enums_1.RestrictionLevel.HIGHLY_RESTRICTIVE;
    }
    safeToDisplayAsUnicode(label, isTldAscii) {
        this.status = enums_1.ErrorCode.ZERO_ERROR;
        // mask all emojis with a regular letter for the rest of the validation
        label = label.replace(categories_1.emoji, 'a');
        let result = this.check(label);
        if (this.status > enums_1.ErrorCode.ZERO_ERROR || result & enums_1.SpoofChecks.ALL_CHECKS) {
            //console.log('Spoof check failuire');
            return false;
        }
        result &= enums_1.RestrictionLevel.RESTRICTION_LEVEL_MASK;
        console.info('spoof check result', result);
        // deviation
        if (regexes_1.deviation.test(label)) {
            console.info('deviation');
            return false;
        }
        console.log(this.restrictionLevel, enums_1.RestrictionLevel.ASCII);
        // ascii
        if (result === enums_1.RestrictionLevel.ASCII) {
            console.info('ascii, return');
            return true;
        }
        // single script
        if (result === enums_1.RestrictionLevel.SINGLE_SCRIPT_RESTRICTIVE &&
            !regexes_1.kanaCharacterException.test(label) &&
            !regexes_1.combiningDiacriticException.test(label)) {
            // Check Cyrillic confusable only for ASCII TLDs.
            return !isTldAscii || !this.isMadeOfLatinAlikeCyrillic(label);
        }
        console.info('multiple script');
        if (regexes_1.nonAsciiLatin.test(label) && !regexes_1.latinGreekCyrillicAscii.test(label)) {
            return false;
        }
        console.log('dangerous patterns');
        return !regexes_1.dangerousPatterns.some(d => d.test(label));
    }
    check(input) {
        let result = 0;
        const checkResult = new check_result_1.CheckResult();
        if ((this.checks & enums_1.SpoofChecks.RESTRICTION_LEVEL) !== 0) {
            const restrictionLevel = this.getRestrictionLevel(input);
            if (restrictionLevel > this.restrictionLevel) {
                result |= enums_1.SpoofChecks.RESTRICTION_LEVEL;
            }
            checkResult.restrictionLevel = restrictionLevel;
            console.log('SpoofChecks.RESTRICTION_LEVEL result ', result.toString(2));
        }
        if (0 !== (this.checks & enums_1.SpoofChecks.MIXED_NUMBERS)) {
            // console.log('MIXED_NUMBERS', result)
            const numerics = this.getNumerics(input);
            if (numerics.length > 1) {
                result |= enums_1.SpoofChecks.MIXED_NUMBERS;
            }
            checkResult.numerics = numerics;
            console.log('MIXED_NUMBERS result ', result.toString(2));
        }
        if (0 !== (this.checks & enums_1.SpoofChecks.CHAR_LIMIT)) {
            // console.log('CHAR_LIMIT', result);
            for (let i = 0; i < input.length;) {
                i++;
                if (!regexes_1.allowed.test(input[i])) {
                    result |= enums_1.SpoofChecks.CHAR_LIMIT;
                    break;
                }
            }
            console.log('CHAR_LIMIT result ', result.toString(2));
        }
        if (0 !== (this.checks & enums_1.SpoofChecks.INVISIBLE)) {
            // console.log('INVISIBLE', result);
            // This check needs to be done on NFD input
            const nfdText = input.normalize('NFD');
            const nfdLength = nfdText.length;
            // scan for more than one occurence of the same non-spacing mark
            // in a sequence of non-spacing marks.
            let i;
            let c;
            let firstNonspacingMark = 0;
            let haveMultipleMarks = false;
            let marksSeenSoFar = []; // Set of combining marks in a single combining sequence.
            for (i = 0; i < nfdLength;) {
                c = nfdText.charCodeAt(i);
                i++;
                if (!categories_1.nonSpacingMark.test(nfdText[i])) {
                    firstNonspacingMark = 0;
                    if (haveMultipleMarks) {
                        console.log('multiple marks');
                        marksSeenSoFar = [];
                        haveMultipleMarks = false;
                    }
                    continue;
                }
                if (firstNonspacingMark === 0) {
                    firstNonspacingMark = c;
                    continue;
                }
                if (!haveMultipleMarks) {
                    marksSeenSoFar.push(firstNonspacingMark);
                    haveMultipleMarks = true;
                }
                if (marksSeenSoFar.indexOf(c) > -1) {
                    // report the error, and stop scanning.
                    // No need to find more than the first failure.
                    result |= enums_1.SpoofChecks.INVISIBLE;
                    break;
                }
                marksSeenSoFar.push(c);
            }
        }
        console.log('INVISIBLE result ', result);
        checkResult.checks = result;
        return checkResult.toCombinedBitmask(this.checks);
    }
    getRestrictionLevel(input) {
        console.log('getRestrictionLevel');
        if (!Array.from(input).every(character => regexes_1.allowed.test(character) && !regexes_1.removed.test(character))) {
            console.log('UNRESTRICTIVE');
            return enums_1.RestrictionLevel.UNRESTRICTIVE;
        }
        let ascii = true;
        for (let i = 0; i < input.length; i++) {
            if (input.charCodeAt(i) > 0x7f) {
                console.log('Not all ascii');
                ascii = false;
                break;
            }
        }
        if (ascii) {
            console.log('ASCII', enums_1.RestrictionLevel.ASCII);
            return enums_1.RestrictionLevel.ASCII;
        }
        const scriptResolver = new script_resolver_1.ScriptResolver(input);
        console.log('scriptResolver', scriptResolver);
        if (scriptResolver.singleScript()) {
            console.log('SINGLE_SCRIPT_RESTRICTIVE');
            return enums_1.RestrictionLevel.SINGLE_SCRIPT_RESTRICTIVE;
        }
        else {
            console.log('HIGHLY_RESTRICTIVE');
            return enums_1.RestrictionLevel.HIGHLY_RESTRICTIVE;
        }
    }
    getNumerics(input) {
        console.log('getNumerics');
        const result = [];
        let charCode;
        for (let i = 0; i < input.length; i++) {
            charCode = input.charCodeAt(i);
            if (categories_1.decimalDigitNumber.test(input[i])) {
                console.log('Decimal digit', 'Charcode: ' + charCode, 'Character: ' + input[i]);
                const zero = String.fromCharCode(charCode - parseInt(input[i], 16));
                console.log('Zero character', zero);
                if (result.includes(zero)) {
                    continue;
                }
                result.push(zero);
            }
        }
        console.log('getNumerics result', result);
        return result;
    }
    isMadeOfLatinAlikeCyrillic(label) {
        const cyrillicInLabel = Array.from(label).filter(character => unicode_1.scripts.cyrillic.test(character));
        return (cyrillicInLabel.length > 0 &&
            cyrillicInLabel.every(character => {
                return regexes_1.cyrillicLikeLatin.test(character);
            }));
    }
}
exports.SpoofChecker = SpoofChecker;
//# sourceMappingURL=spoof-checker.js.map