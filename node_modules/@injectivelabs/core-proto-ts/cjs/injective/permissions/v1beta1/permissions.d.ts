import _m0 from "protobufjs/minimal";
import { Coin } from "../../../cosmos/base/v1beta1/coin";
export declare const protobufPackage = "injective.permissions.v1beta1";
/** each Action enum value should be a power of two */
export declare enum Action {
    UNSPECIFIED = 0,
    MINT = 1,
    RECEIVE = 2,
    BURN = 4,
    UNRECOGNIZED = -1
}
export declare function actionFromJSON(object: any): Action;
export declare function actionToJSON(object: Action): string;
/** Namespace defines a permissions namespace */
export interface Namespace {
    /** tokenfactory denom to which this namespace applies to */
    denom: string;
    /** address of smart contract to apply code-based restrictions */
    wasmHook: string;
    mintsPaused: boolean;
    sendsPaused: boolean;
    burnsPaused: boolean;
    /** permissions for each role */
    rolePermissions: Role[];
    addressRoles: AddressRoles[];
}
export interface AddressRoles {
    address: string;
    roles: string[];
}
/** Role is only used for storage */
export interface Role {
    role: string;
    permissions: number;
}
/** used in storage */
export interface RoleIDs {
    roleIds: number[];
}
export interface Voucher {
    coins: Coin[];
}
export interface AddressVoucher {
    address: string;
    voucher: Voucher | undefined;
}
export declare const Namespace: {
    encode(message: Namespace, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Namespace;
    fromJSON(object: any): Namespace;
    toJSON(message: Namespace): unknown;
    create(base?: DeepPartial<Namespace>): Namespace;
    fromPartial(object: DeepPartial<Namespace>): Namespace;
};
export declare const AddressRoles: {
    encode(message: AddressRoles, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): AddressRoles;
    fromJSON(object: any): AddressRoles;
    toJSON(message: AddressRoles): unknown;
    create(base?: DeepPartial<AddressRoles>): AddressRoles;
    fromPartial(object: DeepPartial<AddressRoles>): AddressRoles;
};
export declare const Role: {
    encode(message: Role, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Role;
    fromJSON(object: any): Role;
    toJSON(message: Role): unknown;
    create(base?: DeepPartial<Role>): Role;
    fromPartial(object: DeepPartial<Role>): Role;
};
export declare const RoleIDs: {
    encode(message: RoleIDs, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): RoleIDs;
    fromJSON(object: any): RoleIDs;
    toJSON(message: RoleIDs): unknown;
    create(base?: DeepPartial<RoleIDs>): RoleIDs;
    fromPartial(object: DeepPartial<RoleIDs>): RoleIDs;
};
export declare const Voucher: {
    encode(message: Voucher, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Voucher;
    fromJSON(object: any): Voucher;
    toJSON(message: Voucher): unknown;
    create(base?: DeepPartial<Voucher>): Voucher;
    fromPartial(object: DeepPartial<Voucher>): Voucher;
};
export declare const AddressVoucher: {
    encode(message: AddressVoucher, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): AddressVoucher;
    fromJSON(object: any): AddressVoucher;
    toJSON(message: AddressVoucher): unknown;
    create(base?: DeepPartial<AddressVoucher>): AddressVoucher;
    fromPartial(object: DeepPartial<AddressVoucher>): AddressVoucher;
};
type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;
export type DeepPartial<T> = T extends Builtin ? T : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
export {};
