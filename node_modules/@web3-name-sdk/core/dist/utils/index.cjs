"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/utils/index.ts
var utils_exports = {};
__export(utils_exports, {
  countCharacters: () => countCharacters,
  labelhash: () => labelhash,
  namehash: () => import_viem4.namehash,
  normalize: () => normalize,
  tldNamehash: () => tldNamehash,
  validateName: () => validateName
});
module.exports = __toCommonJS(utils_exports);
var import_viem4 = require("viem");

// src/utils/labels.ts
var import_viem = require("viem");
function isEncodedLabelhash(hash) {
  return hash.startsWith("[") && hash.endsWith("]") && hash.length === 66;
}
function labelhash(unnormalizedLabelOrLabelhash) {
  return (0, import_viem.labelhash)(unnormalizedLabelOrLabelhash);
}

// src/utils/namehash.ts
var import_ens_normalize = require("@adraffy/ens-normalize");
var import_viem2 = require("viem");
var normalize = (name) => name ? (0, import_ens_normalize.ens_normalize)(name) : name;
function tldNamehash(inputName, identifier) {
  if (!identifier)
    return (0, import_viem2.namehash)(inputName);
  const fullNameNode = `${inputName}.[${(0, import_viem2.toHex)(identifier, { size: 32 }).slice(2)}]`;
  return (0, import_viem2.namehash)(fullNameNode);
}

// src/constants/whitelist.ts
var whitelist_default = [
  "cz.bnb",
  "id.bnb",
  "sm.bnb",
  "yg.bnb",
  "cz.eth.bnb",
  "id.eth.bnb",
  "sm.eth.bnb",
  "yg.eth.bnb",
  "go.arb"
];

// src/utils/validate.ts
var import_ens_normalize2 = require("@adraffy/ens-normalize");
var import_ens_validation = require("@ensdomains/ens-validation");

// src/utils/common.ts
var import_viem3 = require("viem");
var import_chains = require("viem/chains");
var v2Tlds = /* @__PURE__ */ new Set(["bnb", "arb", "eth"]);
function isV2Tld(tld) {
  return v2Tlds.has(tld);
}

// src/utils/validate.ts
function validateName(name) {
  if (!name) {
    throw new Error("Invalid name");
  }
  const labelArr = name.split(".");
  let domain = name;
  let suffix = "";
  if (labelArr.length > 1) {
    domain = labelArr.slice(0, labelArr.length - 1).join(".");
    suffix = labelArr[labelArr.length - 1];
  }
  if (labelArr.length === 3 && suffix.toLowerCase() === "bnb" && labelArr[1].toLowerCase() === "eth") {
    domain = labelArr[0];
  }
  const hasEmptyLabels = labelArr.filter((e) => e.length < 1).length > 0;
  if (hasEmptyLabels)
    throw new Error("Domain cannot have empty labels");
  if (!validateLabelLength(domain, !isV2Tld(suffix)) && !whitelist_default.includes(name.toLowerCase())) {
    throw new Error("Invalid name");
  }
  if (!validateDomains(domain))
    throw new Error("Invalid name");
  const normalizedArray = labelArr.map((label) => {
    return isEncodedLabelhash(label) ? label : normalize(label);
  });
  try {
    return normalizedArray.join(".");
  } catch (e) {
    throw e;
  }
}
function validateLabelLength(name, allowShortLabel = false) {
  if (!name) {
    return false;
  }
  const len = countCharacters(name);
  if (len > 512 || !allowShortLabel && len < 3) {
    return false;
  }
  let normalizedValue;
  try {
    normalizedValue = normalize(name);
  } catch (e) {
    normalizedValue = name;
  }
  if (normalizedValue.length > 512 || !allowShortLabel && len < 3) {
    return false;
  }
  return true;
}
function validateDomains(value) {
  const nospecial = /^[^*|\\":<>[\]{}`\\\\()';@&$]+$/u;
  const blackList = /[\u0000-\u002c\u002e-\u002f\u003a-\u005e\u0060\u007b-\u007f\u200b\u200c\u200d\ufeff]/g;
  return nospecial.test(value) && !blackList.test(value) && (0, import_ens_validation.validate)(value);
}
function countCharacters(str) {
  const normalizedStr = (0, import_ens_normalize2.ens_normalize)(str);
  const regex = /[\u0000-\uffff]|\p{L}|\p{Emoji}(?!\p{M})/gu;
  const matches = normalizedStr.match(regex);
  return matches ? matches.length : 0;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  countCharacters,
  labelhash,
  namehash,
  normalize,
  tldNamehash,
  validateName
});
