// src/tlds/web3name/index.ts
import { createPublicClient as createPublicClient4, http as http4, namehash as namehash4 } from "viem";
import { normalize as normalize2 } from "viem/ens";

// src/utils/common.ts
import { createPublicClient, http } from "viem";
import { mainnet, goerli, sepolia } from "viem/chains";
function createCustomClient(tldInfo, rpcUrl) {
  const client = createPublicClient({
    chain: {
      id: Number(tldInfo.chainId),
      rpcUrls: {
        default: { http: [rpcUrl || tldInfo.defaultRpc] },
        public: { http: [rpcUrl || tldInfo.defaultRpc] }
      },
      name: "",
      network: "",
      nativeCurrency: {
        decimals: 18,
        name: "",
        symbol: ""
      }
    },
    transport: http()
  });
  return client;
}
var v2Tlds = /* @__PURE__ */ new Set(["bnb", "arb", "eth"]);
function isV2Tld(tld) {
  return v2Tlds.has(tld);
}
function isEthChain(chainId) {
  const ethChains = /* @__PURE__ */ new Set([mainnet.id, goerli.id, sepolia.id]);
  return ethChains.has(chainId);
}
function getChainFromId(chainId) {
  switch (chainId) {
    case 1:
      return mainnet;
    case 5:
      return goerli;
    case 11155111:
      return sepolia;
    default:
      return mainnet;
  }
}
function getBaseContractFromChainId(chainId) {
  switch (chainId) {
    case 1:
    case 11155111:
      return "0x57f1887a8bf19b14fc0df6fd9b2acc9af147ea85";
    case 56:
      return "0xE3b1D32e43Ce8d658368e2CBFF95D57Ef39Be8a6";
    case 97:
      return "0x888A2BA9787381000Cd93CA4bd23bB113f03C5Af";
    case 42161:
      return "0x5d482d501b369f5ba034dec5c5fb7a50d2d6ca20";
    default:
      return "0x57f1887a8bf19b14fc0df6fd9b2acc9af147ea85";
  }
}

// src/utils/contract.ts
import {
  createPublicClient as createPublicClient2,
  getContract,
  toFunctionSelector,
  hexToBigInt,
  hexToNumber,
  http as http2,
  keccak256
} from "viem";
import { bscTestnet, mainnet as mainnet2 } from "viem/chains";

// src/abi/Resolver.ts
var ResolverAbi = [
  {
    inputs: [{ internalType: "bytes32", name: "node", type: "bytes32" }],
    name: "name",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "bytes32", name: "node", type: "bytes32" },
      { internalType: "uint256", name: "identifier", type: "uint256" }
    ],
    name: "tldName",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "bytes32", name: "node", type: "bytes32" },
      { internalType: "string", name: "key", type: "string" }
    ],
    name: "text",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "bytes32", name: "node", type: "bytes32" },
      { internalType: "uint256", name: "contentTypes", type: "uint256" }
    ],
    name: "ABI",
    outputs: [
      { internalType: "uint256", name: "", type: "uint256" },
      { internalType: "bytes", name: "", type: "bytes" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "bytes32", name: "node", type: "bytes32" }],
    name: "addr",
    outputs: [{ internalType: "address payable", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "bytes32", name: "node", type: "bytes32" },
      { internalType: "uint256", name: "coinType", type: "uint256" }
    ],
    name: "addr",
    outputs: [{ internalType: "bytes", name: "", type: "bytes" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "bytes32", name: "node", type: "bytes32" }],
    name: "contenthash",
    outputs: [{ internalType: "bytes", name: "", type: "bytes" }],
    stateMutability: "view",
    type: "function"
  }
];

// src/abi/ReverseResolver.ts
var ReverseResolverAbi = [
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      }
    ],
    name: "name",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// src/abi/SANN.ts
var SANNContractAbi = [
  {
    inputs: [{ internalType: "uint256", name: "identifier", type: "uint256" }],
    name: "tldBase",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  }
];

// src/abi/SIDRegistry.ts
var SIDRegistryAbi = [
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      }
    ],
    name: "resolver",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// src/abi/TldBase.ts
var TldBaseContractAbi = [
  {
    inputs: [{ internalType: "uint256", name: "tokenId", type: "uint256" }],
    name: "tokenURI",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "view",
    type: "function"
  }
];

// src/abi/VerifiedTldHub.ts
var VerifiedTldHubAbi = [
  {
    inputs: [{ internalType: "uint256", name: "chainId", type: "uint256" }],
    name: "getChainInfo",
    outputs: [
      {
        components: [
          { internalType: "uint256", name: "chainId", type: "uint256" },
          { internalType: "string", name: "defaultRpc", type: "string" },
          { internalType: "address", name: "registry", type: "address" },
          { internalType: "address", name: "sann", type: "address" }
        ],
        internalType: "struct VerifiedTldHub.chainInfo",
        name: "",
        type: "tuple"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint256", name: "chainId", type: "uint256" }],
    name: "getChainTlds",
    outputs: [{ internalType: "string[]", name: "", type: "string[]" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "string[]", name: "tlds", type: "string[]" }],
    name: "getTldInfo",
    outputs: [
      {
        components: [
          { internalType: "string", name: "tld", type: "string" },
          { internalType: "uint256", name: "identifier", type: "uint256" },
          { internalType: "uint256", name: "chainId", type: "uint256" },
          { internalType: "string", name: "defaultRpc", type: "string" },
          { internalType: "address", name: "registry", type: "address" },
          { internalType: "address", name: "sann", type: "address" }
        ],
        internalType: "struct VerifiedTldHub.completeTldInfo[]",
        name: "",
        type: "tuple[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getTlds",
    outputs: [{ internalType: "string[]", name: "", type: "string[]" }],
    stateMutability: "view",
    type: "function"
  }
];

// src/constants/contracts.ts
var CONTRACTS = {
  verifiedTldHub: "0x754D6827A57334143eD5fB58C5b1A4aAe4396ba5",
  verifiedTldHubTest: "0x123c784946a9b649FB1268D589E41bc7BF658725"
};

// src/utils/contract.ts
var ContractReader = class {
  constructor(isDev, rpcUrl) {
    this.isDev = isDev;
    this.rpcUrl = rpcUrl ?? "https://rpc.ankr.com/eth";
  }
  /** Get verified TLD hub contract */
  getVerifiedTldHubContract() {
    const ethClient = createPublicClient2({
      chain: this.isDev ? bscTestnet : mainnet2,
      transport: http2(this.isDev ? void 0 : this.rpcUrl)
    });
    const hubContract = getContract({
      address: this.isDev ? CONTRACTS.verifiedTldHubTest : CONTRACTS.verifiedTldHub,
      abi: VerifiedTldHubAbi,
      client: {
        public: ethClient
      }
    });
    return hubContract;
  }
  async getTldInfo(tldList) {
    const hubContract = this.getVerifiedTldHubContract();
    const tldInfoList = await hubContract.read.getTldInfo([tldList]);
    return tldInfoList.filter((e) => !!e.tld);
  }
  /**
   * Get resolver contract by TLD
   *
   * @export
   * @param {string} domain
   * @param {TldInfo} tldInfo
   * @param {string} [rpcUrl]
   * @return {*}
   */
  async getResolverContractByTld(namehash5, tldInfo, rpcUrl) {
    const client = createCustomClient(tldInfo, rpcUrl);
    const registryContract = getContract({
      address: tldInfo.registry,
      abi: SIDRegistryAbi,
      client: {
        public: client
      }
    });
    const resolverAddr = await registryContract.read.resolver([namehash5]);
    if (!hexToNumber(resolverAddr)) {
      throw "resolver address is null";
    }
    const resolverContract = getContract({
      address: resolverAddr,
      abi: ResolverAbi,
      client: {
        public: client
      }
    });
    return resolverContract;
  }
  /** Get reverse resolver contract (V2 only) */
  async getReverseResolverContract(reverseNamehash, tldInfo, rpcUrl) {
    if (!tldInfo.defaultRpc)
      return void 0;
    const client = createCustomClient(tldInfo, rpcUrl);
    const registryContract = getContract({
      address: tldInfo.registry,
      abi: SIDRegistryAbi,
      client: {
        public: client
      }
    });
    const resolverAddr = await registryContract.read.resolver([reverseNamehash]);
    const resolverContract = getContract({
      address: resolverAddr ?? "",
      abi: ReverseResolverAbi,
      client: {
        public: client
      }
    });
    return resolverContract;
  }
  async getTldMetadata(domain, tldInfo, rpcUrl) {
    const tokenId = hexToBigInt(keccak256(Buffer.from(domain.split(".")[0])));
    const client = createCustomClient(tldInfo, rpcUrl);
    const sannContract = getContract({
      address: tldInfo.sann,
      abi: SANNContractAbi,
      client: {
        public: client
      }
    });
    const tldBaseContractAddr = tldInfo.identifier === BigInt(0) ? getBaseContractFromChainId(Number(tldInfo.chainId)) : await sannContract.read.tldBase([BigInt(`${tldInfo.identifier}`)]);
    if (tldInfo.chainId === BigInt(mainnet2.id)) {
      return `https://metadata.ens.domains/mainnet/${tldBaseContractAddr}/${tokenId}`;
    }
    const tldBaseContract = getContract({
      address: tldBaseContractAddr,
      abi: TldBaseContractAbi,
      client: {
        public: client
      }
    });
    const metadata = await tldBaseContract.read.tokenURI([tokenId]);
    return metadata;
  }
  // Read content hash from resolver contract
  async getContenthash(namehash5, tldInfo, rpcUrl) {
    const resolver = await this.getResolverContractByTld(namehash5, tldInfo, rpcUrl);
    const functionExists = await this.resolverFunctionExists(resolver.address, "contenthash(bytes32)", tldInfo, rpcUrl);
    if (!functionExists)
      return void 0;
    const contentHash = await resolver.read.contenthash([namehash5]);
    return contentHash;
  }
  // Read content hash from resolver contract
  async getABI(namehash5, tldInfo, rpcUrl) {
    const resolver = await this.getResolverContractByTld(namehash5, tldInfo, rpcUrl);
    const functionExists = await this.resolverFunctionExists(resolver.address, "ABI(bytes32, uint256)", tldInfo, rpcUrl);
    if (!functionExists)
      return void 0;
    const contentHash = await resolver.read.ABI([namehash5, BigInt(1)]);
    return contentHash;
  }
  async containsTldNameFunction(resolverAddr, tldInfo, rpcUrl) {
    const client = createCustomClient(tldInfo, rpcUrl);
    const bytecode = await client.getBytecode({ address: resolverAddr });
    const selector = toFunctionSelector("tldName(bytes32, uint256)");
    return bytecode?.includes(selector.slice(2)) ?? false;
  }
  async resolverFunctionExists(resolverAddr, functionName, tldInfo, rpcUrl) {
    const client = createCustomClient(tldInfo, rpcUrl);
    const bytecode = await client.getBytecode({ address: resolverAddr });
    const selector = toFunctionSelector(functionName);
    return bytecode?.includes(selector.slice(2)) ?? false;
  }
};

// src/utils/index.ts
import { namehash as namehash2 } from "viem";

// src/utils/labels.ts
import { labelhash as _labelhash } from "viem";
function isEncodedLabelhash(hash) {
  return hash.startsWith("[") && hash.endsWith("]") && hash.length === 66;
}

// src/utils/namehash.ts
import { ens_normalize } from "@adraffy/ens-normalize";
import { namehash, toHex } from "viem";
var normalize = (name) => name ? ens_normalize(name) : name;
function tldNamehash(inputName, identifier) {
  if (!identifier)
    return namehash(inputName);
  const fullNameNode = `${inputName}.[${toHex(identifier, { size: 32 }).slice(2)}]`;
  return namehash(fullNameNode);
}

// src/constants/whitelist.ts
var whitelist_default = [
  "cz.bnb",
  "id.bnb",
  "sm.bnb",
  "yg.bnb",
  "cz.eth.bnb",
  "id.eth.bnb",
  "sm.eth.bnb",
  "yg.eth.bnb",
  "go.arb"
];

// src/utils/validate.ts
import { ens_normalize as ens_normalize2 } from "@adraffy/ens-normalize";
import { validate as ensValidate } from "@ensdomains/ens-validation";
function validateName(name) {
  if (!name) {
    throw new Error("Invalid name");
  }
  const labelArr = name.split(".");
  let domain = name;
  let suffix = "";
  if (labelArr.length > 1) {
    domain = labelArr.slice(0, labelArr.length - 1).join(".");
    suffix = labelArr[labelArr.length - 1];
  }
  if (labelArr.length === 3 && suffix.toLowerCase() === "bnb" && labelArr[1].toLowerCase() === "eth") {
    domain = labelArr[0];
  }
  const hasEmptyLabels = labelArr.filter((e) => e.length < 1).length > 0;
  if (hasEmptyLabels)
    throw new Error("Domain cannot have empty labels");
  if (!validateLabelLength(domain, !isV2Tld(suffix)) && !whitelist_default.includes(name.toLowerCase())) {
    throw new Error("Invalid name");
  }
  if (!validateDomains(domain))
    throw new Error("Invalid name");
  const normalizedArray = labelArr.map((label) => {
    return isEncodedLabelhash(label) ? label : normalize(label);
  });
  try {
    return normalizedArray.join(".");
  } catch (e) {
    throw e;
  }
}
function validateLabelLength(name, allowShortLabel = false) {
  if (!name) {
    return false;
  }
  const len = countCharacters(name);
  if (len > 512 || !allowShortLabel && len < 3) {
    return false;
  }
  let normalizedValue;
  try {
    normalizedValue = normalize(name);
  } catch (e) {
    normalizedValue = name;
  }
  if (normalizedValue.length > 512 || !allowShortLabel && len < 3) {
    return false;
  }
  return true;
}
function validateDomains(value) {
  const nospecial = /^[^*|\\":<>[\]{}`\\\\()';@&$]+$/u;
  const blackList = /[\u0000-\u002c\u002e-\u002f\u003a-\u005e\u0060\u007b-\u007f\u200b\u200c\u200d\ufeff]/g;
  return nospecial.test(value) && !blackList.test(value) && ensValidate(value);
}
function countCharacters(str) {
  const normalizedStr = ens_normalize2(str);
  const regex = /[\u0000-\uffff]|\p{L}|\p{Emoji}(?!\p{M})/gu;
  const matches = normalizedStr.match(regex);
  return matches ? matches.length : 0;
}

// src/tlds/UD/index.ts
import { createPublicClient as createPublicClient3, getContract as getContract2, http as http3, namehash as namehash3 } from "viem";
import { polygon } from "viem/chains";

// src/abi/UD/ProxyReader.ts
var proxyReaderAbi = [
  {
    inputs: [
      { internalType: "string[]", name: "keys", type: "string[]" },
      { internalType: "uint256", name: "tokenId", type: "uint256" }
    ],
    name: "getMany",
    outputs: [{ internalType: "string[]", name: "values", type: "string[]" }],
    stateMutability: "view",
    type: "function"
  }
];

// src/abi/UD/UNSRegistry.ts
var unsRegistryAbi = [
  {
    inputs: [{ internalType: "address", name: "addr", type: "address" }],
    name: "reverseNameOf",
    outputs: [{ internalType: "string", name: "reverseUri", type: "string" }],
    stateMutability: "view",
    type: "function"
  }
];

// src/tlds/UD/index.ts
var UDResolver = class {
  constructor() {
    this.proxyReaderAddress = "0x423F2531bd5d3C3D4EF7C318c2D1d9BEDE67c680";
    this.unsRegistryAddress = "0xa9a6A3626993D487d2Dbda3173cf58cA1a9D9e9f";
  }
  /**
   * Resolve address from name
   * @param domain
   * @returns
   */
  async getAddress(domain) {
    const client = createPublicClient3({
      chain: polygon,
      transport: http3()
    });
    const proxyReaderContract = getContract2({
      address: this.proxyReaderAddress,
      abi: proxyReaderAbi,
      publicClient: client
    });
    const keys = ["crypto.ETH.address"];
    const res = await proxyReaderContract.read.getMany([keys, BigInt(namehash3(domain))]);
    return res.at(0) || null;
  }
  /**
   * Resolve name from address
   * @param address
   * @returns
   */
  async getName(address) {
    const client = createPublicClient3({
      chain: polygon,
      transport: http3()
    });
    const registryContract = getContract2({
      address: this.unsRegistryAddress,
      abi: unsRegistryAbi,
      publicClient: client
    });
    const res = await registryContract.read.reverseNameOf([address]);
    if (!res.endsWith(".crypto")) {
      return null;
    }
    return res;
  }
};

// src/tlds/lens/index.ts
var baseUrl = "https://api.lens.dev/";
var LensProtocol = class {
  static async getDomainName(address) {
    const gql = `
      query Profile($ethereumAddress: EthereumAddress!) {
        defaultProfile(request: { ethereumAddress: $ethereumAddress }) {
          id
          handle
        }
      }
    `;
    const res = await fetch(baseUrl, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        query: gql,
        variables: {
          ethereumAddress: address
        }
      })
    }).then((res2) => res2.json());
    return res.data.defaultProfile.handle;
  }
  static async getAddress(domain) {
    const gql = `
      query Profile ($handle: Handle!) {
        profile(request: { handle: $handle }) {
          id
          ownedBy
        }
      }
    `;
    const res = await fetch(baseUrl, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        query: gql,
        variables: {
          handle: domain
        }
      })
    }).then((res2) => res2.json());
    return res.data.profile.ownedBy;
  }
};

// src/tlds/web3name/index.ts
var Web3Name = class {
  constructor({ isDev = false, rpcUrl } = {}) {
    this.contractReader = new ContractReader(isDev, rpcUrl);
  }
  async getTldInfoList({ queryTldList, queryChainIdList }) {
    const hubContract = this.contractReader.getVerifiedTldHubContract();
    const chainTlds = [];
    for await (const chainId of queryChainIdList ?? []) {
      const tlds2 = await hubContract.read.getChainTlds([BigInt(chainId)]);
      if (isEthChain(chainId)) {
        const ethTld = tlds2.filter((e) => e !== "eth" /* ENS */).at(0);
        if (ethTld)
          chainTlds.push(ethTld);
        chainTlds.push("eth" /* ENS */);
      } else {
        const tldName = tlds2.at(0);
        if (tldName)
          chainTlds.push(tldName);
      }
    }
    const tlds = queryTldList ?? [];
    if (tlds.length === 0) {
      const allTlds = await hubContract.read.getTlds();
      tlds.push(...allTlds);
    }
    const reqTlds = queryChainIdList?.length ? chainTlds : tlds;
    return await this.contractReader.getTldInfo(reqTlds);
  }
  async getDomainNameByTld(address, reverseNamehash, tld, isTldName, rpcUrl) {
    let name = null;
    try {
      if (tld.tld === "eth" /* ENS */) {
        const contract = await this.contractReader.getReverseResolverContract(reverseNamehash, tld, rpcUrl);
        name = await contract?.read.name([reverseNamehash]) ?? "";
      } else {
        const contract = await this.contractReader.getResolverContractByTld(reverseNamehash, tld, rpcUrl);
        if (isTldName) {
          if (isV2Tld(tld.tld)) {
            const containsTldNameFunction = await this.contractReader.containsTldNameFunction(
              contract.address,
              tld,
              rpcUrl
            );
            if (containsTldNameFunction) {
              name = await contract.read.tldName([reverseNamehash, tld.identifier]);
            } else {
              name = await contract.read.name([reverseNamehash]);
            }
          } else {
            name = await contract.read.tldName([reverseNamehash, tld.identifier]);
          }
        } else {
          name = await contract.read.name([reverseNamehash]);
        }
      }
    } catch (error) {
    }
    if (name) {
      const reverseAddress = await this.getAddress(name, { rpcUrl });
      if (reverseAddress?.toLowerCase() === address.toLowerCase()) {
        return name;
      } else {
        return null;
      }
    }
    return name;
  }
  /**
   * Get domain name from address.
   * If queryChainIdList is specified, it will return domain name from that chain.
   * If queryTldList is specified, it will return domain name from that TLDs with the order.
   * If neither is specified, it will return domain name from all TLDs.
   * It's not recommended to use queryChainIdList and queryTldList together.
   *
   * @param {GetDomainNameProps} { address, queryChainIdList, queryTldList }
   * @return {*}  {(Promise<string | null>)}
   * @memberof Web3Name
   */
  async getDomainName({ address, queryChainIdList, queryTldList, rpcUrl }) {
    if (queryChainIdList?.length && queryTldList?.length) {
      console.warn("queryChainIdList and queryTldList cannot be used together, queryTldList will be ignored");
    }
    try {
      const reverseNode = `${normalize2(address).slice(2)}.addr.reverse`;
      const reverseNamehash = namehash4(reverseNode);
      const tldInfoList = await this.getTldInfoList({ queryChainIdList, queryTldList, rpcUrl });
      const resList = [];
      for await (const tld of tldInfoList) {
        if (!tld.tld)
          continue;
        const isTldName = !!queryTldList?.length;
        let name = await this.getDomainNameByTld(address, reverseNamehash, tld, isTldName, rpcUrl);
        if (name) {
          resList.push(name);
          break;
        }
      }
      if (queryTldList?.includes("lens" /* LENS */)) {
        const lensName = await LensProtocol.getDomainName(address);
        if (lensName)
          resList.push(lensName);
      } else if (queryTldList?.includes("crypto" /* CRYPTO */)) {
        const UD = new UDResolver();
        const udName = await UD.getName(address);
        if (udName)
          resList.push(udName);
      }
      return resList.at(0) ?? null;
    } catch (e) {
      console.log(`Error getting name for reverse record of ${address}`, e);
      return null;
    }
  }
  async batchGetDomainName({
    addressList,
    queryChainIdList,
    queryTldList,
    rpcUrl
  }) {
    if (queryChainIdList?.length && queryTldList?.length) {
      console.warn("queryChainIdList and queryTldList cannot be used together, queryTldList will be ignored");
    }
    if (!addressList.length)
      return [];
    let curAddr = addressList[0];
    try {
      const tldInfoList = await this.getTldInfoList({ queryChainIdList, queryTldList, rpcUrl });
      const resList = [];
      const isIncludeLens = queryTldList?.includes("lens" /* LENS */);
      const isIncludeCrypto = queryTldList?.includes("crypto" /* CRYPTO */);
      for await (const address of addressList) {
        curAddr = address;
        const reverseNode = `${normalize2(address).slice(2)}.addr.reverse`;
        const reverseNamehash = namehash4(reverseNode);
        let nameRes = null;
        for await (const tld of tldInfoList) {
          if (!tld.tld)
            continue;
          const isTldName = !!queryTldList?.length;
          nameRes = await this.getDomainNameByTld(address, reverseNamehash, tld, isTldName, rpcUrl);
          if (nameRes) {
            break;
          }
        }
        if (!nameRes && isIncludeLens) {
          nameRes = await LensProtocol.getDomainName(address);
        }
        if (!nameRes && isIncludeCrypto) {
          const UD = new UDResolver();
          nameRes = await UD.getName(address);
        }
        resList.push({ address, domain: nameRes });
      }
      return resList;
    } catch (e) {
      console.log(`Error getting name for reverse record of ${curAddr}`, e);
      return null;
    }
  }
  /**
   * Get address from name. If coinType is specified, it will return ENSIP-9 address for that coinType.
   *
   * @param {string} name
   * @param {{ coinType?: number; rpcUrl?: string }} { coinType, rpcUrl }
   * @return {*}  {(Promise<string | null>)}
   * @memberof Web3Name
   */
  async getAddress(name, { coinType, rpcUrl } = {}) {
    const tld = name.split(".").pop()?.toLowerCase();
    if (!tld) {
      return null;
    }
    const normalizedDomain = "lens" /* LENS */ === tld ? name : normalize2(name);
    if (tld !== "eth" /* ENS */ && tld !== "lens" /* LENS */ && tld !== "crypto" /* CRYPTO */) {
      validateName(normalizedDomain);
    }
    try {
      if (tld === "eth" /* ENS */) {
        const tldInfoList2 = await this.contractReader.getTldInfo([tld]);
        const publicClient = createPublicClient4({
          chain: getChainFromId(Number(tldInfoList2[0].chainId)),
          transport: http4()
        });
        return await publicClient.getEnsAddress({
          name: normalizedDomain
        });
      }
      if (tld === "lens" /* LENS */) {
        return await LensProtocol.getAddress(name);
      }
      if (tld === "crypto" /* CRYPTO */) {
        const UD = new UDResolver();
        return await UD.getAddress(name);
      }
      const tldInfoList = await this.contractReader.getTldInfo([tld]);
      const tldInfo = tldInfoList.at(0);
      if (!tldInfo) {
        throw "TLD not found";
      }
      const namehash5 = tldNamehash(normalizedDomain, isV2Tld(tld) ? void 0 : tldInfo.identifier);
      const resolverContract = await this.contractReader.getResolverContractByTld(namehash5, tldInfo, rpcUrl);
      const res = coinType !== void 0 ? await resolverContract.read.addr([namehash5, BigInt(coinType)]) : await resolverContract.read.addr([namehash5]);
      return res;
    } catch (error) {
      console.error(`Error getting address for ${name}`, error);
      return null;
    }
  }
  /**
   * Get available domain list from address.
   *
   * @param {GetDomainNameProps} { address, queryChainIdList, queryTldList }
   * @return {*}  {Promise<string[]>}
   * @memberof Web3Name
   */
  async getDomainNames({ address, queryChainIdList, queryTldList, rpcUrl }) {
    if (queryChainIdList?.length && queryTldList?.length) {
      console.warn("queryChainIdList and queryTldList cannot be used together, queryTldList will be ignored");
    }
    const resList = /* @__PURE__ */ new Set([]);
    try {
      const reverseNode = `${address.toLowerCase().slice(2)}.addr.reverse`;
      const reverseNamehash = namehash4(reverseNode);
      const hubContract = this.contractReader.getVerifiedTldHubContract();
      const chainTlds = [];
      for (const chainId of queryChainIdList ?? []) {
        const tlds2 = await hubContract.read.getChainTlds([BigInt(chainId)]);
        if (isEthChain(chainId)) {
          const ethTld = tlds2.filter((e) => e !== "eth" /* ENS */).at(0);
          if (ethTld)
            chainTlds.push(ethTld);
          chainTlds.push("eth" /* ENS */);
        } else {
          const tldName = tlds2.at(0);
          if (tldName)
            chainTlds.push(tldName);
        }
      }
      const tlds = queryTldList ?? [];
      if (tlds.length === 0) {
        const allTlds = await hubContract.read.getTlds();
        tlds.push(...allTlds);
      }
      const reqTlds = queryChainIdList?.length ? chainTlds : tlds;
      const tldInfoList = await this.contractReader.getTldInfo(reqTlds);
      for (const tld of tldInfoList) {
        if (!tld.tld)
          continue;
        let name = "";
        try {
          if (tld.tld === "eth" /* ENS */) {
            const contract = await this.contractReader.getReverseResolverContract(reverseNamehash, tld, rpcUrl);
            name = await contract?.read.name([reverseNamehash]) ?? "";
          } else {
            const contract = await this.contractReader.getResolverContractByTld(reverseNamehash, tld);
            if (queryTldList?.length) {
              if (isV2Tld(tld.tld)) {
                const containsTldNameFunction = await this.contractReader.containsTldNameFunction(contract.address, tld);
                if (!containsTldNameFunction)
                  throw "TLD name is not supported for this TLD";
              }
              name = await contract.read.tldName([reverseNamehash, tld.identifier]);
            } else {
              name = await contract.read.name([reverseNamehash]);
            }
          }
        } catch (error) {
          continue;
        }
        if (name) {
          const reverseAddress = await this.getAddress(name, { rpcUrl });
          if (reverseAddress === address) {
            resList.add(name);
          }
        }
      }
      if (queryTldList?.includes("lens" /* LENS */)) {
        const lensName = await LensProtocol.getDomainName(address);
        if (lensName)
          resList.add(lensName);
      } else if (queryTldList?.includes("crypto" /* CRYPTO */)) {
        const UD = new UDResolver();
        const name = await UD.getName(address);
        name && resList.add(name);
      }
      return Array.from(resList);
    } catch (e) {
      console.log(`Error getting name for reverse record of ${address}`, e);
      return [];
    }
  }
  /**
   * Get domain record from name and key.
   *
   * @param {{ name: string; key: string; rpcUrl?: string }} { name, key, rpcUrl }
   * @return {*}
   * @memberof Web3Name
   */
  async getDomainRecord({ name, key, rpcUrl }) {
    const tld = name.split(".").pop()?.toLowerCase();
    if (!tld) {
      return null;
    }
    try {
      const normalizedDomain = "lens" /* LENS */ === tld ? name : normalize2(name);
      const tldInfoList = await this.contractReader.getTldInfo([tld]);
      const tldInfo = tldInfoList[0];
      if (!tldInfo) {
        throw "TLD not found";
      }
      const namehash5 = tldNamehash(normalizedDomain, isV2Tld(tld) ? void 0 : tldInfo.identifier);
      const resolverContract = await this.contractReader.getResolverContractByTld(namehash5, tldInfo, rpcUrl);
      const record = await resolverContract.read.text([namehash5, key]);
      return record;
    } catch (error) {
      console.error(`Error getting address for ${name}`, error);
      return null;
    }
  }
  /**
   * Get domain metadata from name.
   *
   * @param {{ name: string; rpcUrl?: string }} { name, rpcUrl }
   * @return {*}
   * @memberof Web3Name
   */
  async getMetadata({ name, rpcUrl }) {
    const tld = name.split(".").pop()?.toLowerCase();
    if (!tld) {
      return null;
    }
    try {
      const tldInfo = await this.contractReader.getTldInfo([tld]);
      if (!tldInfo || !tldInfo.at(0)?.sann) {
        return null;
      }
      const metadata = await this.contractReader.getTldMetadata(name, tldInfo[0], rpcUrl);
      const res = await fetch(metadata).then((res2) => res2.json());
      return res;
    } catch (error) {
      console.error(`Error getting metadata for ${name}`, error);
    }
  }
  /**
   * Get domain avatar from name.
   *
   * @param {{ name: string; key: string; rpcUrl?: string }} { name, rpcUrl }
   * @return {*}
   * @memberof Web3Name
   */
  async getDomainAvatar({ name, rpcUrl }) {
    const metadata = await this.getMetadata({ name, rpcUrl });
    return metadata?.image;
  }
  /**
   * Get domain content hash from name.
   *
   * @param {{ name: string; rpcUrl?: string }} { name, rpcUrl }
   * @return {*}  {(Promise<string | undefined>)}
   * @memberof Web3Name
   */
  async getContentHash({ name, rpcUrl }) {
    const tld = name.split(".").pop()?.toLowerCase();
    if (!tld) {
      return void 0;
    }
    try {
      const tldInfo = (await this.contractReader.getTldInfo([tld])).at(0);
      if (!tldInfo)
        throw "TLD not found";
      const namehash5 = tldNamehash(normalize2(name), isV2Tld(tld) ? void 0 : tldInfo.identifier);
      const contenthash = await this.contractReader.getContenthash(namehash5, tldInfo, rpcUrl);
      if (!contenthash || contenthash === "0x")
        return void 0;
      return contenthash;
    } catch (error) {
      console.error(`Error getting content hash for ${name}`, error);
    }
  }
  /**
   * Retrieves the ABI (Application Binary Interface) for a given name on the Web3Name system.
   * @param name - The name for which to retrieve the ABI.
   * @param rpcUrl - Optional RPC URL to use for retrieving the ABI.
   * @returns The ABI for the specified name, or undefined if the TLD (Top-Level Domain) is not found.
   */
  // async getABI({ name, rpcUrl }: { name: string; rpcUrl?: string }) {
  //   const tld = name.split('.').pop()?.toLowerCase()
  //   if (!tld) {
  //     return undefined
  //   }
  //   try {
  //     const tldInfo = (await this.contractReader.getTldInfo([tld])).at(0)
  //     if (!tldInfo) throw 'TLD not found'
  //     const namehash = tldNamehash(normalize(name), isV2Tld(tld) ? undefined : tldInfo.identifier)
  //     const abi = await this.contractReader.getABI(namehash, tldInfo, rpcUrl)
  //     return abi
  //   } catch (error) {
  //     console.error(`Error getting content hash for ${name}`, error)
  //   }
  // }
};

// src/index.ts
function createWeb3Name({ isDev = false, rpcUrl } = {}) {
  return new Web3Name({ isDev, rpcUrl });
}
export {
  createWeb3Name
};
