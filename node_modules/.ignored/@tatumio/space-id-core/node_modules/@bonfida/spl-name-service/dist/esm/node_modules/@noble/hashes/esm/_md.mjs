import{exists as t,output as s}from"./_assert.mjs";import{Hash as e,createView as i,toBytes as n}from"./utils.mjs";const o=(t,s,e)=>t&s^~t&e,h=(t,s,e)=>t&s^t&e^s&e;class r extends e{constructor(t,s,e,n){super(),this.blockLen=t,this.outputLen=s,this.padOffset=e,this.isLE=n,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(t),this.view=i(this.buffer)}update(s){t(this);const{view:e,buffer:o,blockLen:h}=this,r=(s=n(s)).length;for(let t=0;t<r;){const n=Math.min(h-this.pos,r-t);if(n!==h)o.set(s.subarray(t,t+n),this.pos),this.pos+=n,t+=n,this.pos===h&&(this.process(e,0),this.pos=0);else{const e=i(s);for(;h<=r-t;t+=h)this.process(e,t)}}return this.length+=s.length,this.roundClean(),this}digestInto(e){t(this),s(e,this),this.finished=!0;const{buffer:n,view:o,blockLen:h,isLE:r}=this;let{pos:f}=this;n[f++]=128,this.buffer.subarray(f).fill(0),this.padOffset>h-f&&(this.process(o,0),f=0);for(let t=f;t<h;t++)n[t]=0;!function(t,s,e,i){if("function"==typeof t.setBigUint64)return t.setBigUint64(s,e,i);const n=BigInt(32),o=BigInt(4294967295),h=Number(e>>n&o),r=Number(e&o),f=i?4:0,u=i?0:4;t.setUint32(s+f,h,i),t.setUint32(s+u,r,i)}(o,h-8,BigInt(8*this.length),r),this.process(o,0);const u=i(e),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const l=c/4,p=this.get();if(l>p.length)throw new Error("_sha2: outputLen bigger than state");for(let t=0;t<l;t++)u.setUint32(4*t,p[t],r)}digest(){const{buffer:t,outputLen:s}=this;this.digestInto(t);const e=t.slice(0,s);return this.destroy(),e}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());const{blockLen:s,buffer:e,length:i,finished:n,destroyed:o,pos:h}=this;return t.length=i,t.pos=h,t.finished=n,t.destroyed=o,i%s&&t.buffer.set(e),t}}export{o as Chi,r as HashMD,h as Maj};
//# sourceMappingURL=_md.mjs.map
