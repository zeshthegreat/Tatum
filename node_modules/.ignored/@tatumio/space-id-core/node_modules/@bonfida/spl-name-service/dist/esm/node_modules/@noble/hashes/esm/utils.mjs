import{crypto as t}from"./crypto.mjs";import{bytes as e}from"./_assert.mjs";
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const n=t=>new DataView(t.buffer,t.byteOffset,t.byteLength),o=(t,e)=>t<<32-e|t>>>e;function r(t){if("string"!=typeof t)throw new Error("utf8ToBytes expected string, got "+typeof t);return new Uint8Array((new TextEncoder).encode(t))}function u(t){return"string"==typeof t&&(t=r(t)),e(t),t}class f{clone(){return this._cloneInto()}}function s(t){const e=e=>t().update(u(e)).digest(),n=t();return e.outputLen=n.outputLen,e.blockLen=n.blockLen,e.create=()=>t(),e}function c(e=32){if(t&&"function"==typeof t.getRandomValues)return t.getRandomValues(new Uint8Array(e));throw new Error("crypto.getRandomValues must be defined")}export{f as Hash,n as createView,c as randomBytes,o as rotr,u as toBytes,r as utf8ToBytes,s as wrapConstructor};
//# sourceMappingURL=utils.mjs.map
