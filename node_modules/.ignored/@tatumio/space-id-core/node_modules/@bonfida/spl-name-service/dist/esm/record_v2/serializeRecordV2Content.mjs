import{PublicKey as e}from"@solana/web3.js";import{encode as r}from"../node_modules/punycode/punycode.es6.mjs";import{bech32 as o}from"../node_modules/@scure/base/lib/esm/index.mjs";import{i as t}from"../node_modules/ipaddr.js/lib/ipaddr.mjs";import{check as s}from"../utils/check.mjs";import{Record as n}from"../types/record.mjs";import{InvalidEvmAddressError as m,InvalidInjectiveAddressError as f,InvalidARecordError as i,InvalidAAAARecordError as d,InvalidRecordInputError as u}from"../error.mjs";import"../node_modules/buffer/index.mjs";import{UTF8_ENCODED as c,EVM_RECORDS as p}from"./const.mjs";import{__exports as a}from"../_virtual/index.mjs";const l=(l,h)=>{if(c.has(h))return h!==n.CNAME&&h!==n.TXT||(l=r(l)),a.Buffer.from(l,"utf-8");if(h===n.SOL)return new e(l).toBuffer();if(p.has(h))return s("0x"===l.slice(0,2),new m("The record content must start with `0x`")),a.Buffer.from(l.slice(2),"hex");if(h===n.Injective){const e=o.decodeToBytes(l);return s("inj"===e.prefix,new f("The record content must start with `inj")),s(20===e.bytes.length,new f("The record data must be 20 bytes long")),a.Buffer.from(e.bytes)}if(h===n.A){const e=t.parse(l).toByteArray();return s(4===e.length,new i("The record content must be 4 bytes long")),a.Buffer.from(e)}if(h===n.AAAA){const e=t.parse(l).toByteArray();return s(16===e.length,new d("The record content must be 16 bytes long")),a.Buffer.from(e)}throw new u("The record content is malformed")};export{l as serializeRecordV2Content};
//# sourceMappingURL=serializeRecordV2Content.mjs.map
