import{bitMask as t,numberToBytesLE as r,numberToBytesBE as n,bytesToNumberLE as e,bytesToNumberBE as o,validateObject as i}from"./utils.mjs";
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const u=BigInt(0),s=BigInt(1),f=BigInt(2),c=BigInt(3),l=BigInt(4),d=BigInt(5),w=BigInt(8);function g(t,r){const n=t%r;return n>=u?n:r+n}function E(t,r,n){if(n<=u||r<u)throw new Error("Expected power/modulo > 0");if(n===s)return u;let e=s;for(;r>u;)r&s&&(e=e*t%n),t=t*t%n,r>>=s;return e}function q(t,r,n){let e=t;for(;r-- >u;)e*=e,e%=n;return e}function h(t,r){if(t===u||r<=u)throw new Error(`invert: expected positive integers, got n=${t} mod=${r}`);let n=g(t,r),e=r,o=u,i=s;for(;n!==u;){const t=e%n,r=o-i*(e/n);e=n,n=t,o=i,i=r}if(e!==s)throw new Error("invert: does not exist");return g(o,r)}function p(t){const r=(t-s)/f;let n,e,o;for(n=t-s,e=0;n%f===u;n/=f,e++);for(o=f;o<t&&E(o,r,t)!==t-s;o++);if(1===e){const r=(t+s)/l;return function(t,n){const e=t.pow(n,r);if(!t.eql(t.sqr(e),n))throw new Error("Cannot find square root");return e}}const i=(n+s)/f;return function(t,u){if(t.pow(u,r)===t.neg(t.ONE))throw new Error("Cannot find square root");let f=e,c=t.pow(t.mul(t.ONE,o),n),l=t.pow(u,i),d=t.pow(u,n);for(;!t.eql(d,t.ONE);){if(t.eql(d,t.ZERO))return t.ZERO;let r=1;for(let n=t.sqr(d);r<f&&!t.eql(n,t.ONE);r++)n=t.sqr(n);const n=t.pow(c,s<<BigInt(f-r-1));c=t.sqr(n),l=t.mul(l,n),d=t.mul(d,c),f=r}return l}}function m(t){if(t%l===c){const r=(t+s)/l;return function(t,n){const e=t.pow(n,r);if(!t.eql(t.sqr(e),n))throw new Error("Cannot find square root");return e}}if(t%w===d){const r=(t-d)/w;return function(t,n){const e=t.mul(n,f),o=t.pow(e,r),i=t.mul(n,o),u=t.mul(t.mul(i,f),o),s=t.mul(i,t.sub(u,t.ONE));if(!t.eql(t.sqr(s),n))throw new Error("Cannot find square root");return s}}return p(t)}BigInt(9),BigInt(16);const a=(t,r)=>(g(t,r)&s)===s,B=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function O(t){const r=B.reduce(((t,r)=>(t[r]="function",t)),{ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"});return i(t,r)}function N(t,r,n){if(n<u)throw new Error("Expected power > 0");if(n===u)return t.ONE;if(n===s)return r;let e=t.ONE,o=r;for(;n>u;)n&s&&(e=t.mul(e,o)),o=t.sqr(o),n>>=s;return e}function I(t,r){const n=new Array(r.length),e=r.reduce(((r,e,o)=>t.is0(e)?r:(n[o]=r,t.mul(r,e))),t.ONE),o=t.inv(e);return r.reduceRight(((r,e,o)=>t.is0(e)?r:(n[o]=t.mul(r,n[o]),t.mul(r,e))),o),n}function v(t,r){const n=void 0!==r?r:t.toString(2).length;return{nBitLength:n,nByteLength:Math.ceil(n/8)}}function b(i,f,c=!1,l={}){if(i<=u)throw new Error(`Expected Field ORDER > 0, got ${i}`);const{nBitLength:d,nByteLength:w}=v(i,f);if(w>2048)throw new Error("Field lengths over 2048 bytes are not supported");const E=m(i),q=Object.freeze({ORDER:i,BITS:d,BYTES:w,MASK:t(d),ZERO:u,ONE:s,create:t=>g(t,i),isValid:t=>{if("bigint"!=typeof t)throw new Error("Invalid field element: expected bigint, got "+typeof t);return u<=t&&t<i},is0:t=>t===u,isOdd:t=>(t&s)===s,neg:t=>g(-t,i),eql:(t,r)=>t===r,sqr:t=>g(t*t,i),add:(t,r)=>g(t+r,i),sub:(t,r)=>g(t-r,i),mul:(t,r)=>g(t*r,i),pow:(t,r)=>N(q,t,r),div:(t,r)=>g(t*h(r,i),i),sqrN:t=>t*t,addN:(t,r)=>t+r,subN:(t,r)=>t-r,mulN:(t,r)=>t*r,inv:t=>h(t,i),sqrt:l.sqrt||(t=>E(q,t)),invertBatch:t=>I(q,t),cmov:(t,r,n)=>n?r:t,toBytes:t=>c?r(t,w):n(t,w),fromBytes:t=>{if(t.length!==w)throw new Error(`Fp.fromBytes: expected ${w}, got ${t.length}`);return c?e(t):o(t)}});return Object.freeze(q)}function R(t,r){if(!t.isOdd)throw new Error("Field doesn't have isOdd");const n=t.sqrt(r);return t.isOdd(n)?t.neg(n):n}export{b as Field,I as FpInvertBatch,N as FpPow,m as FpSqrt,R as FpSqrtEven,h as invert,a as isNegativeLE,g as mod,v as nLength,E as pow,q as pow2,p as tonelliShanks,O as validateField};
//# sourceMappingURL=modular.mjs.map
