{"version":3,"file":"deserialize.mjs","sources":["../../../../../../node_modules/borsh/lib/esm/deserialize.js"],"sourcesContent":["import { integers } from './types.js';\nimport { DecodeBuffer } from './buffer.js';\nvar BorshDeserializer = /** @class */ (function () {\n    function BorshDeserializer(bufferArray) {\n        this.buffer = new DecodeBuffer(bufferArray);\n    }\n    BorshDeserializer.prototype.decode = function (schema) {\n        return this.decode_value(schema);\n    };\n    BorshDeserializer.prototype.decode_value = function (schema) {\n        if (typeof schema === 'string') {\n            if (integers.includes(schema))\n                return this.decode_integer(schema);\n            if (schema === 'string')\n                return this.decode_string();\n            if (schema === 'bool')\n                return this.decode_boolean();\n        }\n        if (typeof schema === 'object') {\n            if ('option' in schema)\n                return this.decode_option(schema);\n            if ('enum' in schema)\n                return this.decode_enum(schema);\n            if ('array' in schema)\n                return this.decode_array(schema);\n            if ('set' in schema)\n                return this.decode_set(schema);\n            if ('map' in schema)\n                return this.decode_map(schema);\n            if ('struct' in schema)\n                return this.decode_struct(schema);\n        }\n        throw new Error(\"Unsupported type: \".concat(schema));\n    };\n    BorshDeserializer.prototype.decode_integer = function (schema) {\n        var size = parseInt(schema.substring(1));\n        if (size <= 32 || schema == 'f64') {\n            return this.buffer.consume_value(schema);\n        }\n        return this.decode_bigint(size, schema.startsWith('i'));\n    };\n    BorshDeserializer.prototype.decode_bigint = function (size, signed) {\n        if (signed === void 0) { signed = false; }\n        var buffer_len = size / 8;\n        var buffer = new Uint8Array(this.buffer.consume_bytes(buffer_len));\n        var bits = buffer.reduceRight(function (r, x) { return r + x.toString(16).padStart(2, '0'); }, '');\n        if (signed && buffer[buffer_len - 1]) {\n            return BigInt.asIntN(size, BigInt(\"0x\".concat(bits)));\n        }\n        return BigInt(\"0x\".concat(bits));\n    };\n    BorshDeserializer.prototype.decode_string = function () {\n        var len = this.decode_integer('u32');\n        var buffer = new Uint8Array(this.buffer.consume_bytes(len));\n        // decode utf-8 string without using TextDecoder\n        // first get all bytes to single byte code points\n        var codePoints = [];\n        for (var i = 0; i < len; ++i) {\n            var byte = buffer[i];\n            if (byte < 0x80) {\n                codePoints.push(byte);\n            }\n            else if (byte < 0xE0) {\n                codePoints.push(((byte & 0x1F) << 6) | (buffer[++i] & 0x3F));\n            }\n            else if (byte < 0xF0) {\n                codePoints.push(((byte & 0x0F) << 12) | ((buffer[++i] & 0x3F) << 6) | (buffer[++i] & 0x3F));\n            }\n            else {\n                var codePoint = ((byte & 0x07) << 18) | ((buffer[++i] & 0x3F) << 12) | ((buffer[++i] & 0x3F) << 6) | (buffer[++i] & 0x3F);\n                codePoints.push(codePoint);\n            }\n        }\n        // then decode code points to utf-8\n        return String.fromCodePoint.apply(String, codePoints);\n    };\n    BorshDeserializer.prototype.decode_boolean = function () {\n        return this.buffer.consume_value('u8') > 0;\n    };\n    BorshDeserializer.prototype.decode_option = function (schema) {\n        var option = this.buffer.consume_value('u8');\n        if (option === 1) {\n            return this.decode_value(schema.option);\n        }\n        if (option !== 0) {\n            throw new Error(\"Invalid option \".concat(option));\n        }\n        return null;\n    };\n    BorshDeserializer.prototype.decode_enum = function (schema) {\n        var _a;\n        var valueIndex = this.buffer.consume_value('u8');\n        if (valueIndex > schema[\"enum\"].length) {\n            throw new Error(\"Enum option \".concat(valueIndex, \" is not available\"));\n        }\n        var struct = schema[\"enum\"][valueIndex].struct;\n        var key = Object.keys(struct)[0];\n        return _a = {}, _a[key] = this.decode_value(struct[key]), _a;\n    };\n    BorshDeserializer.prototype.decode_array = function (schema) {\n        var result = [];\n        var len = schema.array.len ? schema.array.len : this.decode_integer('u32');\n        for (var i = 0; i < len; ++i) {\n            result.push(this.decode_value(schema.array.type));\n        }\n        return result;\n    };\n    BorshDeserializer.prototype.decode_set = function (schema) {\n        var len = this.decode_integer('u32');\n        var result = new Set();\n        for (var i = 0; i < len; ++i) {\n            result.add(this.decode_value(schema.set));\n        }\n        return result;\n    };\n    BorshDeserializer.prototype.decode_map = function (schema) {\n        var len = this.decode_integer('u32');\n        var result = new Map();\n        for (var i = 0; i < len; ++i) {\n            var key = this.decode_value(schema.map.key);\n            var value = this.decode_value(schema.map.value);\n            result.set(key, value);\n        }\n        return result;\n    };\n    BorshDeserializer.prototype.decode_struct = function (schema) {\n        var result = {};\n        for (var key in schema.struct) {\n            result[key] = this.decode_value(schema.struct[key]);\n        }\n        return result;\n    };\n    return BorshDeserializer;\n}());\nexport { BorshDeserializer };\n"],"names":["BorshDeserializer","bufferArray","this","buffer","DecodeBuffer","prototype","decode","schema","decode_value","integers","includes","decode_integer","decode_string","decode_boolean","decode_option","decode_enum","decode_array","decode_set","decode_map","decode_struct","Error","concat","size","parseInt","substring","consume_value","decode_bigint","startsWith","signed","buffer_len","Uint8Array","consume_bytes","bits","reduceRight","r","x","toString","padStart","BigInt","asIntN","len","codePoints","i","byte","push","codePoint","String","fromCodePoint","apply","option","_a","valueIndex","length","struct","key","Object","keys","result","array","type","Set","add","set","Map","map","value"],"mappings":"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","x_google_ignoreList":[0]}