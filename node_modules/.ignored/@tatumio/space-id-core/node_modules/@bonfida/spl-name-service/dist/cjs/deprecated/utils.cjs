"use strict";var e=require("@solana/web3.js"),t=require("../node_modules/@noble/hashes/esm/sha256.cjs"),r=require("../constants.cjs"),a=require("../state.cjs");require("../node_modules/buffer/index.cjs");var o=require("../error.cjs"),s=require("../_virtual/index.cjs");async function n(e){const a=r.HASH_PREFIX+e,o=t.sha256(s.__exports.Buffer.from(a,"utf8"));return s.__exports.Buffer.from(o)}async function i(t,a,o){const n=[t];a?n.push(a.toBuffer()):n.push(s.__exports.Buffer.alloc(32)),o?n.push(o.toBuffer()):n.push(s.__exports.Buffer.alloc(32));const[i]=await e.PublicKey.findProgramAddress(n,r.NAME_PROGRAM_ID);return i}const u=async(e,t=r.ROOT_DOMAIN_ACCOUNT)=>{let a=await n(e);return{pubkey:await i(a,void 0,t),hashed:a}},c=async(e,t=!1)=>{e.endsWith(".sol")&&(e=e.slice(0,-4));const a=e.split(".");if(2===a.length){const e=s.__exports.Buffer.from([t?1:0]).toString().concat(a[0]),{pubkey:r}=await u(a[1]);return{...await u(e,r),isSub:!0,parent:r}}if(3===a.length&&t){const{pubkey:e}=await u(a[2]),{pubkey:t}=await u("\0".concat(a[1]),e),r=s.__exports.Buffer.from([1]).toString();return{...await u(r.concat(a[0]),t),isSub:!0,parent:e,isSubRecord:!0}}if(a.length>=3)throw new o.InvalidInputError("The domain is malformed");return{...await u(e,r.ROOT_DOMAIN_ACCOUNT),isSub:!1,parent:void 0}};exports.getDomainKey=c,exports.getHashedName=n,exports.getNameAccountKey=i,exports.getNameOwner=async function(e,t){if(!await e.getAccountInfo(t))throw new o.AccountDoesNotExistError("The name account does exist");return a.NameRegistryState.retrieve(e,t)},exports.getReverseKey=async(e,t)=>{const{pubkey:a,parent:o}=await c(e),s=await n(a.toBase58());return await i(s,r.REVERSE_LOOKUP_CLASS,t?o:void 0)},exports.performReverseLookup=async function(e,t){const s=await n(t.toBase58()),u=await i(s,r.REVERSE_LOOKUP_CLASS),{registry:c}=await a.NameRegistryState.retrieve(e,u);if(!c.data)throw new o.NoAccountDataError("The registry data is empty");const f=c.data.slice(0,4).readUInt32LE(0);return c.data.slice(4,4+f).toString()},exports.performReverseLookupBatch=async function(e,t){let o=[];for(let e of t){const t=await n(e.toBase58()),a=await i(t,r.REVERSE_LOOKUP_CLASS);o.push(a)}return(await a.NameRegistryState.retrieveBatch(e,o)).map((e=>{if(void 0===e||void 0===e.data)return;const t=e.data.slice(0,4).readUInt32LE(0);return e.data.slice(4,4+t).toString()}))};
//# sourceMappingURL=utils.cjs.map
