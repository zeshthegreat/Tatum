{"version":3,"file":"utils.mjs","sources":["../../../../../../../node_modules/@noble/curves/esm/abstract/utils.js"],"sourcesContent":["/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// 100 lines of code in the file are duplicated from noble-hashes (utils).\n// This is OK: `abstract` directory does not use noble-hashes.\n// User may opt-in into using different hashing library. This way, noble-hashes\n// won't be included into their bundle.\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nexport function isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\nexport function abytes(item) {\n    if (!isBytes(item))\n        throw new Error('Uint8Array expected');\n}\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes) {\n    abytes(bytes);\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\nexport function numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? `0${hex}` : hex;\n}\nexport function hexToNumber(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    // Big Endian\n    return BigInt(hex === '' ? '0' : `0x${hex}`);\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };\nfunction asciiToBase16(char) {\n    if (char >= asciis._0 && char <= asciis._9)\n        return char - asciis._0;\n    if (char >= asciis._A && char <= asciis._F)\n        return char - (asciis._A - 10);\n    if (char >= asciis._a && char <= asciis._f)\n        return char - (asciis._a - 10);\n    return;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2;\n    }\n    return array;\n}\n// BE: Big Endian, LE: Little Endian\nexport function bytesToNumberBE(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\nexport function bytesToNumberLE(bytes) {\n    abytes(bytes);\n    return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));\n}\nexport function numberToBytesBE(n, len) {\n    return hexToBytes(n.toString(16).padStart(len * 2, '0'));\n}\nexport function numberToBytesLE(n, len) {\n    return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nexport function numberToVarBytesBE(n) {\n    return hexToBytes(numberToHexUnpadded(n));\n}\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'private key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */\nexport function ensureBytes(title, hex, expectedLength) {\n    let res;\n    if (typeof hex === 'string') {\n        try {\n            res = hexToBytes(hex);\n        }\n        catch (e) {\n            throw new Error(`${title} must be valid hex string, got \"${hex}\". Cause: ${e}`);\n        }\n    }\n    else if (isBytes(hex)) {\n        // Uint8Array.from() instead of hash.slice() because node.js Buffer\n        // is instance of Uint8Array, and its slice() creates **mutable** copy\n        res = Uint8Array.from(hex);\n    }\n    else {\n        throw new Error(`${title} must be hex string or Uint8Array`);\n    }\n    const len = res.length;\n    if (typeof expectedLength === 'number' && len !== expectedLength)\n        throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);\n    return res;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        abytes(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n// Compares 2 u8a-s in kinda constant time\nexport function equalBytes(a, b) {\n    if (a.length !== b.length)\n        return false;\n    let diff = 0;\n    for (let i = 0; i < a.length; i++)\n        diff |= a[i] ^ b[i];\n    return diff === 0;\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n// Bit operations\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n */\nexport function bitLen(n) {\n    let len;\n    for (len = 0; n > _0n; n >>= _1n, len += 1)\n        ;\n    return len;\n}\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */\nexport function bitGet(n, pos) {\n    return (n >> BigInt(pos)) & _1n;\n}\n/**\n * Sets single bit at position.\n */\nexport function bitSet(n, pos, value) {\n    return n | ((value ? _1n : _0n) << BigInt(pos));\n}\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */\nexport const bitMask = (n) => (_2n << BigInt(n - 1)) - _1n;\n// DRBG\nconst u8n = (data) => new Uint8Array(data); // creates Uint8Array\nconst u8fr = (arr) => Uint8Array.from(arr); // another shortcut\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */\nexport function createHmacDrbg(hashLen, qByteLen, hmacFn) {\n    if (typeof hashLen !== 'number' || hashLen < 2)\n        throw new Error('hashLen must be a number');\n    if (typeof qByteLen !== 'number' || qByteLen < 2)\n        throw new Error('qByteLen must be a number');\n    if (typeof hmacFn !== 'function')\n        throw new Error('hmacFn must be a function');\n    // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n    let i = 0; // Iterations counter, will throw when over 1000\n    const reset = () => {\n        v.fill(1);\n        k.fill(0);\n        i = 0;\n    };\n    const h = (...b) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n    const reseed = (seed = u8n()) => {\n        // HMAC-DRBG reseed() function. Steps D-G\n        k = h(u8fr([0x00]), seed); // k = hmac(k || v || 0x00 || seed)\n        v = h(); // v = hmac(k || v)\n        if (seed.length === 0)\n            return;\n        k = h(u8fr([0x01]), seed); // k = hmac(k || v || 0x01 || seed)\n        v = h(); // v = hmac(k || v)\n    };\n    const gen = () => {\n        // HMAC-DRBG generate() function\n        if (i++ >= 1000)\n            throw new Error('drbg: tried 1000 values');\n        let len = 0;\n        const out = [];\n        while (len < qByteLen) {\n            v = h();\n            const sl = v.slice();\n            out.push(sl);\n            len += v.length;\n        }\n        return concatBytes(...out);\n    };\n    const genUntil = (seed, pred) => {\n        reset();\n        reseed(seed); // Steps D-G\n        let res = undefined; // Step H: grind until k is in [1..n-1]\n        while (!(res = pred(gen())))\n            reseed();\n        reset();\n        return res;\n    };\n    return genUntil;\n}\n// Validating curves and fields\nconst validatorFns = {\n    bigint: (val) => typeof val === 'bigint',\n    function: (val) => typeof val === 'function',\n    boolean: (val) => typeof val === 'boolean',\n    string: (val) => typeof val === 'string',\n    stringOrUint8Array: (val) => typeof val === 'string' || isBytes(val),\n    isSafeInteger: (val) => Number.isSafeInteger(val),\n    array: (val) => Array.isArray(val),\n    field: (val, object) => object.Fp.isValid(val),\n    hash: (val) => typeof val === 'function' && Number.isSafeInteger(val.outputLen),\n};\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\nexport function validateObject(object, validators, optValidators = {}) {\n    const checkField = (fieldName, type, isOptional) => {\n        const checkVal = validatorFns[type];\n        if (typeof checkVal !== 'function')\n            throw new Error(`Invalid validator \"${type}\", expected function`);\n        const val = object[fieldName];\n        if (isOptional && val === undefined)\n            return;\n        if (!checkVal(val, object)) {\n            throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);\n        }\n    };\n    for (const [fieldName, type] of Object.entries(validators))\n        checkField(fieldName, type, false);\n    for (const [fieldName, type] of Object.entries(optValidators))\n        checkField(fieldName, type, true);\n    return object;\n}\n// validate type tests\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n// // Should fail type-check\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\n//# sourceMappingURL=utils.js.map"],"names":["BigInt","_1n","_2n","isBytes","a","Uint8Array","constructor","name","abytes","item","Error","hexes","Array","from","length","_","i","toString","padStart","bytesToHex","bytes","hex","hexToNumber","asciis","_0","_9","_A","_F","_a","_f","asciiToBase16","char","hexToBytes","hl","al","array","ai","hi","n1","charCodeAt","n2","undefined","bytesToNumberBE","bytesToNumberLE","reverse","numberToBytesBE","n","len","numberToBytesLE","ensureBytes","title","expectedLength","res","e","concatBytes","arrays","sum","pad","set","bitMask","validatorFns","bigint","val","function","boolean","string","stringOrUint8Array","isSafeInteger","Number","isArray","field","object","Fp","isValid","hash","outputLen"],"mappings":"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","x_google_ignoreList":[0]}