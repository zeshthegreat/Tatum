/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function r(...r){const e=r=>r,o=(r,e)=>o=>r(e(o));return{encode:r.map((r=>r.encode)).reduceRight(o,e),decode:r.map((r=>r.decode)).reduce(o,e)}}const e=(r,o)=>o?e(o,r%o):r,o=(r,o)=>r+(o-e(r,o));function n(r,e,n,t){if(!Array.isArray(r))throw new Error("convertRadix2: data should be array");if(e<=0||e>32)throw new Error(`convertRadix2: wrong from=${e}`);if(n<=0||n>32)throw new Error(`convertRadix2: wrong to=${n}`);if(o(e,n)>32)throw new Error(`convertRadix2: carry overflow from=${e} to=${n} carryBits=${o(e,n)}`);let i=0,f=0;const c=2**n-1,d=[];for(const o of r){if(o>=2**e)throw new Error(`convertRadix2: invalid data word=${o} from=${e}`);if(i=i<<e|o,f+e>32)throw new Error(`convertRadix2: carry overflow pos=${f} from=${e}`);for(f+=e;f>=n;f-=n)d.push((i>>f-n&c)>>>0);i&=2**f-1}if(i=i<<n-f&c,!t&&f>=e)throw new Error("Excess padding");if(!t&&i)throw new Error(`Non-zero padding: ${i}`);return t&&f>0&&d.push(i>>>0),d}function t(r,e=!1){if(r<=0||r>32)throw new Error("radix2: bits should be in (0..32]");if(o(8,r)>32||o(r,8)>32)throw new Error("radix2: carry overflow");return{encode:o=>{if(!((t=o)instanceof Uint8Array||null!=t&&"object"==typeof t&&"Uint8Array"===t.constructor.name))throw new Error("radix2.encode input should be Uint8Array");var t;return n(Array.from(o),8,r,!e)},decode:o=>{if(!Array.isArray(o)||o.length&&"number"!=typeof o[0])throw new Error("radix2.decode input should be array of numbers");return Uint8Array.from(n(o,r,8,e))}}}function i(r){if("function"!=typeof r)throw new Error("unsafeWrapper fn should be function");return function(...e){try{return r.apply(null,e)}catch(r){}}}const f=r(function(r){return{encode:e=>{if(!Array.isArray(e)||e.length&&"number"!=typeof e[0])throw new Error("alphabet.encode input should be an array of numbers");return e.map((e=>{if(e<0||e>=r.length)throw new Error(`Digit index outside alphabet: ${e} (alphabet: ${r.length})`);return r[e]}))},decode:e=>{if(!Array.isArray(e)||e.length&&"string"!=typeof e[0])throw new Error("alphabet.decode input should be array of strings");return e.map((e=>{if("string"!=typeof e)throw new Error(`alphabet.decode: not string element=${e}`);const o=r.indexOf(e);if(-1===o)throw new Error(`Unknown letter: "${e}". Allowed: ${r}`);return o}))}}}("qpzry9x8gf2tvdw0s3jn54khce6mua7l"),function(r=""){if("string"!=typeof r)throw new Error("join separator should be string");return{encode:e=>{if(!Array.isArray(e)||e.length&&"string"!=typeof e[0])throw new Error("join.encode input should be array of strings");for(let r of e)if("string"!=typeof r)throw new Error(`join.encode: non-string input=${r}`);return e.join(r)},decode:e=>{if("string"!=typeof e)throw new Error("join.decode input should be string");return e.split(r)}}}("")),c=[996825010,642813549,513874426,1027748829,705979059];function d(r){const e=r>>25;let o=(33554431&r)<<5;for(let r=0;r<c.length;r++)1==(e>>r&1)&&(o^=c[r]);return o}function s(r,e,o=1){const t=r.length;let i=1;for(let e=0;e<t;e++){const o=r.charCodeAt(e);if(o<33||o>126)throw new Error(`Invalid prefix (${r})`);i=d(i)^o>>5}i=d(i);for(let e=0;e<t;e++)i=d(i)^31&r.charCodeAt(e);for(let r of e)i=d(i)^r;for(let r=0;r<6;r++)i=d(i);return i^=o,f.encode(n([i%2**30],30,5,!1))}function a(r){const e="bech32"===r?1:734539939,o=t(5),n=o.decode,c=o.encode,d=i(n);function a(r,o=90){if("string"!=typeof r)throw new Error("bech32.decode input should be string, not "+typeof r);if(r.length<8||!1!==o&&r.length>o)throw new TypeError(`Wrong string length: ${r.length} (${r}). Expected (8..${o})`);const n=r.toLowerCase();if(r!==n&&r!==r.toUpperCase())throw new Error("String must be lowercase or uppercase");const t=n.lastIndexOf("1");if(0===t||-1===t)throw new Error('Letter "1" must be present between prefix and data only');const i=n.slice(0,t),c=n.slice(t+1);if(c.length<6)throw new Error("Data must be at least 6 characters long");const d=f.decode(c).slice(0,-6),a=s(i,d,e);if(!c.endsWith(a))throw new Error(`Invalid checksum in ${r}: expected "${a}"`);return{prefix:i,words:d}}return{encode:function(r,o,n=90){if("string"!=typeof r)throw new Error("bech32.encode prefix should be string, not "+typeof r);if(!Array.isArray(o)||o.length&&"number"!=typeof o[0])throw new Error("bech32.encode words should be array of numbers, not "+typeof o);if(0===r.length)throw new TypeError(`Invalid prefix length ${r.length}`);const t=r.length+7+o.length;if(!1!==n&&t>n)throw new TypeError(`Length ${t} exceeds limit ${n}`);const i=r.toLowerCase(),c=s(i,o,e);return`${i}1${f.encode(o)}${c}`},decode:a,decodeToBytes:function(r){const{prefix:e,words:o}=a(r,!1);return{prefix:e,words:o,bytes:n(o)}},decodeUnsafe:i(a),fromWords:n,fromWordsUnsafe:d,toWords:c}}const h=a("bech32");export{h as bech32};
//# sourceMappingURL=index.mjs.map
