"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Utils = void 0;
/* eslint-disable @typescript-eslint/no-explicit-any */
const bignumber_js_1 = require("bignumber.js");
const typedi_1 = require("typedi");
const package_json_1 = require("../../package.json");
const dto_1 = require("../dto");
const service_1 = require("../service");
const EvmArchiveLoadBalancerRpc_1 = require("../service/rpc/evm/EvmArchiveLoadBalancerRpc");
const EvmBeaconArchiveLoadBalancerRpc_1 = require("../service/rpc/evm/EvmBeaconArchiveLoadBalancerRpc");
const NativeEvmArchiveLoadBalancerRpc_1 = require("../service/rpc/evm/NativeEvmArchiveLoadBalancerRpc");
const TronLoadBalancerRpc_1 = require("../service/rpc/evm/TronLoadBalancerRpc");
const TronRpc_1 = require("../service/rpc/evm/TronRpc");
const AlgorandAlgodLoadBalancerRpc_1 = require("../service/rpc/other/AlgorandAlgodLoadBalancerRpc");
const AlgorandIndexerLoadBalancerRpc_1 = require("../service/rpc/other/AlgorandIndexerLoadBalancerRpc");
const BnbLoadBalancerRpc_1 = require("../service/rpc/other/BnbLoadBalancerRpc");
const CardanoLoadBalancerRpc_1 = require("../service/rpc/other/CardanoLoadBalancerRpc");
const EosLoadBalancerRpc_1 = require("../service/rpc/other/EosLoadBalancerRpc");
const EosRpc_1 = require("../service/rpc/other/EosRpc");
const IotaLoadBalancerRpc_1 = require("../service/rpc/other/IotaLoadBalancerRpc");
const KadenaLoadBalancerRpc_1 = require("../service/rpc/other/KadenaLoadBalancerRpc");
const RostrumLoadBalancerRpc_1 = require("../service/rpc/other/RostrumLoadBalancerRpc");
const SolanaArchiveLoadBalancerRpc_1 = require("../service/rpc/other/SolanaArchiveLoadBalancerRpc");
const StellarLoadBalancerRpc_1 = require("../service/rpc/other/StellarLoadBalancerRpc");
const StellarRpc_1 = require("../service/rpc/other/StellarRpc");
const TezosLoadBalancerRpc_1 = require("../service/rpc/other/TezosLoadBalancerRpc");
const XrpLoadBalancerRpc_1 = require("../service/rpc/other/XrpLoadBalancerRpc");
const DogeLoadBalancedRpc_1 = require("../service/rpc/utxo/DogeLoadBalancedRpc");
const UtxoLoadBalancerRpc_1 = require("../service/rpc/utxo/UtxoLoadBalancerRpc");
const UtxoLoadBalancerRpcEstimateFee_1 = require("../service/rpc/utxo/UtxoLoadBalancerRpcEstimateFee");
const UtxoRpcEstimateFee_1 = require("../service/rpc/utxo/UtxoRpcEstimateFee");
const constant_1 = require("./constant");
const di_tokens_1 = require("./di.tokens");
const IotaRpc_1 = require("../service/rpc/other/IotaRpc");
const CosmosLoadBalancerRpc_1 = require("../service/rpc/other/CosmosLoadBalancerRpc");
const CasperLoadBalancerRpc_1 = require("../service/rpc/other/CasperLoadBalancerRpc");
const TonRpc_1 = require("../service/rpc/other/TonRpc");
const ZkSyncLoadBalancerRpc_1 = require("../service/rpc/evm/ZkSyncLoadBalancerRpc");
exports.Utils = {
    getRpc: (id, config) => {
        const { network } = config;
        if ((0, dto_1.isZkSyncNetwork)(network)) {
            return typedi_1.Container.of(id).get(ZkSyncLoadBalancerRpc_1.ZkSyncLoadBalancerRpc);
        }
        if ((0, dto_1.isTonNetwork)(network)) {
            return typedi_1.Container.of(id).get(TonRpc_1.TonRpc);
        }
        if ((0, dto_1.isCasperNetwork)(network)) {
            return typedi_1.Container.of(id).get(CasperLoadBalancerRpc_1.CasperLoadBalancerRpc);
        }
        if ((0, dto_1.isCosmosNetwork)(network)) {
            return typedi_1.Container.of(id).get(CosmosLoadBalancerRpc_1.CosmosLoadBalancerRpc);
        }
        if ((0, dto_1.isIotaLoadBalancerNetwork)(network)) {
            return typedi_1.Container.of(id).get(IotaLoadBalancerRpc_1.IotaLoadBalancerRpc);
        }
        if ((0, dto_1.isIotaNetwork)(network)) {
            return typedi_1.Container.of(id).get(IotaRpc_1.IotaRpc);
        }
        if ((0, dto_1.isRostrumLoadBalancerNetwork)(network)) {
            return typedi_1.Container.of(id).get(RostrumLoadBalancerRpc_1.RostrumLoadBalancerRpc);
        }
        if ((0, dto_1.isKadenaLoadBalancerNetwork)(network)) {
            return typedi_1.Container.of(id).get(KadenaLoadBalancerRpc_1.KadenaLoadBalancerRpc);
        }
        if ((0, dto_1.isStellarLoadBalancerNetwork)(network)) {
            return typedi_1.Container.of(id).get(StellarLoadBalancerRpc_1.StellarLoadBalancerRpc);
        }
        if ((0, dto_1.isStellarNetwork)(network)) {
            return typedi_1.Container.of(id).get(StellarRpc_1.StellarRpc);
        }
        if ((0, dto_1.isCardanoNetwork)(network)) {
            return typedi_1.Container.of(id).get(CardanoLoadBalancerRpc_1.CardanoLoadBalancerRpc);
        }
        if ((0, dto_1.isAlgorandIndexerNetwork)(network)) {
            return typedi_1.Container.of(id).get(AlgorandIndexerLoadBalancerRpc_1.AlgorandIndexerLoadBalancerRpc);
        }
        if ((0, dto_1.isAlgorandAlgodNetwork)(network)) {
            return typedi_1.Container.of(id).get(AlgorandAlgodLoadBalancerRpc_1.AlgorandAlgodLoadBalancerRpc);
        }
        if ((0, dto_1.isTezosNetwork)(network)) {
            return typedi_1.Container.of(id).get(TezosLoadBalancerRpc_1.TezosLoadBalancerRpc);
        }
        if ((0, dto_1.isBnbLoadBalancerNetwork)(network)) {
            return typedi_1.Container.of(id).get(BnbLoadBalancerRpc_1.BnbLoadBalancerRpc);
        }
        if ((0, dto_1.isDogecoinLoadBalancedNetwork)(network)) {
            return typedi_1.Container.of(id).get(DogeLoadBalancedRpc_1.DogeLoadBalancedRpc);
        }
        if ((0, dto_1.isUtxoLoadBalancerEstimateFeeNetwork)(network)) {
            return typedi_1.Container.of(id).get(UtxoLoadBalancerRpcEstimateFee_1.UtxoLoadBalancerRpcEstimateFee);
        }
        if ((0, dto_1.isUtxoEstimateFeeNetwork)(network)) {
            return typedi_1.Container.of(id).get(UtxoRpcEstimateFee_1.UtxoRpcEstimateFee);
        }
        if ((0, dto_1.isUtxoLoadBalancerNetwork)(network)) {
            return typedi_1.Container.of(id).get(UtxoLoadBalancerRpc_1.UtxoLoadBalancerRpc);
        }
        if ((0, dto_1.isNativeEvmLoadBalancerNetwork)(network)) {
            return typedi_1.Container.of(id).get(NativeEvmArchiveLoadBalancerRpc_1.NativeEvmArchiveLoadBalancerRpc);
        }
        if ((0, dto_1.isEvmArchiveNonArchiveBeaconLoadBalancerNetwork)(network)) {
            return typedi_1.Container.of(id).get(EvmBeaconArchiveLoadBalancerRpc_1.EvmBeaconArchiveLoadBalancerRpc);
        }
        if ((0, dto_1.isEvmArchiveNonArchiveLoadBalancerNetwork)(network)) {
            return typedi_1.Container.of(id).get(EvmArchiveLoadBalancerRpc_1.EvmArchiveLoadBalancerRpc);
        }
        if ((0, dto_1.isEvmLoadBalancerNetwork)(network)) {
            return typedi_1.Container.of(id).get(service_1.EvmLoadBalancerRpc);
        }
        if ((0, dto_1.isEvmBasedNetwork)(network)) {
            return typedi_1.Container.of(id).get(service_1.EvmRpc);
        }
        if ((0, dto_1.isUtxoBasedNetwork)(network)) {
            return typedi_1.Container.of(id).get(service_1.UtxoRpc);
        }
        if ((0, dto_1.isXrpNetwork)(network)) {
            return typedi_1.Container.of(id).get(XrpLoadBalancerRpc_1.XrpLoadBalancerRpc);
        }
        if ((0, dto_1.isSolanaNetwork)(network)) {
            return typedi_1.Container.of(id).get(SolanaArchiveLoadBalancerRpc_1.SolanaArchiveLoadBalancerRpc);
        }
        if ((0, dto_1.isTronLoadBalancerNetwork)(network)) {
            return typedi_1.Container.of(id).get(TronLoadBalancerRpc_1.TronLoadBalancerRpc);
        }
        if ((0, dto_1.isTronNetwork)(network)) {
            return typedi_1.Container.of(id).get(TronRpc_1.TronRpc);
        }
        if ((0, dto_1.isEosLoadBalancerNetwork)(network)) {
            return typedi_1.Container.of(id).get(EosLoadBalancerRpc_1.EosLoadBalancerRpc);
        }
        if ((0, dto_1.isEosNetwork)(network)) {
            return typedi_1.Container.of(id).get(EosRpc_1.EosRpc);
        }
        typedi_1.Container.of(id).get(di_tokens_1.LOGGER).warn(`RPC Network ${network} is not supported.`);
        return typedi_1.Container.of(id).get(service_1.GenericRpc);
    },
    getRpcListUrl: (network) => {
        const mappedNetwork = exports.Utils.mapRpcListUrl(network);
        return [
            `https://rpc.tatum.io/${mappedNetwork}/list.json`,
            `https://rpc.tatum.io/${mappedNetwork}-archive/list.json`,
        ];
    },
    mapRpcListUrl: (network) => {
        const mappedNetwork = dto_1.MAPPED_NETWORK[network];
        return mappedNetwork ?? network;
    },
    getStatusPayload: (network) => {
        if ((0, dto_1.isCasperNetwork)(network)) {
            return {
                jsonrpc: '2.0',
                method: 'info_get_status_result',
                params: [],
                id: 1,
            };
        }
        if ((0, dto_1.isRostrumLoadBalancerNetwork)(network)) {
            return {
                jsonrpc: '2.0',
                method: 'blockchain.headers.tip',
                params: [],
                id: 1,
            };
        }
        if ((0, dto_1.isXrpNetwork)(network)) {
            return {
                method: 'ledger',
                params: [
                    {
                        ledger_index: 'current',
                        transactions: false,
                        expand: false,
                        owner_funds: false,
                    },
                ],
                id: 1,
                jsonrpc: '2.0',
            };
        }
        if ((0, dto_1.isUtxoBasedNetwork)(network)) {
            return {
                jsonrpc: '2.0',
                method: 'getblockcount',
                params: [],
                id: 1,
            };
        }
        if ((0, dto_1.isEvmBasedNetwork)(network) || (0, dto_1.isTronNetwork)(network)) {
            return {
                jsonrpc: '2.0',
                method: 'eth_blockNumber',
                params: [],
                id: 1,
            };
        }
        if ((0, dto_1.isSolanaNetwork)(network)) {
            return {
                jsonrpc: '2.0',
                method: 'getBlockHeight',
                params: [],
                id: 1,
            };
        }
        if ((0, dto_1.isBnbLoadBalancerNetwork)(network)) {
            return {
                jsonrpc: '2.0',
                method: 'block',
                params: {},
                id: 1,
            };
        }
        if ((0, dto_1.isCardanoNetwork)(network)) {
            return {
                network_identifier: {
                    blockchain: dto_1.Network.COSMOS_ROSETTA === network ? 'cosmos' : 'cardano',
                    network: dto_1.Network.CARDANO_ROSETTA === network ? 'mainnet' : 'preprod',
                },
            };
        }
        if ((0, dto_1.isEosNetwork)(network) ||
            (0, dto_1.isTezosNetwork)(network) ||
            (0, dto_1.isAlgorandAlgodNetwork)(network) ||
            (0, dto_1.isAlgorandIndexerNetwork)(network) ||
            (0, dto_1.isStellarLoadBalancerNetwork)(network) ||
            (0, dto_1.isKadenaLoadBalancerNetwork)(network) ||
            (0, dto_1.isIotaLoadBalancerNetwork)(network) ||
            (0, dto_1.isTonNetwork)(network)) {
            return null;
        }
        throw new Error(`Network ${network} is not supported.`);
    },
    getStatusUrl(network, url) {
        if ((0, dto_1.isTonNetwork)(network)) {
            return `${url}v2/liteserver/get_masterchain_info`;
        }
        if ((0, dto_1.isIotaLoadBalancerNetwork)(network)) {
            return `${url}api/core/v2/info`;
        }
        if ((0, dto_1.isEosNetwork)(network)) {
            return `${url}${constant_1.Constant.EOS_PREFIX}get_info`;
        }
        if ((0, dto_1.isAlgorandAlgodNetwork)(network)) {
            return `${url}v2/status`;
        }
        if ((0, dto_1.isAlgorandIndexerNetwork)(network)) {
            return `${url}health`;
        }
        if ((0, dto_1.isCardanoNetwork)(network)) {
            return `${url}network/status`;
        }
        if ((0, dto_1.isCasperNetwork)(network)) {
            return `${url}/rpc`;
        }
        if ((0, dto_1.isXrpNetwork)(network)) {
            return url;
        }
        if ((0, dto_1.isSameGetBlockNetwork)(network)) {
            return url;
        }
        if ((0, dto_1.isBnbLoadBalancerNetwork)(network)) {
            return url;
        }
        if ((0, dto_1.isRostrumLoadBalancerNetwork)(network)) {
            return url;
        }
        if ((0, dto_1.isTezosNetwork)(network)) {
            return `${url}chains/main/blocks/head/header`;
        }
        if ((0, dto_1.isStellarLoadBalancerNetwork)(network)) {
            return `${url}fee_stats`;
        }
        if ((0, dto_1.isKadenaLoadBalancerNetwork)(network)) {
            return `${url}chainweb/0.0/mainnet01/cut`;
        }
        throw new Error(`Network ${network} is not supported.`);
    },
    getStatusMethod(network) {
        if ((0, dto_1.isTezosNetwork)(network) ||
            (0, dto_1.isAlgorandAlgodNetwork)(network) ||
            (0, dto_1.isAlgorandIndexerNetwork)(network) ||
            (0, dto_1.isStellarLoadBalancerNetwork)(network) ||
            (0, dto_1.isKadenaLoadBalancerNetwork)(network) ||
            (0, dto_1.isIotaLoadBalancerNetwork)(network) ||
            (0, dto_1.isTonNetwork)(network)) {
            return 'GET';
        }
        return 'POST';
    },
    parseStatusPayload: (network, response) => {
        if ((0, dto_1.isTonNetwork)(network)) {
            return new bignumber_js_1.BigNumber(response.last.seqno || -1).toNumber();
        }
        if ((0, dto_1.isCasperNetwork)(network)) {
            return new bignumber_js_1.BigNumber(response.result.last_added_block_info.height || -1).toNumber();
        }
        if ((0, dto_1.isSameGetBlockNetwork)(network)) {
            return new bignumber_js_1.BigNumber(response.result || -1).toNumber();
        }
        if ((0, dto_1.isBnbLoadBalancerNetwork)(network)) {
            return new bignumber_js_1.BigNumber(response.result.block.header.height || -1).toNumber();
        }
        if ((0, dto_1.isEosNetwork)(network)) {
            return new bignumber_js_1.BigNumber(response.head_block_num || -1).toNumber();
        }
        if ((0, dto_1.isTezosNetwork)(network)) {
            return new bignumber_js_1.BigNumber(response.level || -1).toNumber();
        }
        if ((0, dto_1.isAlgorandAlgodNetwork)(network)) {
            return new bignumber_js_1.BigNumber(response['last-round'] || -1).toNumber();
        }
        if ((0, dto_1.isAlgorandIndexerNetwork)(network)) {
            return new bignumber_js_1.BigNumber(response['round'] || -1).toNumber();
        }
        if ((0, dto_1.isCardanoNetwork)(network)) {
            return new bignumber_js_1.BigNumber(response.current_block_identifier.index || -1).toNumber();
        }
        if ((0, dto_1.isStellarLoadBalancerNetwork)(network)) {
            return new bignumber_js_1.BigNumber(response.last_ledger || -1).toNumber();
        }
        if ((0, dto_1.isXrpNetwork)(network)) {
            return new bignumber_js_1.BigNumber(response.result.ledger_current_index || -1).toNumber();
        }
        if ((0, dto_1.isKadenaLoadBalancerNetwork)(network)) {
            return new bignumber_js_1.BigNumber(response.hashes[0].height || -1).toNumber();
        }
        if ((0, dto_1.isRostrumLoadBalancerNetwork)(network)) {
            return new bignumber_js_1.BigNumber(response.result.height || -1).toNumber();
        }
        if ((0, dto_1.isIotaLoadBalancerNetwork)(network)) {
            return new bignumber_js_1.BigNumber(response?.status?.latestMilestone?.index || -1).toNumber();
        }
        throw new Error(`Network ${network} is not supported.`);
    },
    isResponseOk: (network, response) => {
        if ((0, dto_1.isTonNetwork)(network)) {
            return response.last.seqno !== undefined;
        }
        if ((0, dto_1.isCasperNetwork)(network)) {
            return response.result.last_added_block_info.height !== undefined;
        }
        if ((0, dto_1.isEosNetwork)(network)) {
            return response.head_block_num !== undefined;
        }
        if ((0, dto_1.isBnbLoadBalancerNetwork)(network)) {
            return response.result.block.header.height !== undefined;
        }
        if ((0, dto_1.isSameGetBlockNetwork)(network)) {
            return response.result !== undefined;
        }
        if ((0, dto_1.isTezosNetwork)(network)) {
            return response.level !== undefined;
        }
        if ((0, dto_1.isAlgorandAlgodNetwork)(network)) {
            return response['last-round'] !== undefined;
        }
        if ((0, dto_1.isAlgorandIndexerNetwork)(network)) {
            return response['round'] !== undefined;
        }
        if ((0, dto_1.isStellarLoadBalancerNetwork)(network)) {
            return response.last_ledger !== undefined;
        }
        if ((0, dto_1.isCardanoNetwork)(network)) {
            return response.current_block_identifier.index !== undefined;
        }
        if ((0, dto_1.isXrpNetwork)(network)) {
            return response.result.ledger_current_index !== undefined;
        }
        if ((0, dto_1.isKadenaLoadBalancerNetwork)(network)) {
            return response?.hashes?.[0]?.height !== undefined;
        }
        if ((0, dto_1.isRostrumLoadBalancerNetwork)(network)) {
            return response?.result?.height !== undefined;
        }
        if ((0, dto_1.isIotaLoadBalancerNetwork)(network)) {
            return response?.status?.latestMilestone?.index !== undefined;
        }
        throw new Error(`Network ${network} is not supported.`);
    },
    mapNotificationChainToNetwork: (chain) => {
        switch (chain) {
            case dto_1.AddressEventNotificationChain.BTC:
                return dto_1.Network.BITCOIN;
            case dto_1.AddressEventNotificationChain.BCH:
                return dto_1.Network.BITCOIN_CASH;
            case dto_1.AddressEventNotificationChain.LTC:
                return dto_1.Network.LITECOIN;
            case dto_1.AddressEventNotificationChain.DOGE:
                return dto_1.Network.DOGECOIN;
            case dto_1.AddressEventNotificationChain.ETH:
                return dto_1.Network.ETHEREUM;
            case dto_1.AddressEventNotificationChain.MATIC:
                return dto_1.Network.POLYGON;
            case dto_1.AddressEventNotificationChain.CELO:
                return dto_1.Network.CELO;
            case dto_1.AddressEventNotificationChain.SOL:
                return dto_1.Network.SOLANA;
            case dto_1.AddressEventNotificationChain.XRP:
                return dto_1.Network.XRP;
            case dto_1.AddressEventNotificationChain.BSC:
                return dto_1.Network.BINANCE_SMART_CHAIN;
            case dto_1.AddressEventNotificationChain.TRON:
                return dto_1.Network.TRON;
            case dto_1.AddressEventNotificationChain.KLAY:
                return dto_1.Network.KLAYTN;
            case dto_1.AddressEventNotificationChain.EON:
                return dto_1.Network.HORIZEN_EON;
            case dto_1.AddressEventNotificationChain.CHZ:
                return dto_1.Network.CHILIZ;
            case dto_1.AddressEventNotificationChain.FLR:
                return dto_1.Network.FLARE;
            case dto_1.AddressEventNotificationChain.BASE:
                return dto_1.Network.BASE;
            case dto_1.AddressEventNotificationChain.AVAX:
                return dto_1.Network.AVALANCHE_C;
            default:
                throw new Error(`Chain ${chain} is not supported.`);
        }
    },
    mapNetworkToNotificationChain: (network) => {
        switch (network) {
            case dto_1.Network.BITCOIN:
            case dto_1.Network.BITCOIN_TESTNET:
                return dto_1.AddressEventNotificationChain.BTC;
            case dto_1.Network.BITCOIN_CASH:
            case dto_1.Network.BITCOIN_CASH_TESTNET:
                return dto_1.AddressEventNotificationChain.BCH;
            case dto_1.Network.LITECOIN:
            case dto_1.Network.LITECOIN_TESTNET:
                return dto_1.AddressEventNotificationChain.LTC;
            case dto_1.Network.DOGECOIN:
            case dto_1.Network.DOGECOIN_TESTNET:
                return dto_1.AddressEventNotificationChain.DOGE;
            case dto_1.Network.ETHEREUM:
            case dto_1.Network.ETHEREUM_SEPOLIA:
            case dto_1.Network.ETHEREUM_HOLESKY:
                return dto_1.AddressEventNotificationChain.ETH;
            case dto_1.Network.POLYGON:
            case dto_1.Network.POLYGON_AMOY:
                return dto_1.AddressEventNotificationChain.MATIC;
            case dto_1.Network.CELO:
            case dto_1.Network.CELO_ALFAJORES:
                return dto_1.AddressEventNotificationChain.CELO;
            case dto_1.Network.SOLANA:
            case dto_1.Network.SOLANA_DEVNET:
                return dto_1.AddressEventNotificationChain.SOL;
            case dto_1.Network.XRP:
            case dto_1.Network.XRP_TESTNET:
                return dto_1.AddressEventNotificationChain.XRP;
            case dto_1.Network.BINANCE_SMART_CHAIN:
            case dto_1.Network.BINANCE_SMART_CHAIN_TESTNET:
                return dto_1.AddressEventNotificationChain.BSC;
            case dto_1.Network.TRON:
            case dto_1.Network.TRON_SHASTA:
                return dto_1.AddressEventNotificationChain.TRON;
            case dto_1.Network.KLAYTN:
            case dto_1.Network.KLAYTN_BAOBAB:
                return dto_1.AddressEventNotificationChain.KLAY;
            case dto_1.Network.TEZOS:
                return dto_1.AddressEventNotificationChain.TEZOS;
            case dto_1.Network.HORIZEN_EON:
                return dto_1.AddressEventNotificationChain.EON;
            case dto_1.Network.CHILIZ:
                return dto_1.AddressEventNotificationChain.CHZ;
            case dto_1.Network.FLARE:
            case dto_1.Network.FLARE_COSTON:
            case dto_1.Network.FLARE_COSTON_2:
            case dto_1.Network.FLARE_SONGBIRD:
                return dto_1.AddressEventNotificationChain.FLR;
            case dto_1.Network.CRONOS:
            case dto_1.Network.CRONOS_TESTNET:
                return dto_1.AddressEventNotificationChain.CRO;
            case dto_1.Network.BASE:
            case dto_1.Network.BASE_SEPOLIA:
                return dto_1.AddressEventNotificationChain.BASE;
            case dto_1.Network.AVALANCHE_C:
            case dto_1.Network.AVALANCHE_C_TESTNET:
                return dto_1.AddressEventNotificationChain.AVAX;
            case dto_1.Network.FANTOM:
            case dto_1.Network.FANTOM_TESTNET:
                return dto_1.AddressEventNotificationChain.FTM;
            case dto_1.Network.OPTIMISM:
            case dto_1.Network.OPTIMISM_TESTNET:
                return dto_1.AddressEventNotificationChain.OPTIMISM;
            default:
                throw new Error(`Network ${network} is not supported.`);
        }
    },
    delay: (t) => new Promise((resolve) => setTimeout(resolve, t)),
    retryWithTimeout: async (action, timeoutInMs = 10000, delayInMs = 500) => {
        const startTime = Date.now();
        let lastError = null;
        while (timeoutInMs + startTime > Date.now()) {
            try {
                const result = await action();
                if (result === null || result === undefined) {
                    throw new Error('Null result');
                }
                return result;
            }
            catch (e) {
                lastError = e;
                await exports.Utils.delay(delayInMs);
            }
        }
        throw lastError ?? new Error('Retry timeout failed');
    },
    fetchWithTimeoutAndRetry: async (url, containerId, config, timeout = 5000, retry = 2) => {
        let lastError = null;
        for (let i = 0; i < retry; i++) {
            try {
                const { response, responseTime } = await exports.Utils.fetchWithTimeout(url, containerId, config, timeout);
                return { response, responseTime };
            }
            catch (e) {
                lastError = e;
            }
        }
        throw lastError ?? new Error('Retry timeout failed');
    },
    fetchWithTimeout: async (url, containerId, config, timeout = 5000) => {
        const controller = new AbortController();
        const id = setTimeout(() => controller.abort(), timeout);
        const start = Date.now();
        const response = await fetch(url, {
            ...config,
            signal: controller.signal,
            headers: exports.Utils.getHeaders(containerId),
        });
        const responseTime = Date.now() - start;
        clearTimeout(id);
        return { responseTime, response };
    },
    headersToJson(headers) {
        const headersObj = {};
        headers.forEach((value, key) => {
            headersObj[key] = value;
        });
        return JSON.stringify(headersObj);
    },
    getHeaders: (id) => {
        const basicHeaders = exports.Utils.getBasicHeaders(id);
        basicHeaders.set('Content-Type', 'application/json');
        return basicHeaders;
    },
    getBasicHeaders: (id) => {
        const config = typedi_1.Container.of(id).get(di_tokens_1.CONFIG);
        const headers = new Headers({
            'x-ttm-sdk-version': package_json_1.version,
            'x-ttm-sdk-product': 'JS',
            'x-ttm-sdk-debug': `${config.verbose}`,
        });
        const apiKeyHeader = 'x-api-key';
        if (config.apiKey) {
            if (typeof config.apiKey === 'string') {
                headers.append(apiKeyHeader, config.apiKey);
            }
            else if (config.version === service_1.ApiVersion.V3 && config.apiKey.v3) {
                headers.append(apiKeyHeader, config.apiKey.v3);
            }
            else if (config.version === service_1.ApiVersion.V4 && config.apiKey.v4) {
                headers.append(apiKeyHeader, config.apiKey.v4);
            }
        }
        return headers;
    },
    padWithZero: (data, length = 64) => data.replace('0x', '').padStart(length, '0'),
    camelToSnakeCase: (str) => str.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`),
    camelToDashCase: (str) => str.replace(/[A-Z]/g, (letter) => `-${letter.toLowerCase()}`),
    identity: (x) => x,
    convertObjectWithStrategy: (obj, strategy) => {
        if (Array.isArray(obj)) {
            return obj.map(exports.Utils.convertObjCamelToSnake);
        }
        const snakeObj = {};
        for (const [key, value] of Object.entries(obj)) {
            const snakeKey = strategy(key);
            if (value instanceof bignumber_js_1.BigNumber) {
                snakeObj[snakeKey] = value.toNumber();
            }
            else if (typeof value === 'object' && value !== null) {
                snakeObj[snakeKey] = exports.Utils.convertObjectWithStrategy(value, strategy);
            }
            else {
                snakeObj[snakeKey] = value;
            }
        }
        return snakeObj;
    },
    convertObjCamelToSnake: (obj) => exports.Utils.convertObjectWithStrategy(obj, exports.Utils.camelToSnakeCase),
    convertObjCamelToDash: (obj) => exports.Utils.convertObjectWithStrategy(obj, exports.Utils.camelToDashCase),
    getClient: (id, network) => {
        switch (network) {
            case dto_1.Network.BITCOIN:
            case dto_1.Network.BITCOIN_TESTNET:
                return new service_1.Bitcoin(id);
            case dto_1.Network.LITECOIN:
            case dto_1.Network.LITECOIN_TESTNET:
                return new service_1.Litecoin(id);
            case dto_1.Network.DOGECOIN:
            case dto_1.Network.DOGECOIN_TESTNET:
                return new service_1.Dogecoin(id);
            case dto_1.Network.BITCOIN_CASH:
            case dto_1.Network.BITCOIN_CASH_TESTNET:
                return new service_1.BitcoinCash(id);
            case dto_1.Network.ZCASH:
            case dto_1.Network.ZCASH_TESTNET:
                return new service_1.ZCash(id);
            case dto_1.Network.ETHEREUM:
            case dto_1.Network.ETHEREUM_SEPOLIA:
            case dto_1.Network.ETHEREUM_HOLESKY:
                return new service_1.Ethereum(id);
            case dto_1.Network.ETHEREUM_CLASSIC:
                return new service_1.EthereumClassic(id);
            case dto_1.Network.ARBITRUM_NOVA:
            case dto_1.Network.ARBITRUM_NOVA_TESTNET:
                return new service_1.ArbitrumNova(id);
            case dto_1.Network.ARBITRUM_ONE:
                return new service_1.ArbitrumOne(id);
            case dto_1.Network.AURORA:
            case dto_1.Network.AURORA_TESTNET:
                return new service_1.Aurora(id);
            case dto_1.Network.AVALANCHE_C:
            case dto_1.Network.AVALANCHE_C_TESTNET:
            case dto_1.Network.AVALANCHE_P:
            case dto_1.Network.AVALANCHE_P_TESTNET:
            case dto_1.Network.AVALANCHE_X:
            case dto_1.Network.AVALANCHE_X_TESTNET:
                return new service_1.AvalancheC(id);
            case dto_1.Network.BINANCE_SMART_CHAIN:
            case dto_1.Network.BINANCE_SMART_CHAIN_TESTNET:
                return new service_1.BinanceSmartChain(id);
            case dto_1.Network.CELO:
            case dto_1.Network.CELO_ALFAJORES:
                return new service_1.Celo(id);
            case dto_1.Network.CRONOS:
            case dto_1.Network.CRONOS_TESTNET:
                return new service_1.Cronos(id);
            case dto_1.Network.FANTOM:
            case dto_1.Network.FANTOM_TESTNET:
                return new service_1.Fantom(id);
            case dto_1.Network.GNOSIS:
            case dto_1.Network.GNOSIS_TESTNET:
                return new service_1.Gnosis(id);
            case dto_1.Network.HARMONY_ONE_SHARD_0:
            case dto_1.Network.HARMONY_ONE_TESTNET_SHARD_0:
                return new service_1.HarmonyOne(id);
            case dto_1.Network.HAQQ:
            case dto_1.Network.HAQQ_TESTNET:
                return new service_1.Haqq(id);
            case dto_1.Network.FLARE:
            case dto_1.Network.FLARE_COSTON:
            case dto_1.Network.FLARE_COSTON_2:
            case dto_1.Network.FLARE_SONGBIRD:
                return new service_1.Flare(id);
            case dto_1.Network.KLAYTN:
            case dto_1.Network.KLAYTN_BAOBAB:
                return new service_1.Klaytn(id);
            case dto_1.Network.KUCOIN:
            case dto_1.Network.KUCOIN_TESTNET:
                return new service_1.Kucoin(id);
            case dto_1.Network.OASIS:
            case dto_1.Network.OASIS_TESTNET:
                return new service_1.Oasis(id);
            case dto_1.Network.OPTIMISM:
            case dto_1.Network.OPTIMISM_TESTNET:
                return new service_1.Optimism(id);
            case dto_1.Network.PALM:
            case dto_1.Network.PALM_TESTNET:
                return new service_1.Palm(id);
            case dto_1.Network.POLYGON:
            case dto_1.Network.POLYGON_AMOY:
                return new service_1.Polygon(id);
            case dto_1.Network.VECHAIN:
            case dto_1.Network.VECHAIN_TESTNET:
                return new service_1.Vechain(id);
            case dto_1.Network.XINFIN:
            case dto_1.Network.XINFIN_TESTNET:
                return new service_1.XinFin(id);
            case dto_1.Network.XRP:
            case dto_1.Network.XRP_TESTNET:
                return new service_1.Xrp(id);
            case dto_1.Network.SOLANA:
            case dto_1.Network.SOLANA_DEVNET:
                return new service_1.Solana(id);
            case dto_1.Network.TRON:
            case dto_1.Network.TRON_SHASTA:
                return new service_1.Tron(id);
            case dto_1.Network.TEZOS:
            case dto_1.Network.TEZOS_TESTNET:
                return new service_1.Tezos(id);
            case dto_1.Network.HORIZEN_EON:
            case dto_1.Network.HORIZEN_EON_GOBI:
                return new service_1.HorizenEon(id);
            case dto_1.Network.EOS:
            case dto_1.Network.EOS_TESTNET:
                return new service_1.Eos(id);
            case dto_1.Network.CHILIZ:
                return new service_1.Chiliz(id);
            case dto_1.Network.BNB:
                return new service_1.Bnb(id);
            case dto_1.Network.ALGORAND_ALGOD:
            case dto_1.Network.ALGORAND_ALGOD_TESTNET:
                return new service_1.AlgorandAlgod(id);
            case dto_1.Network.ALGORAND_INDEXER:
            case dto_1.Network.ALGORAND_INDEXER_TESTNET:
                return new service_1.AlgorandIndexer(id);
            case dto_1.Network.CARDANO_ROSETTA:
            case dto_1.Network.CARDANO_ROSETTA_PREPROD:
                return new service_1.CardanoRosetta(id);
            case dto_1.Network.COSMOS_ROSETTA:
                return new service_1.CosmosRosetta(id);
            case dto_1.Network.STELLAR:
            case dto_1.Network.STELLAR_TESTNET:
                return new service_1.Stellar(id);
            case dto_1.Network.BASE:
            case dto_1.Network.BASE_SEPOLIA:
                return new service_1.Base(id);
            case dto_1.Network.KADENA:
            case dto_1.Network.KADENA_TESTNET:
                return new service_1.Kadena(id);
            case dto_1.Network.ROSTRUM:
            case dto_1.Network.ROSTRUM_TESTNET:
                return new service_1.Rostrum(id);
            case dto_1.Network.IOTA:
            case dto_1.Network.IOTA_TESTNET:
                return new service_1.Iota(id);
            case dto_1.Network.BITCOIN_ELECTRS:
            case dto_1.Network.BITCOIN_ELECTRS_TESTNET:
                return new service_1.BitcoinElectrs(id);
            case dto_1.Network.CASPER:
                return new service_1.Casper(id);
            case dto_1.Network.TON:
            case dto_1.Network.TON_TESTNET:
                return new service_1.Ton(id);
            case dto_1.Network.ZK_SYNC:
            case dto_1.Network.ZK_SYNC_TESTNET:
                return new service_1.ZkSync(id);
            default:
                return new service_1.FullSdk(id);
        }
    },
    /**
     * Log message to console if verbose mode is enabled.
     * @deprecated Use `Container.of(id).get(LOGGER)` instead.
     */
    log: ({ id, message, data, mode }) => {
        const config = typedi_1.Container.of(id).get(di_tokens_1.CONFIG);
        if (config.verbose) {
            if (data) {
                if (mode === 'table') {
                    console.table(data);
                }
                else {
                    console.debug(new Date().toISOString(), message, data);
                }
            }
            else {
                console.debug(new Date().toISOString(), message);
            }
        }
    },
    prepareRpcCall: (method, params, id = 1) => {
        return {
            jsonrpc: '2.0',
            id,
            method,
            params,
        };
    },
    deepMerge(target, source) {
        const isObject = (obj) => typeof obj === 'object' && obj !== null;
        if (!isObject(target) || !isObject(source)) {
            return source;
        }
        const output = { ...target };
        Object.keys(source).forEach((key) => {
            const targetValue = output[key];
            const sourceValue = source[key];
            if (Array.isArray(targetValue) && Array.isArray(sourceValue)) {
                output[key] = [...targetValue, ...sourceValue];
            }
            else if (isObject(targetValue) && isObject(sourceValue)) {
                output[key] = exports.Utils.deepMerge(targetValue, sourceValue);
            }
            else {
                output[key] = sourceValue;
            }
        });
        return output;
    },
    getV3RpcUrl: (config, path) => {
        const { apiKey, rpc, network } = config;
        if (apiKey) {
            const url = rpc?.nodes?.[0].url ||
                `${constant_1.Constant.TATUM_API_URL.V3}blockchain/node/${network}/${typeof apiKey === 'string' ? apiKey : apiKey.v3 || apiKey.v4}`;
            return url.concat(path || '');
        }
        return rpc?.nodes?.[0].url || `${constant_1.Constant.TATUM_API_URL.V3}blockchain/node/${network}`.concat(path || '');
    },
    addQueryParams: ({ basePath, strategy, queryParams, }) => {
        let queryString = '';
        if (queryParams) {
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore
            const query = exports.Utils.convertObjectWithStrategy(queryParams, strategy ?? exports.Utils.identity);
            const params = [];
            Object.entries(query).forEach(([key, value]) => {
                if (Array.isArray(value)) {
                    value.forEach((val) => {
                        if (val != null) {
                            params.push(`${encodeURIComponent(key)}=${encodeURIComponent(val)}`);
                        }
                    });
                }
                else {
                    if (value != null) {
                        params.push(`${encodeURIComponent(key)}=${encodeURIComponent(value)}`);
                    }
                }
            });
            if (params.length > 0) {
                queryString = '?' + params.join('&');
            }
        }
        return basePath + queryString;
    },
    removeLastSlash: (url) => url.replace(/\/$/, ''),
};
//# sourceMappingURL=util.shared.js.map