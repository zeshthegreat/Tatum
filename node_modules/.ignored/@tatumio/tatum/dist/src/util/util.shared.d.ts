import { AddressEventNotificationChain, JsonRpcCall, JsonRpcResponse, Network, QueryParams, QueryValue } from '../dto';
import { TatumConfig } from '../service';
export declare const Utils: {
    getRpc: <T>(id: string, config: TatumConfig) => T;
    getRpcListUrl: (network: Network) => string[];
    mapRpcListUrl: (network: Network) => string;
    getStatusPayload: (network: Network) => {
        method: string;
        params: {
            ledger_index: string;
            transactions: boolean;
            expand: boolean;
            owner_funds: boolean;
        }[];
        id: number;
        jsonrpc: string;
        network_identifier?: undefined;
    } | {
        jsonrpc: string;
        method: string;
        params: {};
        id: number;
        network_identifier?: undefined;
    } | {
        network_identifier: {
            blockchain: string;
            network: string;
        };
        method?: undefined;
        params?: undefined;
        id?: undefined;
        jsonrpc?: undefined;
    } | null;
    getStatusUrl(network: Network, url: string): string;
    getStatusMethod(network: Network): string;
    parseStatusPayload: (network: Network, response: JsonRpcResponse<any> | any) => number;
    isResponseOk: (network: Network, response: JsonRpcResponse<any> | any) => boolean;
    mapNotificationChainToNetwork: (chain: AddressEventNotificationChain) => Network;
    mapNetworkToNotificationChain: (network: Network) => AddressEventNotificationChain;
    delay: (t: number) => Promise<unknown>;
    retryWithTimeout: <T_1>(action: () => Promise<T_1>, timeoutInMs?: number, delayInMs?: number) => Promise<T_1>;
    fetchWithTimeoutAndRetry: (url: string, containerId: string, config: RequestInit, timeout?: number, retry?: number) => Promise<{
        response: Response;
        responseTime: number;
    }>;
    fetchWithTimeout: (url: string, containerId: string, config: RequestInit, timeout?: number) => Promise<{
        response: Response;
        responseTime: number;
    }>;
    headersToJson(headers: any): string;
    getHeaders: (id: string) => Headers;
    getBasicHeaders: (id: string) => Headers;
    padWithZero: (data: string, length?: number) => string;
    camelToSnakeCase: (str: string) => string;
    camelToDashCase: (str: string) => string;
    identity: <T_2>(x: T_2) => T_2;
    convertObjectWithStrategy: (obj: object, strategy: (key: string) => string) => Record<string, unknown> | Record<string, unknown>[];
    convertObjCamelToSnake: (obj: object) => Record<string, unknown> | Record<string, unknown>[];
    convertObjCamelToDash: (obj: object) => Record<string, unknown> | Record<string, unknown>[];
    getClient: <T_3>(id: string, network: Network) => T_3;
    /**
     * Log message to console if verbose mode is enabled.
     * @deprecated Use `Container.of(id).get(LOGGER)` instead.
     */
    log: ({ id, message, data, mode }: {
        id: string;
        message?: string | undefined;
        data?: object | undefined;
        mode?: "table" | undefined;
    }) => void;
    prepareRpcCall: (method: string, params?: unknown[], id?: number) => JsonRpcCall;
    deepMerge(target: unknown, source: unknown): unknown;
    getV3RpcUrl: (config: TatumConfig, path?: string) => string;
    addQueryParams: ({ basePath, strategy, queryParams, }: {
        basePath: string;
        strategy?: ((key: string) => string) | undefined;
        queryParams?: Partial<Record<string, QueryValue>> | undefined;
    }) => string;
    removeLastSlash: (url: string) => string;
};
