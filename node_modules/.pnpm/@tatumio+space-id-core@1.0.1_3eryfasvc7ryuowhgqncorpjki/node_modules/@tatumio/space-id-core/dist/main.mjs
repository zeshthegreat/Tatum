// src/main.ts
import "reflect-metadata";

// src/extension.ts
import { isSolanaNetwork, Network, TatumSdkExtension } from "@tatumio/tatum";
import { LoadBalancer } from "@tatumio/tatum/dist/src/service/rpc/generic/LoadBalancer";
import { NetworkUtils } from "@tatumio/tatum/dist/src/util/network.utils";
import { createWeb3Name } from "@web3-name-sdk/core";
import { createSolName } from "@web3-name-sdk/core/solName";
import SIDRegister from "@web3-name-sdk/register";
import { ethers } from "ethers";
var SpaceIdCore = class extends TatumSdkExtension {
  constructor(tatumSdkContainer) {
    super(tatumSdkContainer);
    this.supportedNetworks = [
      Network.ETHEREUM,
      Network.ARBITRUM_ONE,
      Network.BINANCE_SMART_CHAIN,
      Network.GNOSIS,
      Network.SOLANA
    ];
    this.loadBalancer = this.tatumSdkContainer.get(LoadBalancer);
    this.sdkConfig = this.tatumSdkContainer.getConfig();
  }
  async getAddress(name, optional) {
    if (isSolanaNetwork(this.sdkConfig.network)) {
      return createSolName().getAddress({ name });
    }
    return createWeb3Name().getAddress(name, optional);
  }
  async getDomainName(address, optional) {
    if (isSolanaNetwork(this.sdkConfig.network)) {
      return createSolName().getDomainName({ address });
    }
    return createWeb3Name().getDomainName({ address, ...optional });
  }
  async getDomainNames(address, optional) {
    this.validateIfNotSolana();
    return createWeb3Name().getDomainNames({ address, ...optional });
  }
  async getDomainNameBatch(addresses, optional) {
    this.validateIfNotSolana();
    return createWeb3Name().batchGetDomainName({ addressList: addresses, ...optional });
  }
  async getDomainRecord(name, key, optional) {
    this.validateIfNotSolana();
    return createWeb3Name().getDomainRecord({ name, key, ...optional });
  }
  async getMetadata(name, optional) {
    this.validateIfNotSolana();
    return createWeb3Name().getMetadata({ name, ...optional });
  }
  async getContentHash(name, optional) {
    this.validateIfNotSolana();
    return createWeb3Name().getContentHash({ name, ...optional });
  }
  async isDomainAvailable(name, privateKey) {
    const { client } = await this.getRegisterClient(privateKey);
    return client.getAvailable(name);
  }
  async getRegistrationFee(name, years, privateKey) {
    const { client } = await this.getRegisterClient(privateKey);
    return client.getRentPrice(name, years);
  }
  async registerDomain(name, years, privateKey) {
    const { client, address } = await this.getRegisterClient(privateKey);
    if (await client.getAvailable(name)) {
      const price = await client.getRentPrice(name, years);
      await client.register(
        name,
        address,
        years,
        this.sdkConfig.network === Network.ETHEREUM ? {
          onCommitSuccess: (waitTime) => {
            return new Promise((resolve) => {
              setTimeout(resolve, waitTime * 1e3);
            });
          }
        } : void 0
      );
      console.log(`[SpaceIdCore] Registered domain ${name} for ${price}`);
      return true;
    }
    console.error(`[SpaceIdCore] Domain ${name} is unavailable`);
    return false;
  }
  validateIfNotSolana() {
    if (isSolanaNetwork(this.sdkConfig.network)) {
      throw new Error(`[SpaceIdCore] Method not supported for selected chain`);
    }
  }
  getApiKey() {
    if (this.sdkConfig.apiKey && typeof this.sdkConfig.apiKey !== "string") {
      return this.sdkConfig.apiKey.v4 || this.sdkConfig.apiKey.v3 || "";
    }
    return this.sdkConfig.apiKey || "";
  }
  async getRegisterClient(privateKey) {
    const supportedChainIds = [1, 56, 97];
    const chainId = NetworkUtils.getChainId(this.sdkConfig.network);
    if (!supportedChainIds.includes(chainId)) {
      throw new Error(`[SpaceIdCore] Domain registration not supported for selected chain`);
    }
    const provider = new ethers.providers.JsonRpcProvider(
      { url: this.loadBalancer.getRpcNodeUrl(), headers: { "x-api-key": this.getApiKey() } },
      chainId
    );
    const signer = new ethers.Wallet(privateKey, provider);
    return { client: new SIDRegister({ signer, chainId }), address: await signer.getAddress() };
  }
};
export {
  SpaceIdCore
};
