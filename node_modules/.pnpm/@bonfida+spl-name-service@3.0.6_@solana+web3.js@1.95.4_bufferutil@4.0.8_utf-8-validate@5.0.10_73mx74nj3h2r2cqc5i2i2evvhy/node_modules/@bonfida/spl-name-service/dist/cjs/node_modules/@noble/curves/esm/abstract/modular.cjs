"use strict";var t=require("./utils.cjs");
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const r=BigInt(0),e=BigInt(1),n=BigInt(2),o=BigInt(3),i=BigInt(4),s=BigInt(5),u=BigInt(8);function f(t,e){const n=t%e;return n>=r?n:e+n}function c(t,n,o){if(o<=r||n<r)throw new Error("Expected power/modulo > 0");if(o===e)return r;let i=e;for(;n>r;)n&e&&(i=i*t%o),t=t*t%o,n>>=e;return i}function l(t,n){if(t===r||n<=r)throw new Error(`invert: expected positive integers, got n=${t} mod=${n}`);let o=f(t,n),i=n,s=r,u=e;for(;o!==r;){const t=i%o,r=s-u*(i/o);i=o,o=t,s=u,u=r}if(i!==e)throw new Error("invert: does not exist");return f(s,n)}function d(t){const o=(t-e)/n;let s,u,f;for(s=t-e,u=0;s%n===r;s/=n,u++);for(f=n;f<t&&c(f,o,t)!==t-e;f++);if(1===u){const r=(t+e)/i;return function(t,e){const n=t.pow(e,r);if(!t.eql(t.sqr(n),e))throw new Error("Cannot find square root");return n}}const l=(s+e)/n;return function(t,r){if(t.pow(r,o)===t.neg(t.ONE))throw new Error("Cannot find square root");let n=u,i=t.pow(t.mul(t.ONE,f),s),c=t.pow(r,l),d=t.pow(r,s);for(;!t.eql(d,t.ONE);){if(t.eql(d,t.ZERO))return t.ZERO;let r=1;for(let e=t.sqr(d);r<n&&!t.eql(e,t.ONE);r++)e=t.sqr(e);const o=t.pow(i,e<<BigInt(n-r-1));i=t.sqr(o),c=t.mul(c,o),d=t.mul(d,i),n=r}return c}}function p(t){if(t%i===o){const r=(t+e)/i;return function(t,e){const n=t.pow(e,r);if(!t.eql(t.sqr(n),e))throw new Error("Cannot find square root");return n}}if(t%u===s){const r=(t-s)/u;return function(t,e){const o=t.mul(e,n),i=t.pow(o,r),s=t.mul(e,i),u=t.mul(t.mul(s,n),i),f=t.mul(s,t.sub(u,t.ONE));if(!t.eql(t.sqr(f),e))throw new Error("Cannot find square root");return f}}return d(t)}BigInt(9),BigInt(16);const w=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function E(t,n,o){if(o<r)throw new Error("Expected power > 0");if(o===r)return t.ONE;if(o===e)return n;let i=t.ONE,s=n;for(;o>r;)o&e&&(i=t.mul(i,s)),s=t.sqr(s),o>>=e;return i}function g(t,r){const e=new Array(r.length),n=r.reduce(((r,n,o)=>t.is0(n)?r:(e[o]=r,t.mul(r,n))),t.ONE),o=t.inv(n);return r.reduceRight(((r,n,o)=>t.is0(n)?r:(e[o]=t.mul(r,e[o]),t.mul(r,n))),o),e}function a(t,r){const e=void 0!==r?r:t.toString(2).length;return{nBitLength:e,nByteLength:Math.ceil(e/8)}}exports.Field=function(n,o,i=!1,s={}){if(n<=r)throw new Error(`Expected Field ORDER > 0, got ${n}`);const{nBitLength:u,nByteLength:c}=a(n,o);if(c>2048)throw new Error("Field lengths over 2048 bytes are not supported");const d=p(n),w=Object.freeze({ORDER:n,BITS:u,BYTES:c,MASK:t.bitMask(u),ZERO:r,ONE:e,create:t=>f(t,n),isValid:t=>{if("bigint"!=typeof t)throw new Error("Invalid field element: expected bigint, got "+typeof t);return r<=t&&t<n},is0:t=>t===r,isOdd:t=>(t&e)===e,neg:t=>f(-t,n),eql:(t,r)=>t===r,sqr:t=>f(t*t,n),add:(t,r)=>f(t+r,n),sub:(t,r)=>f(t-r,n),mul:(t,r)=>f(t*r,n),pow:(t,r)=>E(w,t,r),div:(t,r)=>f(t*l(r,n),n),sqrN:t=>t*t,addN:(t,r)=>t+r,subN:(t,r)=>t-r,mulN:(t,r)=>t*r,inv:t=>l(t,n),sqrt:s.sqrt||(t=>d(w,t)),invertBatch:t=>g(w,t),cmov:(t,r,e)=>e?r:t,toBytes:r=>i?t.numberToBytesLE(r,c):t.numberToBytesBE(r,c),fromBytes:r=>{if(r.length!==c)throw new Error(`Fp.fromBytes: expected ${c}, got ${r.length}`);return i?t.bytesToNumberLE(r):t.bytesToNumberBE(r)}});return Object.freeze(w)},exports.FpInvertBatch=g,exports.FpPow=E,exports.FpSqrt=p,exports.FpSqrtEven=function(t,r){if(!t.isOdd)throw new Error("Field doesn't have isOdd");const e=t.sqrt(r);return t.isOdd(e)?t.neg(e):e},exports.invert=l,exports.isNegativeLE=(t,r)=>(f(t,r)&e)===e,exports.mod=f,exports.nLength=a,exports.pow=c,exports.pow2=function(t,e,n){let o=t;for(;e-- >r;)o*=o,o%=n;return o},exports.tonelliShanks=d,exports.validateField=function(r){const e=w.reduce(((t,r)=>(t[r]="function",t)),{ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"});return t.validateObject(r,e)};
//# sourceMappingURL=modular.cjs.map
