"use strict";
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */BigInt(0);const t=BigInt(1),e=BigInt(2);function r(t){return t instanceof Uint8Array||null!=t&&"object"==typeof t&&"Uint8Array"===t.constructor.name}function n(t){if(!r(t))throw new Error("Uint8Array expected")}const o=Array.from({length:256},((t,e)=>e.toString(16).padStart(2,"0")));function i(t){n(t);let e="";for(let r=0;r<t.length;r++)e+=o[t[r]];return e}function s(t){if("string"!=typeof t)throw new Error("hex string expected, got "+typeof t);return BigInt(""===t?"0":`0x${t}`)}const f={_0:48,_9:57,_A:65,_F:70,_a:97,_f:102};function c(t){return t>=f._0&&t<=f._9?t-f._0:t>=f._A&&t<=f._F?t-(f._A-10):t>=f._a&&t<=f._f?t-(f._a-10):void 0}function a(t){if("string"!=typeof t)throw new Error("hex string expected, got "+typeof t);const e=t.length,r=e/2;if(e%2)throw new Error("padded hex string expected, got unpadded hex of length "+e);const n=new Uint8Array(r);for(let e=0,o=0;e<r;e++,o+=2){const r=c(t.charCodeAt(o)),i=c(t.charCodeAt(o+1));if(void 0===r||void 0===i){const e=t[o]+t[o+1];throw new Error('hex string expected, got non-hex character "'+e+'" at index '+o)}n[e]=16*r+i}return n}function u(t,e){return a(t.toString(16).padStart(2*e,"0"))}const p={bigint:t=>"bigint"==typeof t,function:t=>"function"==typeof t,boolean:t=>"boolean"==typeof t,string:t=>"string"==typeof t,stringOrUint8Array:t=>"string"==typeof t||r(t),isSafeInteger:t=>Number.isSafeInteger(t),array:t=>Array.isArray(t),field:(t,e)=>e.Fp.isValid(t),hash:t=>"function"==typeof t&&Number.isSafeInteger(t.outputLen)};exports.abytes=n,exports.bitMask=r=>(e<<BigInt(r-1))-t,exports.bytesToHex=i,exports.bytesToNumberBE=function(t){return s(i(t))},exports.bytesToNumberLE=function(t){return n(t),s(i(Uint8Array.from(t).reverse()))},exports.concatBytes=function(...t){let e=0;for(let r=0;r<t.length;r++){const o=t[r];n(o),e+=o.length}const r=new Uint8Array(e);for(let e=0,n=0;e<t.length;e++){const o=t[e];r.set(o,n),n+=o.length}return r},exports.ensureBytes=function(t,e,n){let o;if("string"==typeof e)try{o=a(e)}catch(r){throw new Error(`${t} must be valid hex string, got "${e}". Cause: ${r}`)}else{if(!r(e))throw new Error(`${t} must be hex string or Uint8Array`);o=Uint8Array.from(e)}const i=o.length;if("number"==typeof n&&i!==n)throw new Error(`${t} expected ${n} bytes, got ${i}`);return o},exports.hexToBytes=a,exports.hexToNumber=s,exports.isBytes=r,exports.numberToBytesBE=u,exports.numberToBytesLE=function(t,e){return u(t,e).reverse()},exports.validateObject=function(t,e,r={}){const n=(e,r,n)=>{const o=p[r];if("function"!=typeof o)throw new Error(`Invalid validator "${r}", expected function`);const i=t[e];if(!(n&&void 0===i||o(i,t)))throw new Error(`Invalid param ${String(e)}=${i} (${typeof i}), expected ${r}`)};for(const[t,r]of Object.entries(e))n(t,r,!1);for(const[t,e]of Object.entries(r))n(t,e,!0);return t};
//# sourceMappingURL=utils.cjs.map
