"use strict";var t=require("./modular.cjs"),e=require("./utils.cjs"),n=require("./curve.cjs");
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const r=BigInt(0),i=BigInt(1),s=BigInt(2),o=BigInt(8),a={zip215:!0};exports.twistedEdwards=function(u){const c=function(t){const r=n.validateBasic(t);return e.validateObject(t,{hash:"function",a:"bigint",d:"bigint",randomBytes:"function"},{adjustScalarBytes:"function",domain:"function",uvRatio:"function",mapToCurve:"function"}),Object.freeze({...r})}(u),{Fp:f,n:l,prehash:h,hash:y,randomBytes:d,nByteLength:w,h:p}=c,x=s<<BigInt(8*w)-i,B=f.create,m=c.uvRatio||((t,e)=>{try{return{isValid:!0,value:f.sqrt(t*f.inv(e))}}catch(t){return{isValid:!1,value:r}}}),E=c.adjustScalarBytes||(t=>t),g=c.domain||((t,e,n)=>{if(e.length||n)throw new Error("Contexts/pre-hash are not supported");return t}),b=t=>"bigint"==typeof t&&r<t,v=(t,e)=>b(t)&&b(e)&&t<e,z=t=>t===r||v(t,x);function A(t,e){if(v(t,e))return t;throw new Error(`Expected valid scalar < ${e}, got ${typeof t} ${t}`)}function R(t){return t===r?t:A(t,l)}const S=new Map;function q(t){if(!(t instanceof T))throw new Error("ExtendedPoint expected")}class T{constructor(t,e,n,r){if(this.ex=t,this.ey=e,this.ez=n,this.et=r,!z(t))throw new Error("x required");if(!z(e))throw new Error("y required");if(!z(n))throw new Error("z required");if(!z(r))throw new Error("t required")}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static fromAffine(t){if(t instanceof T)throw new Error("extended point not allowed");const{x:e,y:n}=t||{};if(!z(e)||!z(n))throw new Error("invalid affine point");return new T(e,n,i,B(e*n))}static normalizeZ(t){const e=f.invertBatch(t.map((t=>t.ez)));return t.map(((t,n)=>t.toAffine(e[n]))).map(T.fromAffine)}_setWindowSize(t){this._WINDOW_SIZE=t,S.delete(this)}assertValidity(){const{a:t,d:e}=c;if(this.is0())throw new Error("bad point: ZERO");const{ex:n,ey:r,ez:i,et:s}=this,o=B(n*n),a=B(r*r),u=B(i*i),f=B(u*u),l=B(o*t);if(B(u*B(l+a))!==B(f+B(e*B(o*a))))throw new Error("bad point: equation left != right (1)");if(B(n*r)!==B(i*s))throw new Error("bad point: equation left != right (2)")}equals(t){q(t);const{ex:e,ey:n,ez:r}=this,{ex:i,ey:s,ez:o}=t,a=B(e*o),u=B(i*r),c=B(n*o),f=B(s*r);return a===u&&c===f}is0(){return this.equals(T.ZERO)}negate(){return new T(B(-this.ex),this.ey,this.ez,B(-this.et))}double(){const{a:t}=c,{ex:e,ey:n,ez:r}=this,i=B(e*e),o=B(n*n),a=B(s*B(r*r)),u=B(t*i),f=e+n,l=B(B(f*f)-i-o),h=u+o,y=h-a,d=u-o,w=B(l*y),p=B(h*d),x=B(l*d),m=B(y*h);return new T(w,p,m,x)}add(t){q(t);const{a:e,d:n}=c,{ex:i,ey:o,ez:a,et:u}=this,{ex:f,ey:l,ez:h,et:y}=t;if(e===BigInt(-1)){const t=B((o-i)*(l+f)),e=B((o+i)*(l-f)),n=B(e-t);if(n===r)return this.double();const c=B(a*s*y),d=B(u*s*h),w=d+c,p=e+t,x=d-c,m=B(w*n),E=B(p*x),g=B(w*x),b=B(n*p);return new T(m,E,b,g)}const d=B(i*f),w=B(o*l),p=B(u*n*y),x=B(a*h),m=B((i+o)*(f+l)-d-w),E=x-p,g=x+p,b=B(w-e*d),v=B(m*E),z=B(g*b),A=B(m*b),R=B(E*g);return new T(v,z,R,A)}subtract(t){return this.add(t.negate())}wNAF(t){return I.wNAFCached(this,S,t,T.normalizeZ)}multiply(t){const{p:e,f:n}=this.wNAF(A(t,l));return T.normalizeZ([e,n])[0]}multiplyUnsafe(t){let e=R(t);return e===r?Z:this.equals(Z)||e===i?this:this.equals(O)?this.wNAF(e).p:I.unsafeLadder(this,e)}isSmallOrder(){return this.multiplyUnsafe(p).is0()}isTorsionFree(){return I.unsafeLadder(this,l).is0()}toAffine(t){const{ex:e,ey:n,ez:s}=this,a=this.is0();null==t&&(t=a?o:f.inv(s));const u=B(e*t),c=B(n*t),l=B(s*t);if(a)return{x:r,y:i};if(l!==i)throw new Error("invZ was invalid");return{x:u,y:c}}clearCofactor(){const{h:t}=c;return t===i?this:this.multiplyUnsafe(t)}static fromHex(t,n=!1){const{d:s,a:o}=c,a=f.BYTES,u=(t=e.ensureBytes("pointHex",t,a)).slice(),l=t[a-1];u[a-1]=-129&l;const h=e.bytesToNumberLE(u);h===r||A(h,n?x:f.ORDER);const y=B(h*h),d=B(y-i),w=B(s*y-o);let{isValid:p,value:E}=m(d,w);if(!p)throw new Error("Point.fromHex: invalid y coordinate");const g=(E&i)===i,b=0!=(128&l);if(!n&&E===r&&b)throw new Error("Point.fromHex: x=0 and x_0=1");return b!==g&&(E=B(-E)),T.fromAffine({x:E,y:h})}static fromPrivateKey(t){return L(t).point}toRawBytes(){const{x:t,y:n}=this.toAffine(),r=e.numberToBytesLE(n,f.BYTES);return r[r.length-1]|=t&i?128:0,r}toHex(){return e.bytesToHex(this.toRawBytes())}}T.BASE=new T(c.Gx,c.Gy,i,B(c.Gx*c.Gy)),T.ZERO=new T(r,i,i,r);const{BASE:O,ZERO:Z}=T,I=n.wNAF(T,8*w);function N(e){return t.mod(e,l)}function H(t){return N(e.bytesToNumberLE(t))}function L(t){const n=w;t=e.ensureBytes("private key",t,n);const r=e.ensureBytes("hashed private key",y(t),2*n),i=E(r.slice(0,n)),s=r.slice(n,2*n),o=H(i),a=O.multiply(o),u=a.toRawBytes();return{head:i,prefix:s,scalar:o,point:a,pointBytes:u}}function P(t=new Uint8Array,...n){const r=e.concatBytes(...n);return H(y(g(r,e.ensureBytes("context",t),!!h)))}const j=a;return O._setWindowSize(8),{CURVE:c,getPublicKey:function(t){return L(t).pointBytes},sign:function(t,n,r={}){t=e.ensureBytes("message",t),h&&(t=h(t));const{prefix:i,scalar:s,pointBytes:o}=L(n),a=P(r.context,i,t),u=O.multiply(a).toRawBytes(),c=N(a+P(r.context,u,o,t)*s);R(c);const l=e.concatBytes(u,e.numberToBytesLE(c,f.BYTES));return e.ensureBytes("result",l,2*w)},verify:function(t,n,r,i=j){const{context:s,zip215:o}=i,a=f.BYTES;t=e.ensureBytes("signature",t,2*a),n=e.ensureBytes("message",n),h&&(n=h(n));const u=e.bytesToNumberLE(t.slice(a,2*a));let c,l,y;try{c=T.fromHex(r,o),l=T.fromHex(t.slice(0,a),o),y=O.multiplyUnsafe(u)}catch(t){return!1}if(!o&&c.isSmallOrder())return!1;const d=P(s,l.toRawBytes(),c.toRawBytes(),n);return l.add(c.multiplyUnsafe(d)).subtract(y).clearCofactor().equals(T.ZERO)},ExtendedPoint:T,utils:{getExtendedPublicKey:L,randomPrivateKey:()=>d(f.BYTES),precompute:(t=8,e=T.BASE)=>(e._setWindowSize(t),e.multiply(BigInt(3)),e)}}};
//# sourceMappingURL=edwards.cjs.map
