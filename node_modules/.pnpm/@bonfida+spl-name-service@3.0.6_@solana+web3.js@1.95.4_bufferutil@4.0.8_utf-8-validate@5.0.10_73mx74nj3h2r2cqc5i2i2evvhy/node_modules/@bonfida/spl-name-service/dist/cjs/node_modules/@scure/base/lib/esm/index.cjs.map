{"version":3,"file":"index.cjs","sources":["../../../../../../../node_modules/@scure/base/lib/esm/index.js"],"sourcesContent":["/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Utilities\n/**\n * @__NO_SIDE_EFFECTS__\n */\nexport function assertNumber(n) {\n    if (!Number.isSafeInteger(n))\n        throw new Error(`Wrong integer: ${n}`);\n}\nfunction isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction chain(...args) {\n    const id = (a) => a;\n    // Wrap call in closure so JIT can inline calls\n    const wrap = (a, b) => (c) => a(b(c));\n    // Construct chain of args[-1].encode(args[-2].encode([...]))\n    const encode = args.map((x) => x.encode).reduceRight(wrap, id);\n    // Construct chain of args[0].decode(args[1].decode(...))\n    const decode = args.map((x) => x.decode).reduce(wrap, id);\n    return { encode, decode };\n}\n/**\n * Encodes integer radix representation to array of strings using alphabet and back\n * @__NO_SIDE_EFFECTS__\n */\nfunction alphabet(alphabet) {\n    return {\n        encode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('alphabet.encode input should be an array of numbers');\n            return digits.map((i) => {\n                assertNumber(i);\n                if (i < 0 || i >= alphabet.length)\n                    throw new Error(`Digit index outside alphabet: ${i} (alphabet: ${alphabet.length})`);\n                return alphabet[i];\n            });\n        },\n        decode: (input) => {\n            if (!Array.isArray(input) || (input.length && typeof input[0] !== 'string'))\n                throw new Error('alphabet.decode input should be array of strings');\n            return input.map((letter) => {\n                if (typeof letter !== 'string')\n                    throw new Error(`alphabet.decode: not string element=${letter}`);\n                const index = alphabet.indexOf(letter);\n                if (index === -1)\n                    throw new Error(`Unknown letter: \"${letter}\". Allowed: ${alphabet}`);\n                return index;\n            });\n        },\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction join(separator = '') {\n    if (typeof separator !== 'string')\n        throw new Error('join separator should be string');\n    return {\n        encode: (from) => {\n            if (!Array.isArray(from) || (from.length && typeof from[0] !== 'string'))\n                throw new Error('join.encode input should be array of strings');\n            for (let i of from)\n                if (typeof i !== 'string')\n                    throw new Error(`join.encode: non-string input=${i}`);\n            return from.join(separator);\n        },\n        decode: (to) => {\n            if (typeof to !== 'string')\n                throw new Error('join.decode input should be string');\n            return to.split(separator);\n        },\n    };\n}\n/**\n * Pad strings array so it has integer number of bits\n * @__NO_SIDE_EFFECTS__\n */\nfunction padding(bits, chr = '=') {\n    assertNumber(bits);\n    if (typeof chr !== 'string')\n        throw new Error('padding chr should be string');\n    return {\n        encode(data) {\n            if (!Array.isArray(data) || (data.length && typeof data[0] !== 'string'))\n                throw new Error('padding.encode input should be array of strings');\n            for (let i of data)\n                if (typeof i !== 'string')\n                    throw new Error(`padding.encode: non-string input=${i}`);\n            while ((data.length * bits) % 8)\n                data.push(chr);\n            return data;\n        },\n        decode(input) {\n            if (!Array.isArray(input) || (input.length && typeof input[0] !== 'string'))\n                throw new Error('padding.encode input should be array of strings');\n            for (let i of input)\n                if (typeof i !== 'string')\n                    throw new Error(`padding.decode: non-string input=${i}`);\n            let end = input.length;\n            if ((end * bits) % 8)\n                throw new Error('Invalid padding: string should have whole number of bytes');\n            for (; end > 0 && input[end - 1] === chr; end--) {\n                if (!(((end - 1) * bits) % 8))\n                    throw new Error('Invalid padding: string has too much padding');\n            }\n            return input.slice(0, end);\n        },\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction normalize(fn) {\n    if (typeof fn !== 'function')\n        throw new Error('normalize fn should be function');\n    return { encode: (from) => from, decode: (to) => fn(to) };\n}\n/**\n * Slow: O(n^2) time complexity\n * @__NO_SIDE_EFFECTS__\n */\nfunction convertRadix(data, from, to) {\n    // base 1 is impossible\n    if (from < 2)\n        throw new Error(`convertRadix: wrong from=${from}, base cannot be less than 2`);\n    if (to < 2)\n        throw new Error(`convertRadix: wrong to=${to}, base cannot be less than 2`);\n    if (!Array.isArray(data))\n        throw new Error('convertRadix: data should be array');\n    if (!data.length)\n        return [];\n    let pos = 0;\n    const res = [];\n    const digits = Array.from(data);\n    digits.forEach((d) => {\n        assertNumber(d);\n        if (d < 0 || d >= from)\n            throw new Error(`Wrong integer: ${d}`);\n    });\n    while (true) {\n        let carry = 0;\n        let done = true;\n        for (let i = pos; i < digits.length; i++) {\n            const digit = digits[i];\n            const digitBase = from * carry + digit;\n            if (!Number.isSafeInteger(digitBase) ||\n                (from * carry) / from !== carry ||\n                digitBase - digit !== from * carry) {\n                throw new Error('convertRadix: carry overflow');\n            }\n            carry = digitBase % to;\n            const rounded = Math.floor(digitBase / to);\n            digits[i] = rounded;\n            if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase)\n                throw new Error('convertRadix: carry overflow');\n            if (!done)\n                continue;\n            else if (!rounded)\n                pos = i;\n            else\n                done = false;\n        }\n        res.push(carry);\n        if (done)\n            break;\n    }\n    for (let i = 0; i < data.length - 1 && data[i] === 0; i++)\n        res.push(0);\n    return res.reverse();\n}\nconst gcd = /* @__NO_SIDE_EFFECTS__ */ (a, b) => (!b ? a : gcd(b, a % b));\nconst radix2carry = /*@__NO_SIDE_EFFECTS__ */ (from, to) => from + (to - gcd(from, to));\n/**\n * Implemented with numbers, because BigInt is 5x slower\n * @__NO_SIDE_EFFECTS__\n */\nfunction convertRadix2(data, from, to, padding) {\n    if (!Array.isArray(data))\n        throw new Error('convertRadix2: data should be array');\n    if (from <= 0 || from > 32)\n        throw new Error(`convertRadix2: wrong from=${from}`);\n    if (to <= 0 || to > 32)\n        throw new Error(`convertRadix2: wrong to=${to}`);\n    if (radix2carry(from, to) > 32) {\n        throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);\n    }\n    let carry = 0;\n    let pos = 0; // bitwise position in current element\n    const mask = 2 ** to - 1;\n    const res = [];\n    for (const n of data) {\n        assertNumber(n);\n        if (n >= 2 ** from)\n            throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);\n        carry = (carry << from) | n;\n        if (pos + from > 32)\n            throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);\n        pos += from;\n        for (; pos >= to; pos -= to)\n            res.push(((carry >> (pos - to)) & mask) >>> 0);\n        carry &= 2 ** pos - 1; // clean carry, otherwise it will cause overflow\n    }\n    carry = (carry << (to - pos)) & mask;\n    if (!padding && pos >= from)\n        throw new Error('Excess padding');\n    if (!padding && carry)\n        throw new Error(`Non-zero padding: ${carry}`);\n    if (padding && pos > 0)\n        res.push(carry >>> 0);\n    return res;\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction radix(num) {\n    assertNumber(num);\n    return {\n        encode: (bytes) => {\n            if (!isBytes(bytes))\n                throw new Error('radix.encode input should be Uint8Array');\n            return convertRadix(Array.from(bytes), 2 ** 8, num);\n        },\n        decode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('radix.decode input should be array of numbers');\n            return Uint8Array.from(convertRadix(digits, num, 2 ** 8));\n        },\n    };\n}\n/**\n * If both bases are power of same number (like `2**8 <-> 2**64`),\n * there is a linear algorithm. For now we have implementation for power-of-two bases only.\n * @__NO_SIDE_EFFECTS__\n */\nfunction radix2(bits, revPadding = false) {\n    assertNumber(bits);\n    if (bits <= 0 || bits > 32)\n        throw new Error('radix2: bits should be in (0..32]');\n    if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)\n        throw new Error('radix2: carry overflow');\n    return {\n        encode: (bytes) => {\n            if (!isBytes(bytes))\n                throw new Error('radix2.encode input should be Uint8Array');\n            return convertRadix2(Array.from(bytes), 8, bits, !revPadding);\n        },\n        decode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('radix2.decode input should be array of numbers');\n            return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));\n        },\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction unsafeWrapper(fn) {\n    if (typeof fn !== 'function')\n        throw new Error('unsafeWrapper fn should be function');\n    return function (...args) {\n        try {\n            return fn.apply(null, args);\n        }\n        catch (e) { }\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction checksum(len, fn) {\n    assertNumber(len);\n    if (typeof fn !== 'function')\n        throw new Error('checksum fn should be function');\n    return {\n        encode(data) {\n            if (!isBytes(data))\n                throw new Error('checksum.encode: input should be Uint8Array');\n            const checksum = fn(data).slice(0, len);\n            const res = new Uint8Array(data.length + len);\n            res.set(data);\n            res.set(checksum, data.length);\n            return res;\n        },\n        decode(data) {\n            if (!isBytes(data))\n                throw new Error('checksum.decode: input should be Uint8Array');\n            const payload = data.slice(0, -len);\n            const newChecksum = fn(payload).slice(0, len);\n            const oldChecksum = data.slice(-len);\n            for (let i = 0; i < len; i++)\n                if (newChecksum[i] !== oldChecksum[i])\n                    throw new Error('Invalid checksum');\n            return payload;\n        },\n    };\n}\n// prettier-ignore\nexport const utils = {\n    alphabet, chain, checksum, convertRadix, convertRadix2, radix, radix2, join, padding,\n};\n// RFC 4648 aka RFC 3548\n// ---------------------\nexport const base16 = /* @__PURE__ */ chain(radix2(4), alphabet('0123456789ABCDEF'), join(''));\nexport const base32 = /* @__PURE__ */ chain(radix2(5), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'), padding(5), join(''));\nexport const base32hex = /* @__PURE__ */ chain(radix2(5), alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'), padding(5), join(''));\nexport const base32crockford = /* @__PURE__ */ chain(radix2(5), alphabet('0123456789ABCDEFGHJKMNPQRSTVWXYZ'), join(''), normalize((s) => s.toUpperCase().replace(/O/g, '0').replace(/[IL]/g, '1')));\nexport const base64 = /* @__PURE__ */ chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), padding(6), join(''));\nexport const base64nopad = /* @__PURE__ */ chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), join(''));\nexport const base64url = /* @__PURE__ */ chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), padding(6), join(''));\nexport const base64urlnopad = /* @__PURE__ */ chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), join(''));\n// base58 code\n// -----------\nconst genBase58 = (abc) => chain(radix(58), alphabet(abc), join(''));\nexport const base58 = /* @__PURE__ */ genBase58('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz');\nexport const base58flickr = /* @__PURE__ */ genBase58('123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ');\nexport const base58xrp = /* @__PURE__ */ genBase58('rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz');\n// xmr ver is done in 8-byte blocks (which equals 11 chars in decoding). Last (non-full) block padded with '1' to size in XMR_BLOCK_LEN.\n// Block encoding significantly reduces quadratic complexity of base58.\n// Data len (index) -> encoded block len\nconst XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];\nexport const base58xmr = {\n    encode(data) {\n        let res = '';\n        for (let i = 0; i < data.length; i += 8) {\n            const block = data.subarray(i, i + 8);\n            res += base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], '1');\n        }\n        return res;\n    },\n    decode(str) {\n        let res = [];\n        for (let i = 0; i < str.length; i += 11) {\n            const slice = str.slice(i, i + 11);\n            const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);\n            const block = base58.decode(slice);\n            for (let j = 0; j < block.length - blockLen; j++) {\n                if (block[j] !== 0)\n                    throw new Error('base58xmr: wrong padding');\n            }\n            res = res.concat(Array.from(block.slice(block.length - blockLen)));\n        }\n        return Uint8Array.from(res);\n    },\n};\nexport const createBase58check = /* @__PURE__ */ (sha256) => chain(checksum(4, (data) => sha256(sha256(data))), base58);\n// legacy export, bad name\nexport const base58check = createBase58check;\nconst BECH_ALPHABET = /* @__PURE__ */ chain(alphabet('qpzry9x8gf2tvdw0s3jn54khce6mua7l'), join(''));\nconst POLYMOD_GENERATORS = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction bech32Polymod(pre) {\n    const b = pre >> 25;\n    let chk = (pre & 0x1ffffff) << 5;\n    for (let i = 0; i < POLYMOD_GENERATORS.length; i++) {\n        if (((b >> i) & 1) === 1)\n            chk ^= POLYMOD_GENERATORS[i];\n    }\n    return chk;\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction bechChecksum(prefix, words, encodingConst = 1) {\n    const len = prefix.length;\n    let chk = 1;\n    for (let i = 0; i < len; i++) {\n        const c = prefix.charCodeAt(i);\n        if (c < 33 || c > 126)\n            throw new Error(`Invalid prefix (${prefix})`);\n        chk = bech32Polymod(chk) ^ (c >> 5);\n    }\n    chk = bech32Polymod(chk);\n    for (let i = 0; i < len; i++)\n        chk = bech32Polymod(chk) ^ (prefix.charCodeAt(i) & 0x1f);\n    for (let v of words)\n        chk = bech32Polymod(chk) ^ v;\n    for (let i = 0; i < 6; i++)\n        chk = bech32Polymod(chk);\n    chk ^= encodingConst;\n    return BECH_ALPHABET.encode(convertRadix2([chk % 2 ** 30], 30, 5, false));\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction genBech32(encoding) {\n    const ENCODING_CONST = encoding === 'bech32' ? 1 : 0x2bc830a3;\n    const _words = radix2(5);\n    const fromWords = _words.decode;\n    const toWords = _words.encode;\n    const fromWordsUnsafe = unsafeWrapper(fromWords);\n    function encode(prefix, words, limit = 90) {\n        if (typeof prefix !== 'string')\n            throw new Error(`bech32.encode prefix should be string, not ${typeof prefix}`);\n        if (!Array.isArray(words) || (words.length && typeof words[0] !== 'number'))\n            throw new Error(`bech32.encode words should be array of numbers, not ${typeof words}`);\n        if (prefix.length === 0)\n            throw new TypeError(`Invalid prefix length ${prefix.length}`);\n        const actualLength = prefix.length + 7 + words.length;\n        if (limit !== false && actualLength > limit)\n            throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);\n        const lowered = prefix.toLowerCase();\n        const sum = bechChecksum(lowered, words, ENCODING_CONST);\n        return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}`;\n    }\n    function decode(str, limit = 90) {\n        if (typeof str !== 'string')\n            throw new Error(`bech32.decode input should be string, not ${typeof str}`);\n        if (str.length < 8 || (limit !== false && str.length > limit))\n            throw new TypeError(`Wrong string length: ${str.length} (${str}). Expected (8..${limit})`);\n        // don't allow mixed case\n        const lowered = str.toLowerCase();\n        if (str !== lowered && str !== str.toUpperCase())\n            throw new Error(`String must be lowercase or uppercase`);\n        const sepIndex = lowered.lastIndexOf('1');\n        if (sepIndex === 0 || sepIndex === -1)\n            throw new Error(`Letter \"1\" must be present between prefix and data only`);\n        const prefix = lowered.slice(0, sepIndex);\n        const data = lowered.slice(sepIndex + 1);\n        if (data.length < 6)\n            throw new Error('Data must be at least 6 characters long');\n        const words = BECH_ALPHABET.decode(data).slice(0, -6);\n        const sum = bechChecksum(prefix, words, ENCODING_CONST);\n        if (!data.endsWith(sum))\n            throw new Error(`Invalid checksum in ${str}: expected \"${sum}\"`);\n        return { prefix, words };\n    }\n    const decodeUnsafe = unsafeWrapper(decode);\n    function decodeToBytes(str) {\n        const { prefix, words } = decode(str, false);\n        return { prefix, words, bytes: fromWords(words) };\n    }\n    return { encode, decode, decodeToBytes, decodeUnsafe, fromWords, fromWordsUnsafe, toWords };\n}\nexport const bech32 = /* @__PURE__ */ genBech32('bech32');\nexport const bech32m = /* @__PURE__ */ genBech32('bech32m');\nexport const utf8 = {\n    encode: (data) => new TextDecoder().decode(data),\n    decode: (str) => new TextEncoder().encode(str),\n};\nexport const hex = /* @__PURE__ */ chain(radix2(4), alphabet('0123456789abcdef'), join(''), normalize((s) => {\n    if (typeof s !== 'string' || s.length % 2)\n        throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);\n    return s.toLowerCase();\n}));\n// prettier-ignore\nconst CODERS = {\n    utf8, hex, base16, base32, base64, base64url, base58, base58xmr\n};\nconst coderTypeError = 'Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr';\nexport const bytesToString = (type, bytes) => {\n    if (typeof type !== 'string' || !CODERS.hasOwnProperty(type))\n        throw new TypeError(coderTypeError);\n    if (!isBytes(bytes))\n        throw new TypeError('bytesToString() expects Uint8Array');\n    return CODERS[type].encode(bytes);\n};\nexport const str = bytesToString; // as in python, but for bytes only\nexport const stringToBytes = (type, str) => {\n    if (!CODERS.hasOwnProperty(type))\n        throw new TypeError(coderTypeError);\n    if (typeof str !== 'string')\n        throw new TypeError('stringToBytes() expects string');\n    return CODERS[type].decode(str);\n};\nexport const bytes = stringToBytes;\n//# sourceMappingURL=index.js.map"],"names":["chain","args","id","a","wrap","b","c","encode","map","x","reduceRight","decode","reduce","gcd","radix2carry","from","to","convertRadix2","data","padding","Array","isArray","Error","carry","pos","mask","res","n","push","radix2","bits","revPadding","bytes","Uint8Array","constructor","name","digits","length","unsafeWrapper","fn","apply","e","BECH_ALPHABET","alphabet","i","input","letter","index","indexOf","separator","join","split","POLYMOD_GENERATORS","bech32Polymod","pre","chk","bechChecksum","prefix","words","encodingConst","len","charCodeAt","v","genBech32","encoding","ENCODING_CONST","_words","fromWords","toWords","fromWordsUnsafe","str","limit","TypeError","lowered","toLowerCase","toUpperCase","sepIndex","lastIndexOf","slice","sum","endsWith","actualLength","decodeToBytes","decodeUnsafe","bech32"],"mappings":"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","x_google_ignoreList":[0]}