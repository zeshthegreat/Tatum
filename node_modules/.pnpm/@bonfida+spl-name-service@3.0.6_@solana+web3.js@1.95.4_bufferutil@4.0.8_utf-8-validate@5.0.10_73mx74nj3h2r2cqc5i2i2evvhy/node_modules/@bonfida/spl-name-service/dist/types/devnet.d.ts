/// <reference types="node" />
import { Buffer } from "buffer";
import { Connection, PublicKey, TransactionInstruction } from "@solana/web3.js";
/**
 * Creates a name account with the given rent budget, allocated space, owner and class.
 *
 * @param connection The solana connection object to the RPC node
 * @param name The name of the new account
 * @param space The space in bytes allocated to the account
 * @param payerKey The allocation cost payer
 * @param nameOwner The pubkey to be set as owner of the new name account
 * @param lamports The budget to be set for the name account. If not specified, it'll be the minimum for rent exemption
 * @param nameClass The class of this new name
 * @param parentName The parent name of the new name. If specified its owner needs to sign
 * @returns
 */
declare function createNameRegistry(connection: Connection, name: string, space: number, payerKey: PublicKey, nameOwner: PublicKey, lamports?: number, nameClass?: PublicKey, parentName?: PublicKey): Promise<TransactionInstruction>;
/**
 * Overwrite the data of the given name registry.
 *
 * @param connection The solana connection object to the RPC node
 * @param name The name of the name registry to update
 * @param offset The offset to which the data should be written into the registry
 * @param input_data The data to be written
 * @param nameClass The class of this name, if it exsists
 * @param nameParent The parent name of this name, if it exists
 */
declare function updateNameRegistryData(connection: Connection, name: string, offset: number, input_data: Buffer, nameClass?: PublicKey, nameParent?: PublicKey): Promise<TransactionInstruction>;
/**
 * Change the owner of a given name account.
 *
 * @param connection The solana connection object to the RPC node
 * @param name The name of the name account
 * @param newOwner The new owner to be set
 * @param nameClass The class of this name, if it exsists
 * @param nameParent The parent name of this name, if it exists
 * @param parentOwner Parent name owner
 * @returns
 */
declare function transferNameOwnership(connection: Connection, name: string, newOwner: PublicKey, nameClass?: PublicKey, nameParent?: PublicKey, parentOwner?: PublicKey): Promise<TransactionInstruction>;
/**
 * Delete the name account and transfer the rent to the target.
 *
 * @param connection The solana connection object to the RPC node
 * @param name The name of the name account
 * @param refundTargetKey The refund destination address
 * @param nameClass The class of this name, if it exsists
 * @param nameParent The parent name of this name, if it exists
 * @returns
 */
declare function deleteNameRegistry(connection: Connection, name: string, refundTargetKey: PublicKey, nameClass?: PublicKey, nameParent?: PublicKey): Promise<TransactionInstruction>;
export declare const devnet: {
    utils: {
        getNameAccountKeySync: (hashed_name: Buffer, nameClass?: PublicKey, nameParent?: PublicKey) => PublicKey;
        reverseLookup: (connection: Connection, nameAccount: PublicKey) => Promise<string>;
        _deriveSync: (name: string, parent?: PublicKey, classKey?: PublicKey) => {
            pubkey: PublicKey;
            hashed: Buffer;
        };
        getDomainKeySync: (domain: string) => {
            isSub: boolean;
            parent: PublicKey;
            pubkey: PublicKey;
            hashed: Buffer;
        } | {
            isSub: boolean;
            parent: undefined;
            pubkey: PublicKey;
            hashed: Buffer;
        };
        getReverseKeySync: (domain: string, isSub?: boolean) => PublicKey;
    };
    constants: {
        /**
         * The Solana Name Service program ID
         */
        NAME_PROGRAM_ID: PublicKey;
        /**
         * Hash prefix used to derive domain name addresses
         */
        HASH_PREFIX: string;
        /**
         * The `.sol` TLD
         */
        ROOT_DOMAIN_ACCOUNT: PublicKey;
        /**
         * The Registry program ID
         */
        REGISTER_PROGRAM_ID: PublicKey;
        /**
         * The reverse look up class
         */
        REVERSE_LOOKUP_CLASS: PublicKey;
        USDC_MINT: PublicKey;
        REFERRERS: PublicKey[];
        TOKENS_SYM_MINT: Map<string, string>;
        PYTH_FEEDS: Map<string, {
            price: string;
            product: string;
        }>;
        PYTH_MAPPING_ACC: PublicKey;
        VAULT_OWNER: PublicKey;
    };
    bindings: {
        createNameRegistry: typeof createNameRegistry;
        updateNameRegistryData: typeof updateNameRegistryData;
        transferNameOwnership: typeof transferNameOwnership;
        deleteNameRegistry: typeof deleteNameRegistry;
        registerDomainName: (connection: Connection, name: string, space: number, buyer: PublicKey, buyerTokenAccount: PublicKey, mint?: PublicKey, referrerKey?: PublicKey) => Promise<TransactionInstruction[][]>;
        createReverseName: (nameAccount: PublicKey, name: string, feePayer: PublicKey, parentName?: PublicKey, parentNameOwner?: PublicKey) => Promise<TransactionInstruction[][]>;
        createSubdomain: (connection: Connection, subdomain: string, owner: PublicKey, space?: number) => Promise<TransactionInstruction[][]>;
        burnDomain: (domain: string, owner: PublicKey, target: PublicKey) => TransactionInstruction;
        transferSubdomain: (connection: Connection, subdomain: string, newOwner: PublicKey, isParentOwnerSigner?: boolean, owner?: PublicKey) => Promise<TransactionInstruction>;
        registerDomainNameV2: (connection: Connection, name: string, space: number, buyer: PublicKey, buyerTokenAccount: PublicKey, mint?: PublicKey, referrerKey?: PublicKey) => Promise<TransactionInstruction[]>;
    };
};
export {};
