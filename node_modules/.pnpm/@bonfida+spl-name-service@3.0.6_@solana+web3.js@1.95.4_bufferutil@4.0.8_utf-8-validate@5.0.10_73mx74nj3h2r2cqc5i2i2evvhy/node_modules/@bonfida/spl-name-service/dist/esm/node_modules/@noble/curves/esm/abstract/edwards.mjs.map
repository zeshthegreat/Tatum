{"version":3,"file":"edwards.mjs","sources":["../../../../../../../node_modules/@noble/curves/esm/abstract/edwards.js"],"sourcesContent":["/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Twisted Edwards curve. The formula is: ax² + y² = 1 + dx²y²\nimport { mod } from './modular.js';\nimport * as ut from './utils.js';\nimport { ensureBytes } from './utils.js';\nimport { wNAF, validateBasic } from './curve.js';\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _8n = BigInt(8);\n// verification rule is either zip215 or rfc8032 / nist186-5. Consult fromHex:\nconst VERIFY_DEFAULT = { zip215: true };\nfunction validateOpts(curve) {\n    const opts = validateBasic(curve);\n    ut.validateObject(curve, {\n        hash: 'function',\n        a: 'bigint',\n        d: 'bigint',\n        randomBytes: 'function',\n    }, {\n        adjustScalarBytes: 'function',\n        domain: 'function',\n        uvRatio: 'function',\n        mapToCurve: 'function',\n    });\n    // Set defaults\n    return Object.freeze({ ...opts });\n}\n// It is not generic twisted curve for now, but ed25519/ed448 generic implementation\nexport function twistedEdwards(curveDef) {\n    const CURVE = validateOpts(curveDef);\n    const { Fp, n: CURVE_ORDER, prehash: prehash, hash: cHash, randomBytes, nByteLength, h: cofactor, } = CURVE;\n    const MASK = _2n << (BigInt(nByteLength * 8) - _1n);\n    const modP = Fp.create; // Function overrides\n    // sqrt(u/v)\n    const uvRatio = CURVE.uvRatio ||\n        ((u, v) => {\n            try {\n                return { isValid: true, value: Fp.sqrt(u * Fp.inv(v)) };\n            }\n            catch (e) {\n                return { isValid: false, value: _0n };\n            }\n        });\n    const adjustScalarBytes = CURVE.adjustScalarBytes || ((bytes) => bytes); // NOOP\n    const domain = CURVE.domain ||\n        ((data, ctx, phflag) => {\n            if (ctx.length || phflag)\n                throw new Error('Contexts/pre-hash are not supported');\n            return data;\n        }); // NOOP\n    const inBig = (n) => typeof n === 'bigint' && _0n < n; // n in [1..]\n    const inRange = (n, max) => inBig(n) && inBig(max) && n < max; // n in [1..max-1]\n    const in0MaskRange = (n) => n === _0n || inRange(n, MASK); // n in [0..MASK-1]\n    function assertInRange(n, max) {\n        // n in [1..max-1]\n        if (inRange(n, max))\n            return n;\n        throw new Error(`Expected valid scalar < ${max}, got ${typeof n} ${n}`);\n    }\n    function assertGE0(n) {\n        // n in [0..CURVE_ORDER-1]\n        return n === _0n ? n : assertInRange(n, CURVE_ORDER); // GE = prime subgroup, not full group\n    }\n    const pointPrecomputes = new Map();\n    function isPoint(other) {\n        if (!(other instanceof Point))\n            throw new Error('ExtendedPoint expected');\n    }\n    // Extended Point works in extended coordinates: (x, y, z, t) ∋ (x=x/z, y=y/z, t=xy).\n    // https://en.wikipedia.org/wiki/Twisted_Edwards_curve#Extended_coordinates\n    class Point {\n        constructor(ex, ey, ez, et) {\n            this.ex = ex;\n            this.ey = ey;\n            this.ez = ez;\n            this.et = et;\n            if (!in0MaskRange(ex))\n                throw new Error('x required');\n            if (!in0MaskRange(ey))\n                throw new Error('y required');\n            if (!in0MaskRange(ez))\n                throw new Error('z required');\n            if (!in0MaskRange(et))\n                throw new Error('t required');\n        }\n        get x() {\n            return this.toAffine().x;\n        }\n        get y() {\n            return this.toAffine().y;\n        }\n        static fromAffine(p) {\n            if (p instanceof Point)\n                throw new Error('extended point not allowed');\n            const { x, y } = p || {};\n            if (!in0MaskRange(x) || !in0MaskRange(y))\n                throw new Error('invalid affine point');\n            return new Point(x, y, _1n, modP(x * y));\n        }\n        static normalizeZ(points) {\n            const toInv = Fp.invertBatch(points.map((p) => p.ez));\n            return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n        }\n        // \"Private method\", don't use it directly\n        _setWindowSize(windowSize) {\n            this._WINDOW_SIZE = windowSize;\n            pointPrecomputes.delete(this);\n        }\n        // Not required for fromHex(), which always creates valid points.\n        // Could be useful for fromAffine().\n        assertValidity() {\n            const { a, d } = CURVE;\n            if (this.is0())\n                throw new Error('bad point: ZERO'); // TODO: optimize, with vars below?\n            // Equation in affine coordinates: ax² + y² = 1 + dx²y²\n            // Equation in projective coordinates (X/Z, Y/Z, Z):  (aX² + Y²)Z² = Z⁴ + dX²Y²\n            const { ex: X, ey: Y, ez: Z, et: T } = this;\n            const X2 = modP(X * X); // X²\n            const Y2 = modP(Y * Y); // Y²\n            const Z2 = modP(Z * Z); // Z²\n            const Z4 = modP(Z2 * Z2); // Z⁴\n            const aX2 = modP(X2 * a); // aX²\n            const left = modP(Z2 * modP(aX2 + Y2)); // (aX² + Y²)Z²\n            const right = modP(Z4 + modP(d * modP(X2 * Y2))); // Z⁴ + dX²Y²\n            if (left !== right)\n                throw new Error('bad point: equation left != right (1)');\n            // In Extended coordinates we also have T, which is x*y=T/Z: check X*Y == Z*T\n            const XY = modP(X * Y);\n            const ZT = modP(Z * T);\n            if (XY !== ZT)\n                throw new Error('bad point: equation left != right (2)');\n        }\n        // Compare one point to another.\n        equals(other) {\n            isPoint(other);\n            const { ex: X1, ey: Y1, ez: Z1 } = this;\n            const { ex: X2, ey: Y2, ez: Z2 } = other;\n            const X1Z2 = modP(X1 * Z2);\n            const X2Z1 = modP(X2 * Z1);\n            const Y1Z2 = modP(Y1 * Z2);\n            const Y2Z1 = modP(Y2 * Z1);\n            return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;\n        }\n        is0() {\n            return this.equals(Point.ZERO);\n        }\n        negate() {\n            // Flips point sign to a negative one (-x, y in affine coords)\n            return new Point(modP(-this.ex), this.ey, this.ez, modP(-this.et));\n        }\n        // Fast algo for doubling Extended Point.\n        // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd\n        // Cost: 4M + 4S + 1*a + 6add + 1*2.\n        double() {\n            const { a } = CURVE;\n            const { ex: X1, ey: Y1, ez: Z1 } = this;\n            const A = modP(X1 * X1); // A = X12\n            const B = modP(Y1 * Y1); // B = Y12\n            const C = modP(_2n * modP(Z1 * Z1)); // C = 2*Z12\n            const D = modP(a * A); // D = a*A\n            const x1y1 = X1 + Y1;\n            const E = modP(modP(x1y1 * x1y1) - A - B); // E = (X1+Y1)2-A-B\n            const G = D + B; // G = D+B\n            const F = G - C; // F = G-C\n            const H = D - B; // H = D-B\n            const X3 = modP(E * F); // X3 = E*F\n            const Y3 = modP(G * H); // Y3 = G*H\n            const T3 = modP(E * H); // T3 = E*H\n            const Z3 = modP(F * G); // Z3 = F*G\n            return new Point(X3, Y3, Z3, T3);\n        }\n        // Fast algo for adding 2 Extended Points.\n        // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd\n        // Cost: 9M + 1*a + 1*d + 7add.\n        add(other) {\n            isPoint(other);\n            const { a, d } = CURVE;\n            const { ex: X1, ey: Y1, ez: Z1, et: T1 } = this;\n            const { ex: X2, ey: Y2, ez: Z2, et: T2 } = other;\n            // Faster algo for adding 2 Extended Points when curve's a=-1.\n            // http://hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html#addition-add-2008-hwcd-4\n            // Cost: 8M + 8add + 2*2.\n            // Note: It does not check whether the `other` point is valid.\n            if (a === BigInt(-1)) {\n                const A = modP((Y1 - X1) * (Y2 + X2));\n                const B = modP((Y1 + X1) * (Y2 - X2));\n                const F = modP(B - A);\n                if (F === _0n)\n                    return this.double(); // Same point. Tests say it doesn't affect timing\n                const C = modP(Z1 * _2n * T2);\n                const D = modP(T1 * _2n * Z2);\n                const E = D + C;\n                const G = B + A;\n                const H = D - C;\n                const X3 = modP(E * F);\n                const Y3 = modP(G * H);\n                const T3 = modP(E * H);\n                const Z3 = modP(F * G);\n                return new Point(X3, Y3, Z3, T3);\n            }\n            const A = modP(X1 * X2); // A = X1*X2\n            const B = modP(Y1 * Y2); // B = Y1*Y2\n            const C = modP(T1 * d * T2); // C = T1*d*T2\n            const D = modP(Z1 * Z2); // D = Z1*Z2\n            const E = modP((X1 + Y1) * (X2 + Y2) - A - B); // E = (X1+Y1)*(X2+Y2)-A-B\n            const F = D - C; // F = D-C\n            const G = D + C; // G = D+C\n            const H = modP(B - a * A); // H = B-a*A\n            const X3 = modP(E * F); // X3 = E*F\n            const Y3 = modP(G * H); // Y3 = G*H\n            const T3 = modP(E * H); // T3 = E*H\n            const Z3 = modP(F * G); // Z3 = F*G\n            return new Point(X3, Y3, Z3, T3);\n        }\n        subtract(other) {\n            return this.add(other.negate());\n        }\n        wNAF(n) {\n            return wnaf.wNAFCached(this, pointPrecomputes, n, Point.normalizeZ);\n        }\n        // Constant-time multiplication.\n        multiply(scalar) {\n            const { p, f } = this.wNAF(assertInRange(scalar, CURVE_ORDER));\n            return Point.normalizeZ([p, f])[0];\n        }\n        // Non-constant-time multiplication. Uses double-and-add algorithm.\n        // It's faster, but should only be used when you don't care about\n        // an exposed private key e.g. sig verification.\n        // Does NOT allow scalars higher than CURVE.n.\n        multiplyUnsafe(scalar) {\n            let n = assertGE0(scalar); // 0 <= scalar < CURVE.n\n            if (n === _0n)\n                return I;\n            if (this.equals(I) || n === _1n)\n                return this;\n            if (this.equals(G))\n                return this.wNAF(n).p;\n            return wnaf.unsafeLadder(this, n);\n        }\n        // Checks if point is of small order.\n        // If you add something to small order point, you will have \"dirty\"\n        // point with torsion component.\n        // Multiplies point by cofactor and checks if the result is 0.\n        isSmallOrder() {\n            return this.multiplyUnsafe(cofactor).is0();\n        }\n        // Multiplies point by curve order and checks if the result is 0.\n        // Returns `false` is the point is dirty.\n        isTorsionFree() {\n            return wnaf.unsafeLadder(this, CURVE_ORDER).is0();\n        }\n        // Converts Extended point to default (x, y) coordinates.\n        // Can accept precomputed Z^-1 - for example, from invertBatch.\n        toAffine(iz) {\n            const { ex: x, ey: y, ez: z } = this;\n            const is0 = this.is0();\n            if (iz == null)\n                iz = is0 ? _8n : Fp.inv(z); // 8 was chosen arbitrarily\n            const ax = modP(x * iz);\n            const ay = modP(y * iz);\n            const zz = modP(z * iz);\n            if (is0)\n                return { x: _0n, y: _1n };\n            if (zz !== _1n)\n                throw new Error('invZ was invalid');\n            return { x: ax, y: ay };\n        }\n        clearCofactor() {\n            const { h: cofactor } = CURVE;\n            if (cofactor === _1n)\n                return this;\n            return this.multiplyUnsafe(cofactor);\n        }\n        // Converts hash string or Uint8Array to Point.\n        // Uses algo from RFC8032 5.1.3.\n        static fromHex(hex, zip215 = false) {\n            const { d, a } = CURVE;\n            const len = Fp.BYTES;\n            hex = ensureBytes('pointHex', hex, len); // copy hex to a new array\n            const normed = hex.slice(); // copy again, we'll manipulate it\n            const lastByte = hex[len - 1]; // select last byte\n            normed[len - 1] = lastByte & ~0x80; // clear last bit\n            const y = ut.bytesToNumberLE(normed);\n            if (y === _0n) {\n                // y=0 is allowed\n            }\n            else {\n                // RFC8032 prohibits >= p, but ZIP215 doesn't\n                if (zip215)\n                    assertInRange(y, MASK); // zip215=true [1..P-1] (2^255-19-1 for ed25519)\n                else\n                    assertInRange(y, Fp.ORDER); // zip215=false [1..MASK-1] (2^256-1 for ed25519)\n            }\n            // Ed25519: x² = (y²-1)/(dy²+1) mod p. Ed448: x² = (y²-1)/(dy²-1) mod p. Generic case:\n            // ax²+y²=1+dx²y² => y²-1=dx²y²-ax² => y²-1=x²(dy²-a) => x²=(y²-1)/(dy²-a)\n            const y2 = modP(y * y); // denominator is always non-0 mod p.\n            const u = modP(y2 - _1n); // u = y² - 1\n            const v = modP(d * y2 - a); // v = d y² + 1.\n            let { isValid, value: x } = uvRatio(u, v); // √(u/v)\n            if (!isValid)\n                throw new Error('Point.fromHex: invalid y coordinate');\n            const isXOdd = (x & _1n) === _1n; // There are 2 square roots. Use x_0 bit to select proper\n            const isLastByteOdd = (lastByte & 0x80) !== 0; // x_0, last bit\n            if (!zip215 && x === _0n && isLastByteOdd)\n                // if x=0 and x_0 = 1, fail\n                throw new Error('Point.fromHex: x=0 and x_0=1');\n            if (isLastByteOdd !== isXOdd)\n                x = modP(-x); // if x_0 != x mod 2, set x = p-x\n            return Point.fromAffine({ x, y });\n        }\n        static fromPrivateKey(privKey) {\n            return getExtendedPublicKey(privKey).point;\n        }\n        toRawBytes() {\n            const { x, y } = this.toAffine();\n            const bytes = ut.numberToBytesLE(y, Fp.BYTES); // each y has 2 x values (x, -y)\n            bytes[bytes.length - 1] |= x & _1n ? 0x80 : 0; // when compressing, it's enough to store y\n            return bytes; // and use the last byte to encode sign of x\n        }\n        toHex() {\n            return ut.bytesToHex(this.toRawBytes()); // Same as toRawBytes, but returns string.\n        }\n    }\n    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, _1n, modP(CURVE.Gx * CURVE.Gy));\n    Point.ZERO = new Point(_0n, _1n, _1n, _0n); // 0, 1, 1, 0\n    const { BASE: G, ZERO: I } = Point;\n    const wnaf = wNAF(Point, nByteLength * 8);\n    function modN(a) {\n        return mod(a, CURVE_ORDER);\n    }\n    // Little-endian SHA512 with modulo n\n    function modN_LE(hash) {\n        return modN(ut.bytesToNumberLE(hash));\n    }\n    /** Convenience method that creates public key and other stuff. RFC8032 5.1.5 */\n    function getExtendedPublicKey(key) {\n        const len = nByteLength;\n        key = ensureBytes('private key', key, len);\n        // Hash private key with curve's hash function to produce uniformingly random input\n        // Check byte lengths: ensure(64, h(ensure(32, key)))\n        const hashed = ensureBytes('hashed private key', cHash(key), 2 * len);\n        const head = adjustScalarBytes(hashed.slice(0, len)); // clear first half bits, produce FE\n        const prefix = hashed.slice(len, 2 * len); // second half is called key prefix (5.1.6)\n        const scalar = modN_LE(head); // The actual private scalar\n        const point = G.multiply(scalar); // Point on Edwards curve aka public key\n        const pointBytes = point.toRawBytes(); // Uint8Array representation\n        return { head, prefix, scalar, point, pointBytes };\n    }\n    // Calculates EdDSA pub key. RFC8032 5.1.5. Privkey is hashed. Use first half with 3 bits cleared\n    function getPublicKey(privKey) {\n        return getExtendedPublicKey(privKey).pointBytes;\n    }\n    // int('LE', SHA512(dom2(F, C) || msgs)) mod N\n    function hashDomainToScalar(context = new Uint8Array(), ...msgs) {\n        const msg = ut.concatBytes(...msgs);\n        return modN_LE(cHash(domain(msg, ensureBytes('context', context), !!prehash)));\n    }\n    /** Signs message with privateKey. RFC8032 5.1.6 */\n    function sign(msg, privKey, options = {}) {\n        msg = ensureBytes('message', msg);\n        if (prehash)\n            msg = prehash(msg); // for ed25519ph etc.\n        const { prefix, scalar, pointBytes } = getExtendedPublicKey(privKey);\n        const r = hashDomainToScalar(options.context, prefix, msg); // r = dom2(F, C) || prefix || PH(M)\n        const R = G.multiply(r).toRawBytes(); // R = rG\n        const k = hashDomainToScalar(options.context, R, pointBytes, msg); // R || A || PH(M)\n        const s = modN(r + k * scalar); // S = (r + k * s) mod L\n        assertGE0(s); // 0 <= s < l\n        const res = ut.concatBytes(R, ut.numberToBytesLE(s, Fp.BYTES));\n        return ensureBytes('result', res, nByteLength * 2); // 64-byte signature\n    }\n    const verifyOpts = VERIFY_DEFAULT;\n    function verify(sig, msg, publicKey, options = verifyOpts) {\n        const { context, zip215 } = options;\n        const len = Fp.BYTES; // Verifies EdDSA signature against message and public key. RFC8032 5.1.7.\n        sig = ensureBytes('signature', sig, 2 * len); // An extended group equation is checked.\n        msg = ensureBytes('message', msg);\n        if (prehash)\n            msg = prehash(msg); // for ed25519ph, etc\n        const s = ut.bytesToNumberLE(sig.slice(len, 2 * len));\n        // zip215: true is good for consensus-critical apps and allows points < 2^256\n        // zip215: false follows RFC8032 / NIST186-5 and restricts points to CURVE.p\n        let A, R, SB;\n        try {\n            A = Point.fromHex(publicKey, zip215);\n            R = Point.fromHex(sig.slice(0, len), zip215);\n            SB = G.multiplyUnsafe(s); // 0 <= s < l is done inside\n        }\n        catch (error) {\n            return false;\n        }\n        if (!zip215 && A.isSmallOrder())\n            return false;\n        const k = hashDomainToScalar(context, R.toRawBytes(), A.toRawBytes(), msg);\n        const RkA = R.add(A.multiplyUnsafe(k));\n        // [8][S]B = [8]R + [8][k]A'\n        return RkA.subtract(SB).clearCofactor().equals(Point.ZERO);\n    }\n    G._setWindowSize(8); // Enable precomputes. Slows down first publicKey computation by 20ms.\n    const utils = {\n        getExtendedPublicKey,\n        // ed25519 private keys are uniform 32b. No need to check for modulo bias, like in secp256k1.\n        randomPrivateKey: () => randomBytes(Fp.BYTES),\n        /**\n         * We're doing scalar multiplication (used in getPublicKey etc) with precomputed BASE_POINT\n         * values. This slows down first getPublicKey() by milliseconds (see Speed section),\n         * but allows to speed-up subsequent getPublicKey() calls up to 20x.\n         * @param windowSize 2, 4, 8, 16\n         */\n        precompute(windowSize = 8, point = Point.BASE) {\n            point._setWindowSize(windowSize);\n            point.multiply(BigInt(3));\n            return point;\n        },\n    };\n    return {\n        CURVE,\n        getPublicKey,\n        sign,\n        verify,\n        ExtendedPoint: Point,\n        utils,\n    };\n}\n//# sourceMappingURL=edwards.js.map"],"names":["_0n","BigInt","_1n","_2n","_8n","VERIFY_DEFAULT","zip215","twistedEdwards","curveDef","CURVE","curve","opts","validateBasic","ut","hash","a","d","randomBytes","adjustScalarBytes","domain","uvRatio","mapToCurve","Object","freeze","validateOpts","Fp","n","CURVE_ORDER","prehash","cHash","nByteLength","h","cofactor","MASK","modP","create","u","v","isValid","value","sqrt","inv","e","bytes","data","ctx","phflag","length","Error","inBig","inRange","max","in0MaskRange","assertInRange","assertGE0","pointPrecomputes","Map","isPoint","other","Point","constructor","ex","ey","ez","et","this","x","toAffine","y","fromAffine","p","normalizeZ","points","toInv","invertBatch","map","i","_setWindowSize","windowSize","_WINDOW_SIZE","delete","assertValidity","is0","X","Y","Z","T","X2","Y2","Z2","Z4","aX2","equals","X1","Y1","Z1","X1Z2","X2Z1","Y1Z2","Y2Z1","ZERO","negate","double","A","B","C","D","x1y1","E","G","F","H","X3","Y3","T3","Z3","add","T1","T2","subtract","wNAF","wnaf","wNAFCached","multiply","scalar","f","multiplyUnsafe","I","unsafeLadder","isSmallOrder","isTorsionFree","iz","z","ax","ay","zz","clearCofactor","fromHex","hex","len","BYTES","normed","ensureBytes","slice","lastByte","ORDER","y2","isXOdd","isLastByteOdd","fromPrivateKey","privKey","getExtendedPublicKey","point","toRawBytes","toHex","BASE","Gx","Gy","modN","mod","modN_LE","key","hashed","head","prefix","pointBytes","hashDomainToScalar","context","Uint8Array","msgs","msg","verifyOpts","getPublicKey","sign","options","r","R","s","res","verify","sig","publicKey","SB","error","k","ExtendedPoint","utils","randomPrivateKey","precompute"],"mappings":"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","x_google_ignoreList":[0]}