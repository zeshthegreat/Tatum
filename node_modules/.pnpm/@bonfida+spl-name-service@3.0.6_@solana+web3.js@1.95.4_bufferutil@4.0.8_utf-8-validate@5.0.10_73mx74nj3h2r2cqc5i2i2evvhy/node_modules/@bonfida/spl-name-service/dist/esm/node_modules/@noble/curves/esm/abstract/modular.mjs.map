{"version":3,"file":"modular.mjs","sources":["../../../../../../../node_modules/@noble/curves/esm/abstract/modular.js"],"sourcesContent":["/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Utilities for modular arithmetics and finite fields\nimport { bitMask, numberToBytesBE, numberToBytesLE, bytesToNumberBE, bytesToNumberLE, ensureBytes, validateObject, } from './utils.js';\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\n// prettier-ignore\nconst _4n = BigInt(4), _5n = BigInt(5), _8n = BigInt(8);\n// prettier-ignore\nconst _9n = BigInt(9), _16n = BigInt(16);\n// Calculates a modulo b\nexport function mod(a, b) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */\n// TODO: use field version && remove\nexport function pow(num, power, modulo) {\n    if (modulo <= _0n || power < _0n)\n        throw new Error('Expected power/modulo > 0');\n    if (modulo === _1n)\n        return _0n;\n    let res = _1n;\n    while (power > _0n) {\n        if (power & _1n)\n            res = (res * num) % modulo;\n        num = (num * num) % modulo;\n        power >>= _1n;\n    }\n    return res;\n}\n// Does x ^ (2 ^ power) mod p. pow2(30, 4) == 30 ^ (2 ^ 4)\nexport function pow2(x, power, modulo) {\n    let res = x;\n    while (power-- > _0n) {\n        res *= res;\n        res %= modulo;\n    }\n    return res;\n}\n// Inverses number over modulo\nexport function invert(number, modulo) {\n    if (number === _0n || modulo <= _0n) {\n        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n    }\n    // Euclidean GCD https://brilliant.org/wiki/extended-euclidean-algorithm/\n    // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n    let a = mod(number, modulo);\n    let b = modulo;\n    // prettier-ignore\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while (a !== _0n) {\n        // JIT applies optimization if those two lines follow each other\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        // prettier-ignore\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n)\n        throw new Error('invert: does not exist');\n    return mod(x, modulo);\n}\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * Will start an infinite loop if field order P is not prime.\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */\nexport function tonelliShanks(P) {\n    // Legendre constant: used to calculate Legendre symbol (a | p),\n    // which denotes the value of a^((p-1)/2) (mod p).\n    // (a | p) ≡ 1    if a is a square (mod p)\n    // (a | p) ≡ -1   if a is not a square (mod p)\n    // (a | p) ≡ 0    if a ≡ 0 (mod p)\n    const legendreC = (P - _1n) / _2n;\n    let Q, S, Z;\n    // Step 1: By factoring out powers of 2 from p - 1,\n    // find q and s such that p - 1 = q*(2^s) with q odd\n    for (Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++)\n        ;\n    // Step 2: Select a non-square z such that (z | p) ≡ -1 and set c ≡ zq\n    for (Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++)\n        ;\n    // Fast-path\n    if (S === 1) {\n        const p1div4 = (P + _1n) / _4n;\n        return function tonelliFast(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // Slow-path\n    const Q1div2 = (Q + _1n) / _2n;\n    return function tonelliSlow(Fp, n) {\n        // Step 0: Check that n is indeed a square: (n | p) should not be ≡ -1\n        if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE))\n            throw new Error('Cannot find square root');\n        let r = S;\n        // TODO: will fail at Fp2/etc\n        let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b\n        let x = Fp.pow(n, Q1div2); // first guess at the square root\n        let b = Fp.pow(n, Q); // first guess at the fudge factor\n        while (!Fp.eql(b, Fp.ONE)) {\n            if (Fp.eql(b, Fp.ZERO))\n                return Fp.ZERO; // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm (4. If t = 0, return r = 0)\n            // Find m such b^(2^m)==1\n            let m = 1;\n            for (let t2 = Fp.sqr(b); m < r; m++) {\n                if (Fp.eql(t2, Fp.ONE))\n                    break;\n                t2 = Fp.sqr(t2); // t2 *= t2\n            }\n            // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift, otherwise there will be overflow\n            const ge = Fp.pow(g, _1n << BigInt(r - m - 1)); // ge = 2^(r-m-1)\n            g = Fp.sqr(ge); // g = ge * ge\n            x = Fp.mul(x, ge); // x *= ge\n            b = Fp.mul(b, g); // b *= g\n            r = m;\n        }\n        return x;\n    };\n}\nexport function FpSqrt(P) {\n    // NOTE: different algorithms can give different roots, it is up to user to decide which one they want.\n    // For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n    // P ≡ 3 (mod 4)\n    // √n = n^((P+1)/4)\n    if (P % _4n === _3n) {\n        // Not all roots possible!\n        // const ORDER =\n        //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;\n        // const NUM = 72057594037927816n;\n        const p1div4 = (P + _1n) / _4n;\n        return function sqrt3mod4(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            // Throw if root**2 != n\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // Atkin algorithm for q ≡ 5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)\n    if (P % _8n === _5n) {\n        const c1 = (P - _5n) / _8n;\n        return function sqrt5mod8(Fp, n) {\n            const n2 = Fp.mul(n, _2n);\n            const v = Fp.pow(n2, c1);\n            const nv = Fp.mul(n, v);\n            const i = Fp.mul(Fp.mul(nv, _2n), v);\n            const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // P ≡ 9 (mod 16)\n    if (P % _16n === _9n) {\n        // NOTE: tonelli is too slow for bls-Fp2 calculations even on start\n        // Means we cannot use sqrt for constants at all!\n        //\n        // const c1 = Fp.sqrt(Fp.negate(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n        // const c2 = Fp.sqrt(c1);                //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n        // const c3 = Fp.sqrt(Fp.negate(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n        // const c4 = (P + _7n) / _16n;           //  4. c4 = (q + 7) / 16        # Integer arithmetic\n        // sqrt = (x) => {\n        //   let tv1 = Fp.pow(x, c4);             //  1. tv1 = x^c4\n        //   let tv2 = Fp.mul(c1, tv1);           //  2. tv2 = c1 * tv1\n        //   const tv3 = Fp.mul(c2, tv1);         //  3. tv3 = c2 * tv1\n        //   let tv4 = Fp.mul(c3, tv1);           //  4. tv4 = c3 * tv1\n        //   const e1 = Fp.equals(Fp.square(tv2), x); //  5.  e1 = (tv2^2) == x\n        //   const e2 = Fp.equals(Fp.square(tv3), x); //  6.  e2 = (tv3^2) == x\n        //   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n        //   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n        //   const e3 = Fp.equals(Fp.square(tv2), x); //  9.  e3 = (tv2^2) == x\n        //   return Fp.cmov(tv1, tv2, e3); //  10.  z = CMOV(tv1, tv2, e3)  # Select the sqrt from tv1 and tv2\n        // }\n    }\n    // Other cases: Tonelli-Shanks algorithm\n    return tonelliShanks(P);\n}\n// Little-endian check for first LE bit (last BE bit);\nexport const isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;\n// prettier-ignore\nconst FIELD_FIELDS = [\n    'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',\n    'eql', 'add', 'sub', 'mul', 'pow', 'div',\n    'addN', 'subN', 'mulN', 'sqrN'\n];\nexport function validateField(field) {\n    const initial = {\n        ORDER: 'bigint',\n        MASK: 'bigint',\n        BYTES: 'isSafeInteger',\n        BITS: 'isSafeInteger',\n    };\n    const opts = FIELD_FIELDS.reduce((map, val) => {\n        map[val] = 'function';\n        return map;\n    }, initial);\n    return validateObject(field, opts);\n}\n// Generic field functions\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */\nexport function FpPow(f, num, power) {\n    // Should have same speed as pow for bigints\n    // TODO: benchmark!\n    if (power < _0n)\n        throw new Error('Expected power > 0');\n    if (power === _0n)\n        return f.ONE;\n    if (power === _1n)\n        return num;\n    let p = f.ONE;\n    let d = num;\n    while (power > _0n) {\n        if (power & _1n)\n            p = f.mul(p, d);\n        d = f.sqr(d);\n        power >>= _1n;\n    }\n    return p;\n}\n/**\n * Efficiently invert an array of Field elements.\n * `inv(0)` will return `undefined` here: make sure to throw an error.\n */\nexport function FpInvertBatch(f, nums) {\n    const tmp = new Array(nums.length);\n    // Walk from first to last, multiply them by each other MOD p\n    const lastMultiplied = nums.reduce((acc, num, i) => {\n        if (f.is0(num))\n            return acc;\n        tmp[i] = acc;\n        return f.mul(acc, num);\n    }, f.ONE);\n    // Invert last element\n    const inverted = f.inv(lastMultiplied);\n    // Walk from last to first, multiply them by inverted each other MOD p\n    nums.reduceRight((acc, num, i) => {\n        if (f.is0(num))\n            return acc;\n        tmp[i] = f.mul(acc, tmp[i]);\n        return f.mul(acc, num);\n    }, inverted);\n    return tmp;\n}\nexport function FpDiv(f, lhs, rhs) {\n    return f.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, f.ORDER) : f.inv(rhs));\n}\n// This function returns True whenever the value x is a square in the field F.\nexport function FpIsSquare(f) {\n    const legendreConst = (f.ORDER - _1n) / _2n; // Integer arithmetic\n    return (x) => {\n        const p = f.pow(x, legendreConst);\n        return f.eql(p, f.ZERO) || f.eql(p, f.ONE);\n    };\n}\n// CURVE.n lengths\nexport function nLength(n, nBitLength) {\n    // Bit size, byte size of CURVE.n\n    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n    const nByteLength = Math.ceil(_nBitLength / 8);\n    return { nBitLength: _nBitLength, nByteLength };\n}\n/**\n * Initializes a finite field over prime. **Non-primes are not supported.**\n * Do not init in loop: slow. Very fragile: always run a benchmark on a change.\n * Major performance optimizations:\n * * a) denormalized operations like mulN instead of mul\n * * b) same object shape: never add or remove keys\n * * c) Object.freeze\n * @param ORDER prime positive bigint\n * @param bitLen how many bits the field consumes\n * @param isLE (def: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */\nexport function Field(ORDER, bitLen, isLE = false, redef = {}) {\n    if (ORDER <= _0n)\n        throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);\n    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);\n    if (BYTES > 2048)\n        throw new Error('Field lengths over 2048 bytes are not supported');\n    const sqrtP = FpSqrt(ORDER);\n    const f = Object.freeze({\n        ORDER,\n        BITS,\n        BYTES,\n        MASK: bitMask(BITS),\n        ZERO: _0n,\n        ONE: _1n,\n        create: (num) => mod(num, ORDER),\n        isValid: (num) => {\n            if (typeof num !== 'bigint')\n                throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);\n            return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n        },\n        is0: (num) => num === _0n,\n        isOdd: (num) => (num & _1n) === _1n,\n        neg: (num) => mod(-num, ORDER),\n        eql: (lhs, rhs) => lhs === rhs,\n        sqr: (num) => mod(num * num, ORDER),\n        add: (lhs, rhs) => mod(lhs + rhs, ORDER),\n        sub: (lhs, rhs) => mod(lhs - rhs, ORDER),\n        mul: (lhs, rhs) => mod(lhs * rhs, ORDER),\n        pow: (num, power) => FpPow(f, num, power),\n        div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),\n        // Same as above, but doesn't normalize\n        sqrN: (num) => num * num,\n        addN: (lhs, rhs) => lhs + rhs,\n        subN: (lhs, rhs) => lhs - rhs,\n        mulN: (lhs, rhs) => lhs * rhs,\n        inv: (num) => invert(num, ORDER),\n        sqrt: redef.sqrt || ((n) => sqrtP(f, n)),\n        invertBatch: (lst) => FpInvertBatch(f, lst),\n        // TODO: do we really need constant cmov?\n        // We don't have const-time bigints anyway, so probably will be not very useful\n        cmov: (a, b, c) => (c ? b : a),\n        toBytes: (num) => (isLE ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES)),\n        fromBytes: (bytes) => {\n            if (bytes.length !== BYTES)\n                throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);\n            return isLE ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);\n        },\n    });\n    return Object.freeze(f);\n}\nexport function FpSqrtOdd(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(`Field doesn't have isOdd`);\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? root : Fp.neg(root);\n}\nexport function FpSqrtEven(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(`Field doesn't have isOdd`);\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).\n * Which makes it slightly more biased, less secure.\n * @deprecated use mapKeyToField instead\n */\nexport function hashToPrivateScalar(hash, groupOrder, isLE = false) {\n    hash = ensureBytes('privateHash', hash);\n    const hashLen = hash.length;\n    const minLen = nLength(groupOrder).nByteLength + 8;\n    if (minLen < 24 || hashLen < minLen || hashLen > 1024)\n        throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);\n    const num = isLE ? bytesToNumberLE(hash) : bytesToNumberBE(hash);\n    return mod(num, groupOrder - _1n) + _1n;\n}\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */\nexport function getFieldBytesLength(fieldOrder) {\n    if (typeof fieldOrder !== 'bigint')\n        throw new Error('field order must be bigint');\n    const bitLength = fieldOrder.toString(2).length;\n    return Math.ceil(bitLength / 8);\n}\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */\nexport function getMinHashLength(fieldOrder) {\n    const length = getFieldBytesLength(fieldOrder);\n    return length + Math.ceil(length / 2);\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */\nexport function mapHashToField(key, fieldOrder, isLE = false) {\n    const len = key.length;\n    const fieldLen = getFieldBytesLength(fieldOrder);\n    const minLen = getMinHashLength(fieldOrder);\n    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n    if (len < 16 || len < minLen || len > 1024)\n        throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);\n    const num = isLE ? bytesToNumberBE(key) : bytesToNumberLE(key);\n    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n    const reduced = mod(num, fieldOrder - _1n) + _1n;\n    return isLE ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);\n}\n//# sourceMappingURL=modular.js.map"],"names":["_0n","BigInt","_1n","_2n","_3n","_4n","_5n","_8n","mod","a","b","result","pow","num","power","modulo","Error","res","pow2","x","invert","number","u","r","m","tonelliShanks","P","legendreC","Q","S","Z","p1div4","Fp","n","root","eql","sqr","Q1div2","neg","ONE","g","mul","ZERO","t2","ge","FpSqrt","c1","n2","v","nv","i","sub","isNegativeLE","FIELD_FIELDS","validateField","field","opts","reduce","map","val","ORDER","MASK","BYTES","BITS","validateObject","FpPow","f","p","d","FpInvertBatch","nums","tmp","Array","length","lastMultiplied","acc","is0","inverted","inv","reduceRight","nLength","nBitLength","_nBitLength","undefined","toString","nByteLength","Math","ceil","Field","bitLen","isLE","redef","sqrtP","Object","freeze","bitMask","create","isValid","isOdd","lhs","rhs","add","div","sqrN","addN","subN","mulN","sqrt","invertBatch","lst","cmov","c","toBytes","numberToBytesLE","numberToBytesBE","fromBytes","bytes","bytesToNumberLE","bytesToNumberBE","FpSqrtEven","elm"],"mappings":"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","x_google_ignoreList":[0]}