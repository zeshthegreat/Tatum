import{PublicKey as t}from"@solana/web3.js";import{retrieveNftOwnerV2 as e}from"./nft/retrieveNftOwnerV2.mjs";import{deserialize as r}from"./node_modules/borsh/lib/esm/index.mjs";import{AccountDoesNotExistError as a}from"./error.mjs";class s{constructor(e){this.parentName=new t(e.parentName),this.owner=new t(e.owner),this.class=new t(e.class)}static deserialize(t){const e=new s(r(this.schema,t));return e.data=null==t?void 0:t.slice(this.HEADER_LEN),e}static async retrieve(t,n){var i;const o=await t.getAccountInfo(n);if(!o)throw new a("The name account does not exist");const c=new s(r(this.schema,o.data));c.data=null===(i=o.data)||void 0===i?void 0:i.slice(this.HEADER_LEN);return{registry:c,nftOwner:await e(t,n)}}static async _retrieveBatch(t,e){const a=await t.getMultipleAccountsInfo(e),n=t=>{if(!t)return;const e=new s(r(this.schema,t));return e.data=null==t?void 0:t.slice(this.HEADER_LEN),e};return a.map((t=>n(null==t?void 0:t.data)))}static async retrieveBatch(t,e){let r=[];const a=[...e];for(;a.length>0;)r.push(...await this._retrieveBatch(t,a.splice(0,100)));return r}}s.HEADER_LEN=96,s.schema={struct:{parentName:{array:{type:"u8",len:32}},owner:{array:{type:"u8",len:32}},class:{array:{type:"u8",len:32}}}};export{s as NameRegistryState};
//# sourceMappingURL=state.mjs.map
