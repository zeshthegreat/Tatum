{"version":3,"file":"_md.mjs","sources":["../../../../../../node_modules/@noble/hashes/esm/_md.js"],"sourcesContent":["import { exists, output } from './_assert.js';\nimport { Hash, createView, toBytes } from './utils.js';\n// Polyfill for Safari 14\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n// Choice: a ? b : c\nexport const Chi = (a, b, c) => (a & b) ^ (~a & c);\n// Majority function, true if any two inpust is true\nexport const Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */\nexport class HashMD extends Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = createView(this.buffer);\n    }\n    update(data) {\n        exists(this);\n        const { view, buffer, blockLen } = this;\n        data = toBytes(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = createView(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        exists(this);\n        output(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in\n        // current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = createView(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n}\n//# sourceMappingURL=_md.js.map"],"names":["Chi","a","b","c","Maj","HashMD","Hash","constructor","blockLen","outputLen","padOffset","isLE","super","this","finished","length","pos","destroyed","buffer","Uint8Array","view","createView","update","data","exists","len","toBytes","take","Math","min","set","subarray","process","dataView","roundClean","digestInto","out","output","fill","i","byteOffset","value","setBigUint64","_32n","BigInt","_u32_max","wh","Number","wl","h","l","setUint32","oview","Error","outLen","state","get","digest","res","slice","destroy","_cloneInto","to"],"mappings":"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","x_google_ignoreList":[0]}