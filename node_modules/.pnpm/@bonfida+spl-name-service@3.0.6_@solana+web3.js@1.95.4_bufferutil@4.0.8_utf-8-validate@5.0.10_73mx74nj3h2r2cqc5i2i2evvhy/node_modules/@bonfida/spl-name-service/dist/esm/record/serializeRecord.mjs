import"../node_modules/buffer/index.mjs";import{PublicKey as e}from"@solana/web3.js";import{bech32 as r}from"../node_modules/@scure/base/lib/esm/index.mjs";import{encode as o}from"../node_modules/punycode/punycode.es6.mjs";import{i as t}from"../node_modules/ipaddr.js/lib/ipaddr.mjs";import{RECORD_V1_SIZE as s,Record as n}from"../types/record.mjs";import{check as i}from"../utils/check.mjs";import{UnsupportedRecordError as m,InvalidEvmAddressError as f,InvalidInjectiveAddressError as d,InvalidARecordError as u,InvalidAAAARecordError as c,InvalidRecordInputError as a}from"../error.mjs";import{__exports as l}from"../_virtual/index.mjs";const p=(p,h)=>{if(!s.get(h))return h!==n.CNAME&&h!==n.TXT||(p=o(p)),l.Buffer.from(p,"utf-8");if(h===n.SOL)throw new m("Use `serializeSolRecord` for SOL record");if(h===n.ETH||h===n.BSC)return i("0x"===p.slice(0,2),new f("The record content must start with `0x`")),l.Buffer.from(p.slice(2),"hex");if(h===n.Injective){const e=r.decodeToBytes(p);return i("inj"===e.prefix,new d("The record content must start with `inj")),i(20===e.bytes.length,new d("The record data must be 20 bytes long")),l.Buffer.from(e.bytes)}if(h===n.A){const e=t.parse(p).toByteArray();return i(4===e.length,new u("The record content must be 4 bytes long")),l.Buffer.from(e)}if(h===n.AAAA){const e=t.parse(p).toByteArray();return i(16===e.length,new c("The record content must be 16 bytes logn")),l.Buffer.from(e)}if(h===n.Background)return new e(p).toBuffer();throw new a("The provided record data is invalid")};export{p as serializeRecord};
//# sourceMappingURL=serializeRecord.mjs.map
