/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
BigInt(0);const t=BigInt(1),r=BigInt(2);function n(t){return t instanceof Uint8Array||null!=t&&"object"==typeof t&&"Uint8Array"===t.constructor.name}function e(t){if(!n(t))throw new Error("Uint8Array expected")}const o=Array.from({length:256},((t,r)=>r.toString(16).padStart(2,"0")));function i(t){e(t);let r="";for(let n=0;n<t.length;n++)r+=o[t[n]];return r}function f(t){if("string"!=typeof t)throw new Error("hex string expected, got "+typeof t);return BigInt(""===t?"0":`0x${t}`)}const c={_0:48,_9:57,_A:65,_F:70,_a:97,_f:102};function s(t){return t>=c._0&&t<=c._9?t-c._0:t>=c._A&&t<=c._F?t-(c._A-10):t>=c._a&&t<=c._f?t-(c._a-10):void 0}function a(t){if("string"!=typeof t)throw new Error("hex string expected, got "+typeof t);const r=t.length,n=r/2;if(r%2)throw new Error("padded hex string expected, got unpadded hex of length "+r);const e=new Uint8Array(n);for(let r=0,o=0;r<n;r++,o+=2){const n=s(t.charCodeAt(o)),i=s(t.charCodeAt(o+1));if(void 0===n||void 0===i){const r=t[o]+t[o+1];throw new Error('hex string expected, got non-hex character "'+r+'" at index '+o)}e[r]=16*n+i}return e}function g(t){return f(i(t))}function u(t){return e(t),f(i(Uint8Array.from(t).reverse()))}function h(t,r){return a(t.toString(16).padStart(2*r,"0"))}function p(t,r){return h(t,r).reverse()}function y(t,r,e){let o;if("string"==typeof r)try{o=a(r)}catch(n){throw new Error(`${t} must be valid hex string, got "${r}". Cause: ${n}`)}else{if(!n(r))throw new Error(`${t} must be hex string or Uint8Array`);o=Uint8Array.from(r)}const i=o.length;if("number"==typeof e&&i!==e)throw new Error(`${t} expected ${e} bytes, got ${i}`);return o}function d(...t){let r=0;for(let n=0;n<t.length;n++){const o=t[n];e(o),r+=o.length}const n=new Uint8Array(r);for(let r=0,e=0;r<t.length;r++){const o=t[r];n.set(o,e),e+=o.length}return n}const l=n=>(r<<BigInt(n-1))-t,w={bigint:t=>"bigint"==typeof t,function:t=>"function"==typeof t,boolean:t=>"boolean"==typeof t,string:t=>"string"==typeof t,stringOrUint8Array:t=>"string"==typeof t||n(t),isSafeInteger:t=>Number.isSafeInteger(t),array:t=>Array.isArray(t),field:(t,r)=>r.Fp.isValid(t),hash:t=>"function"==typeof t&&Number.isSafeInteger(t.outputLen)};function x(t,r,n={}){const e=(r,n,e)=>{const o=w[n];if("function"!=typeof o)throw new Error(`Invalid validator "${n}", expected function`);const i=t[r];if(!(e&&void 0===i||o(i,t)))throw new Error(`Invalid param ${String(r)}=${i} (${typeof i}), expected ${n}`)};for(const[t,n]of Object.entries(r))e(t,n,!1);for(const[t,r]of Object.entries(n))e(t,r,!0);return t}export{e as abytes,l as bitMask,i as bytesToHex,g as bytesToNumberBE,u as bytesToNumberLE,d as concatBytes,y as ensureBytes,a as hexToBytes,f as hexToNumber,n as isBytes,h as numberToBytesBE,p as numberToBytesLE,x as validateObject};
//# sourceMappingURL=utils.mjs.map
