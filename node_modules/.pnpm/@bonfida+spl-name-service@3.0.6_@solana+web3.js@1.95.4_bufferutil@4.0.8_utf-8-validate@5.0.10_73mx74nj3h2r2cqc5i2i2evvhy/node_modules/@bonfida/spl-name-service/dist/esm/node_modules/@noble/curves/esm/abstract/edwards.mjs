import{mod as t}from"./modular.mjs";import{validateObject as e,ensureBytes as n,bytesToNumberLE as r,numberToBytesLE as i,bytesToHex as o,concatBytes as s}from"./utils.mjs";import{validateBasic as a,wNAF as u}from"./curve.mjs";
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const c=BigInt(0),f=BigInt(1),l=BigInt(2),h=BigInt(8),d={zip215:!0};function y(y){const w=function(t){const n=a(t);return e(t,{hash:"function",a:"bigint",d:"bigint",randomBytes:"function"},{adjustScalarBytes:"function",domain:"function",uvRatio:"function",mapToCurve:"function"}),Object.freeze({...n})}(y),{Fp:p,n:m,prehash:x,hash:E,randomBytes:B,nByteLength:g,h:v}=w,z=l<<BigInt(8*g)-f,A=p.create,R=w.uvRatio||((t,e)=>{try{return{isValid:!0,value:p.sqrt(t*p.inv(e))}}catch(t){return{isValid:!1,value:c}}}),S=w.adjustScalarBytes||(t=>t),b=w.domain||((t,e,n)=>{if(e.length||n)throw new Error("Contexts/pre-hash are not supported");return t}),q=t=>"bigint"==typeof t&&c<t,O=(t,e)=>q(t)&&q(e)&&t<e,Z=t=>t===c||O(t,z);function I(t,e){if(O(t,e))return t;throw new Error(`Expected valid scalar < ${e}, got ${typeof t} ${t}`)}function P(t){return t===c?t:I(t,m)}const H=new Map;function T(t){if(!(t instanceof U))throw new Error("ExtendedPoint expected")}class U{constructor(t,e,n,r){if(this.ex=t,this.ey=e,this.ez=n,this.et=r,!Z(t))throw new Error("x required");if(!Z(e))throw new Error("y required");if(!Z(n))throw new Error("z required");if(!Z(r))throw new Error("t required")}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static fromAffine(t){if(t instanceof U)throw new Error("extended point not allowed");const{x:e,y:n}=t||{};if(!Z(e)||!Z(n))throw new Error("invalid affine point");return new U(e,n,f,A(e*n))}static normalizeZ(t){const e=p.invertBatch(t.map((t=>t.ez)));return t.map(((t,n)=>t.toAffine(e[n]))).map(U.fromAffine)}_setWindowSize(t){this._WINDOW_SIZE=t,H.delete(this)}assertValidity(){const{a:t,d:e}=w;if(this.is0())throw new Error("bad point: ZERO");const{ex:n,ey:r,ez:i,et:o}=this,s=A(n*n),a=A(r*r),u=A(i*i),c=A(u*u),f=A(s*t);if(A(u*A(f+a))!==A(c+A(e*A(s*a))))throw new Error("bad point: equation left != right (1)");if(A(n*r)!==A(i*o))throw new Error("bad point: equation left != right (2)")}equals(t){T(t);const{ex:e,ey:n,ez:r}=this,{ex:i,ey:o,ez:s}=t,a=A(e*s),u=A(i*r),c=A(n*s),f=A(o*r);return a===u&&c===f}is0(){return this.equals(U.ZERO)}negate(){return new U(A(-this.ex),this.ey,this.ez,A(-this.et))}double(){const{a:t}=w,{ex:e,ey:n,ez:r}=this,i=A(e*e),o=A(n*n),s=A(l*A(r*r)),a=A(t*i),u=e+n,c=A(A(u*u)-i-o),f=a+o,h=f-s,d=a-o,y=A(c*h),p=A(f*d),m=A(c*d),x=A(h*f);return new U(y,p,x,m)}add(t){T(t);const{a:e,d:n}=w,{ex:r,ey:i,ez:o,et:s}=this,{ex:a,ey:u,ez:f,et:h}=t;if(e===BigInt(-1)){const t=A((i-r)*(u+a)),e=A((i+r)*(u-a)),n=A(e-t);if(n===c)return this.double();const d=A(o*l*h),y=A(s*l*f),w=y+d,p=e+t,m=y-d,x=A(w*n),E=A(p*m),B=A(w*m),g=A(n*p);return new U(x,E,g,B)}const d=A(r*a),y=A(i*u),p=A(s*n*h),m=A(o*f),x=A((r+i)*(a+u)-d-y),E=m-p,B=m+p,g=A(y-e*d),v=A(x*E),z=A(B*g),R=A(x*g),S=A(E*B);return new U(v,z,S,R)}subtract(t){return this.add(t.negate())}wNAF(t){return F.wNAFCached(this,H,t,U.normalizeZ)}multiply(t){const{p:e,f:n}=this.wNAF(I(t,m));return U.normalizeZ([e,n])[0]}multiplyUnsafe(t){let e=P(t);return e===c?C:this.equals(C)||e===f?this:this.equals(j)?this.wNAF(e).p:F.unsafeLadder(this,e)}isSmallOrder(){return this.multiplyUnsafe(v).is0()}isTorsionFree(){return F.unsafeLadder(this,m).is0()}toAffine(t){const{ex:e,ey:n,ez:r}=this,i=this.is0();null==t&&(t=i?h:p.inv(r));const o=A(e*t),s=A(n*t),a=A(r*t);if(i)return{x:c,y:f};if(a!==f)throw new Error("invZ was invalid");return{x:o,y:s}}clearCofactor(){const{h:t}=w;return t===f?this:this.multiplyUnsafe(t)}static fromHex(t,e=!1){const{d:i,a:o}=w,s=p.BYTES,a=(t=n("pointHex",t,s)).slice(),u=t[s-1];a[s-1]=-129&u;const l=r(a);l===c||I(l,e?z:p.ORDER);const h=A(l*l),d=A(h-f),y=A(i*h-o);let{isValid:m,value:x}=R(d,y);if(!m)throw new Error("Point.fromHex: invalid y coordinate");const E=(x&f)===f,B=0!=(128&u);if(!e&&x===c&&B)throw new Error("Point.fromHex: x=0 and x_0=1");return B!==E&&(x=A(-x)),U.fromAffine({x:x,y:l})}static fromPrivateKey(t){return V(t).point}toRawBytes(){const{x:t,y:e}=this.toAffine(),n=i(e,p.BYTES);return n[n.length-1]|=t&f?128:0,n}toHex(){return o(this.toRawBytes())}}U.BASE=new U(w.Gx,w.Gy,f,A(w.Gx*w.Gy)),U.ZERO=new U(c,f,f,c);const{BASE:j,ZERO:C}=U,F=u(U,8*g);function _(e){return t(e,m)}function N(t){return _(r(t))}function V(t){const e=g;t=n("private key",t,e);const r=n("hashed private key",E(t),2*e),i=S(r.slice(0,e)),o=r.slice(e,2*e),s=N(i),a=j.multiply(s),u=a.toRawBytes();return{head:i,prefix:o,scalar:s,point:a,pointBytes:u}}function W(t=new Uint8Array,...e){const r=s(...e);return N(E(b(r,n("context",t),!!x)))}const Y=d;j._setWindowSize(8);return{CURVE:w,getPublicKey:function(t){return V(t).pointBytes},sign:function(t,e,r={}){t=n("message",t),x&&(t=x(t));const{prefix:o,scalar:a,pointBytes:u}=V(e),c=W(r.context,o,t),f=j.multiply(c).toRawBytes(),l=_(c+W(r.context,f,u,t)*a);P(l);const h=s(f,i(l,p.BYTES));return n("result",h,2*g)},verify:function(t,e,i,o=Y){const{context:s,zip215:a}=o,u=p.BYTES;t=n("signature",t,2*u),e=n("message",e),x&&(e=x(e));const c=r(t.slice(u,2*u));let f,l,h;try{f=U.fromHex(i,a),l=U.fromHex(t.slice(0,u),a),h=j.multiplyUnsafe(c)}catch(t){return!1}if(!a&&f.isSmallOrder())return!1;const d=W(s,l.toRawBytes(),f.toRawBytes(),e);return l.add(f.multiplyUnsafe(d)).subtract(h).clearCofactor().equals(U.ZERO)},ExtendedPoint:U,utils:{getExtendedPublicKey:V,randomPrivateKey:()=>B(p.BYTES),precompute:(t=8,e=U.BASE)=>(e._setWindowSize(t),e.multiply(BigInt(3)),e)}}}export{y as twistedEdwards};
//# sourceMappingURL=edwards.mjs.map
