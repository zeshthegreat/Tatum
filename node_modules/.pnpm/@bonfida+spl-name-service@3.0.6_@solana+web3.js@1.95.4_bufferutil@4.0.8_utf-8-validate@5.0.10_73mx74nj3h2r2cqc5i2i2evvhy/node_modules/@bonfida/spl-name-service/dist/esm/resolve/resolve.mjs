import"../node_modules/buffer/index.mjs";import{PublicKey as e,SIGNATURE_LENGTH_IN_BYTES as o}from"@solana/web3.js";import{getDomainKeySync as r}from"../utils/getDomainKeySync.mjs";import{NftRecord as t,Tag as n}from"../nft/state.mjs";import{NAME_TOKENIZER_ID as i}from"../nft/const.mjs";import{getRecordKeySync as a}from"../record/getRecordKeySync.mjs";import{Record as s}from"../types/record.mjs";import{getRecordV2Key as d}from"../record_v2/getRecordV2Key.mjs";import{Record as l,Validation as m}from"../node_modules/@bonfida/sns-records/dist/index.mjs";import{DomainDoesNotExist as f,CouldNotFindNftOwner as c,RecordMalformed as w,WrongValidation as u,InvalidRoAError as p,PdaOwnerNotAllowed as E}from"../error.mjs";import{NameRegistryState as v}from"../state.mjs";import{checkSolRecord as h}from"../record/checkSolRecord.mjs";import{retrieveNftOwnerV2 as g}from"../nft/retrieveNftOwnerV2.mjs";import{__exports as j}from"../_virtual/index.mjs";const R=async(R,A,_={allowPda:!1})=>{var y;const{pubkey:S}=r(A),[D]=t.findKeySync(S,i),x=a(A,s.SOL),L=d(A,s.SOL),[b,N,B,H]=await R.getMultipleAccountsInfo([D,x,L,S]);if(!(null==H?void 0:H.data))throw new f(`Domain ${A} does not exist`);const I=v.deserialize(H.data);if(null==b?void 0:b.data){if(t.deserialize(b.data).tag===n.ActiveRecord){const e=await g(R,S);if(!e)throw new c;return e}}e:if(null==B?void 0:B.data){const o=l.deserialize(B.data),r=o.getStalenessId(),t=o.getRoAId(),n=o.getContent();if(32!==n.length)throw new w("Record is malformed");if(o.header.rightOfAssociationValidation!==m.Solana||o.header.stalenessValidation!==m.Solana)throw new u;if(!r.equals(I.owner.toBuffer()))break e;if(t.equals(n))return new e(n);throw new p(`The RoA ID shoudl be ${new e(n).toBase58()} but is ${new e(t).toBase58()} `)}if(null==N?void 0:N.data){const r=new TextEncoder,t=j.Buffer.concat([N.data.slice(v.HEADER_LEN,v.HEADER_LEN+32),x.toBuffer()]),n=r.encode(t.toString("hex"));if(h(n,N.data.slice(v.HEADER_LEN+32,v.HEADER_LEN+32+o),I.owner))return new e(N.data.slice(v.HEADER_LEN,v.HEADER_LEN+32))}if(!e.isOnCurve(I.owner)){if("any"===_.allowPda)return I.owner;if(_.allowPda){const e=await R.getAccountInfo(I.owner);if(null===(y=_.programIds)||void 0===y?void 0:y.some((o=>{var r;return null===(r=null==e?void 0:e.owner)||void 0===r?void 0:r.equals(o)})))return I.owner;throw new E(`The Program ${null==e?void 0:e.owner.toBase58()} is not allowed`)}throw new E}return I.owner};export{R as resolve};
//# sourceMappingURL=resolve.mjs.map
