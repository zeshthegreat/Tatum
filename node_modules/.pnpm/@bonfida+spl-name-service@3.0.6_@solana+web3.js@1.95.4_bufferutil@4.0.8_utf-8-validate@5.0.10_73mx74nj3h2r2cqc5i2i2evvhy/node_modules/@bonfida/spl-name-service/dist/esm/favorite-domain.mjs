import"./node_modules/buffer/index.mjs";import{deserialize as e}from"./node_modules/borsh/lib/esm/index.mjs";import{PublicKey as t}from"@solana/web3.js";import{deserializeReverse as a}from"./utils/deserializeReverse.mjs";import{getReverseKeyFromDomainKey as o}from"./utils/getReverseKeyFromDomainKey.mjs";import{reverseLookup as n}from"./utils/reverseLookup.mjs";import{FavouriteDomainNotFoundError as r}from"./error.mjs";import{getDomainMint as i}from"./nft/getDomainMint.mjs";import{NameRegistryState as s}from"./state.mjs";import{ROOT_DOMAIN_ACCOUNT as m,NAME_PROGRAM_ID as u}from"./constants.mjs";import{__exports as l}from"./_virtual/index.mjs";import{getAssociatedTokenAddressSync as c}from"./node_modules/@solana/spl-token/lib/esm/state/mint.mjs";import{AccountLayout as d}from"./node_modules/@solana/spl-token/lib/esm/state/account.mjs";const f=new t("85iDfUvr3HJyLM2zcq5BXSiDvUWfw6cSE1FfNBo8Ap29");class p{constructor(e){this.tag=e.tag,this.nameAccount=new t(e.nameAccount)}static deserialize(t){return new p(e(this.schema,t))}static async retrieve(e,t){const a=await e.getAccountInfo(t);if(!a||!a.data)throw new r("The favourite account does not exist");return this.deserialize(a.data)}static async getKey(e,a){return await t.findProgramAddress([l.Buffer.from("favourite_domain"),a.toBuffer()],e)}static getKeySync(e,a){return t.findProgramAddressSync([l.Buffer.from("favourite_domain"),a.toBuffer()],e)}}p.schema={struct:{tag:"u8",nameAccount:{array:{type:"u8",len:32}}}};const v=async(e,a)=>{const[o]=p.getKeySync(f,new t(a)),r=await p.retrieve(e,o),{registry:i,nftOwner:u}=await s.retrieve(e,r.nameAccount),l=u||i.owner;let c=await n(e,r.nameAccount,i.parentName.equals(m)?void 0:i.parentName);if(!i.parentName.equals(m)){c+=`.${await n(e,i.parentName)}`}return{domain:r.nameAccount,reverse:c,stale:!a.equals(l)}},w=async(e,n)=>{const r=[],s=n.map((e=>p.getKeySync(f,e)[0])),v=(await e.getMultipleAccountsInfo(s)).map((e=>(null==e?void 0:e.data)?p.deserialize(null==e?void 0:e.data).nameAccount:t.default)),w=await e.getMultipleAccountsInfo(v),g=[],y=w.map(((e,a)=>{var n;const r=new t(null!==(n=null==e?void 0:e.data.slice(0,32))&&void 0!==n?n:l.Buffer.alloc(32)),i=(null==e?void 0:e.owner.equals(u))&&!r.equals(m);return g.push(i?o(r):t.default),o(v[a],i?r:void 0)})),h=v.map(((e,t)=>{const a=i(e);return c(a,n[t],!0)})),[A,j,_]=await Promise.all([e.getMultipleAccountsInfo(y),e.getMultipleAccountsInfo(h),e.getMultipleAccountsInfo(g)]);for(let e=0;e<n.length;e++){let o="";const i=w[e],s=A[e],m=_[e],l=j[e];if(!i||!s){r.push(void 0);continue}if(m&&m.owner.equals(u)){o+=`.${a(m.data.slice(96))}`}if(new t(null==i?void 0:i.data.slice(32,64)).equals(n[e])){r.push(a(null==s?void 0:s.data.slice(96),!0)+o);continue}if(!l){r.push(void 0);continue}const c=d.decode(l.data);1!==Number(c.amount)?r.push(void 0):r.push(a(null==s?void 0:s.data.slice(96))+o)}return r};export{p as FavouriteDomain,f as NAME_OFFERS_ID,p as PrimaryDomain,v as getFavoriteDomain,w as getMultipleFavoriteDomains,w as getMultiplePrimaryDomains,v as getPrimaryDomain};
//# sourceMappingURL=favorite-domain.mjs.map
