'use strict';

Object.defineProperty(exports, '__esModule', {
	value: true
});
exports.verifyDigest32 =
	exports.pubKeyToKeyPair =
	exports.pubKeyToBytes =
	exports.isValidSeiAddress =
	exports.getAddressHashFromPubKey =
	exports.compressedPubKeyToAddress =
		void 0;
var _encoding = require('@cosmjs/encoding');
var _elliptic = require('elliptic');
var _hash = require('./hash');
var _crypto = require('@cosmjs/crypto');
var _bech = require('./bech32');
var isValidSeiAddress = (exports.isValidSeiAddress = function isValidSeiAddress(address) {
	try {
		var _fromBech = (0, _encoding.fromBech32)(address),
			prefix = _fromBech.prefix;
		return prefix && prefix === 'sei';
	} catch (e) {
		return false;
	}
});
var pubKeyToKeyPair = (exports.pubKeyToKeyPair = function pubKeyToKeyPair(pubKey) {
	var secp256k1 = new _elliptic.ec('secp256k1');
	return secp256k1.keyFromPublic(Buffer.from(pubKey).toString('hex'), 'hex');
});
var pubKeyToBytes = (exports.pubKeyToBytes = function pubKeyToBytes(pubKey, uncompressed) {
	if (uncompressed && pubKey.length === 65) {
		return pubKey;
	}
	if (!uncompressed && pubKey.length === 33) {
		return pubKey;
	}
	var keyPair = pubKeyToKeyPair(pubKey);
	if (uncompressed) {
		return new Uint8Array(Buffer.from(keyPair.getPublic().encode('hex', false), 'hex'));
	} else {
		return new Uint8Array(Buffer.from(keyPair.getPublic().encodeCompressed('hex'), 'hex'));
	}
});
var compressedPubKeyToAddress = (exports.compressedPubKeyToAddress = function compressedPubKeyToAddress(publicKey) {
	return (0, _bech.toBech32)(getAddressHashFromPubKey(publicKey));
});
var getAddressHashFromPubKey = (exports.getAddressHashFromPubKey = function getAddressHashFromPubKey(compressedPublicKey) {
	return (0, _crypto.ripemd160)((0, _hash.sha256)(compressedPublicKey));
});
var verifyDigest32 = (exports.verifyDigest32 = function verifyDigest32(digest, signature, pubKey) {
	if (digest.length !== 32) {
		throw new Error('Invalid length of digest to verify: '.concat(digest.length));
	}
	if (signature.length !== 64) {
		throw new Error('Invalid length of signature: '.concat(signature.length));
	}
	var secp256k1 = new _elliptic.ec('secp256k1');
	var r = signature.slice(0, 32);
	var s = signature.slice(32);
	return secp256k1.verify(
		digest,
		{
			r: Buffer.from(r).toString('hex'),
			s: Buffer.from(s).toString('hex')
		},
		pubKeyToKeyPair(pubKey)
	);
});
//# sourceMappingURL=address.js.map
