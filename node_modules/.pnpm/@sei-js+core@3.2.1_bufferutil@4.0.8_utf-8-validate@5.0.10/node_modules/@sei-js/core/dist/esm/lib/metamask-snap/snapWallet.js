'use strict';

var _interopRequireDefault = require('@babel/runtime/helpers/interopRequireDefault');
Object.defineProperty(exports, '__esModule', {
	value: true
});
exports.getMetaMaskSnapSeiWallet = exports.SnapWallet = void 0;
exports.getWallet = getWallet;
var _regenerator = _interopRequireDefault(require('@babel/runtime/regenerator'));
var _defineProperty2 = _interopRequireDefault(require('@babel/runtime/helpers/defineProperty'));
var _asyncToGenerator2 = _interopRequireDefault(require('@babel/runtime/helpers/asyncToGenerator'));
var _classCallCheck2 = _interopRequireDefault(require('@babel/runtime/helpers/classCallCheck'));
var _createClass2 = _interopRequireDefault(require('@babel/runtime/helpers/createClass'));
var _secp256k = require('@noble/secp256k1');
var _sha = require('@noble/hashes/sha256');
var _amino = require('@cosmjs/amino');
var _buffer = require('buffer');
var _utils = require('./utils');
var _utils2 = require('../utils');
var _cosmjs = require('./cosmjs');
function ownKeys(e, r) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r &&
			(o = o.filter(function (r) {
				return Object.getOwnPropertyDescriptor(e, r).enumerable;
			})),
			t.push.apply(t, o);
	}
	return t;
}
function _objectSpread(e) {
	for (var r = 1; r < arguments.length; r++) {
		var t = null != arguments[r] ? arguments[r] : {};
		r % 2
			? ownKeys(Object(t), !0).forEach(function (r) {
					(0, _defineProperty2['default'])(e, r, t[r]);
			  })
			: Object.getOwnPropertyDescriptors
			? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t))
			: ownKeys(Object(t)).forEach(function (r) {
					Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
			  });
	}
	return e;
}
var SnapWallet = (exports.SnapWallet = /*#__PURE__*/ (function () {
	function SnapWallet(privateKey, compressedPubKey, address) {
		(0, _classCallCheck2['default'])(this, SnapWallet);
		this.privateKey = privateKey;
		this.compressedPubKey = compressedPubKey;
		this.address = address;
	}
	(0, _createClass2['default'])(
		SnapWallet,
		[
			{
				key: 'getAccounts',
				value: function getAccounts() {
					return [
						{
							address: this.address,
							algo: 'secp256k1',
							pubkey: this.compressedPubKey
						}
					];
				}
			},
			{
				key: 'signDirect',
				value: (function () {
					var _signDirect = (0, _asyncToGenerator2['default'])(
						/*#__PURE__*/ _regenerator['default'].mark(function _callee(signerAddress, signDoc) {
							var accounts, account, hash, signature;
							return _regenerator['default'].wrap(
								function _callee$(_context) {
									while (1)
										switch ((_context.prev = _context.next)) {
											case 0:
												accounts = this.getAccounts();
												account = accounts.find(function (acc) {
													return acc.address === signerAddress;
												});
												if (account) {
													_context.next = 4;
													break;
												}
												throw new Error('Signer address does not match wallet address');
											case 4:
												hash = (0, _sha.sha256)((0, _utils2.serializeDirectSignDoc)(signDoc));
												_context.next = 7;
												return (0, _secp256k.sign)(hash, this.privateKey, {
													canonical: true,
													extraEntropy: true,
													der: false
												});
											case 7:
												signature = _context.sent;
												return _context.abrupt('return', {
													signed: _objectSpread(
														_objectSpread({}, signDoc),
														{},
														{
															accountNumber: signDoc.accountNumber.toString()
														}
													),
													signature: (0, _amino.encodeSecp256k1Signature)(account.pubkey, signature)
												});
											case 9:
											case 'end':
												return _context.stop();
										}
								},
								_callee,
								this
							);
						})
					);
					function signDirect(_x, _x2) {
						return _signDirect.apply(this, arguments);
					}
					return signDirect;
				})()
			},
			{
				key: 'signAmino',
				value: (function () {
					var _signAmino = (0, _asyncToGenerator2['default'])(
						/*#__PURE__*/ _regenerator['default'].mark(function _callee2(signerAddress, signDoc, options) {
							var accounts, account, hash, extraEntropy, signature;
							return _regenerator['default'].wrap(
								function _callee2$(_context2) {
									while (1)
										switch ((_context2.prev = _context2.next)) {
											case 0:
												accounts = this.getAccounts();
												account = accounts.find(function (acc) {
													return acc.address === signerAddress;
												});
												if (account) {
													_context2.next = 4;
													break;
												}
												throw new Error('Signer address does not match wallet address');
											case 4:
												if (account.pubkey) {
													_context2.next = 6;
													break;
												}
												throw new Error('Unable to derive keypair');
											case 6:
												hash = (0, _sha.sha256)((0, _utils2.serializeAminoSignDoc)(signDoc));
												extraEntropy = options !== null && options !== void 0 && options.extraEntropy ? true : undefined;
												_context2.next = 10;
												return (0, _secp256k.sign)(hash, this.privateKey, {
													canonical: true,
													extraEntropy: extraEntropy,
													der: false
												});
											case 10:
												signature = _context2.sent;
												return _context2.abrupt('return', {
													signed: signDoc,
													signature: (0, _amino.encodeSecp256k1Signature)(account.pubkey, signature)
												});
											case 12:
											case 'end':
												return _context2.stop();
										}
								},
								_callee2,
								this
							);
						})
					);
					function signAmino(_x3, _x4, _x5) {
						return _signAmino.apply(this, arguments);
					}
					return signAmino;
				})()
			}
		],
		[
			{
				key: 'create',
				value: function create(privateKey) {
					var sanitizedPvtKey = privateKey.replace('0x', '');
					var pvtKeyBytes = _buffer.Buffer.from(sanitizedPvtKey, 'hex');
					var compressedPubKey = (0, _secp256k.getPublicKey)(pvtKeyBytes, true);
					var seiAddress = (0, _utils2.compressedPubKeyToAddress)(compressedPubKey);
					return new SnapWallet(pvtKeyBytes, compressedPubKey, seiAddress);
				}
			}
		]
	);
	return SnapWallet;
})());
function getWallet() {
	return _getWallet.apply(this, arguments);
}
function _getWallet() {
	_getWallet = (0, _asyncToGenerator2['default'])(
		/*#__PURE__*/ _regenerator['default'].mark(function _callee10() {
			var account_index,
				snapId,
				account,
				_args10 = arguments;
			return _regenerator['default'].wrap(function _callee10$(_context10) {
				while (1)
					switch ((_context10.prev = _context10.next)) {
						case 0:
							account_index = _args10.length > 0 && _args10[0] !== undefined ? _args10[0] : 0;
							snapId = _args10.length > 1 ? _args10[1] : undefined;
							_context10.next = 4;
							return (0, _utils.sendReqToSnap)(
								'getPrivateKey',
								{
									account_index: account_index
								},
								snapId
							);
						case 4:
							account = _context10.sent;
							if (!account.privateKey) {
								_context10.next = 7;
								break;
							}
							return _context10.abrupt('return', SnapWallet.create(account.privateKey));
						case 7:
							throw new Error('Error creating sei wallet!');
						case 8:
						case 'end':
							return _context10.stop();
					}
			}, _callee10);
		})
	);
	return _getWallet.apply(this, arguments);
}
var getMetaMaskSnapSeiWallet = (exports.getMetaMaskSnapSeiWallet = function getMetaMaskSnapSeiWallet(snapId) {
	return {
		getAccounts: (function () {
			var _getAccounts = (0, _asyncToGenerator2['default'])(
				/*#__PURE__*/ _regenerator['default'].mark(function _callee3(chainId) {
					var offlineSigner;
					return _regenerator['default'].wrap(function _callee3$(_context3) {
						while (1)
							switch ((_context3.prev = _context3.next)) {
								case 0:
									offlineSigner = new _cosmjs.CosmJSOfflineSigner(chainId, snapId);
									return _context3.abrupt('return', offlineSigner.getAccounts());
								case 2:
								case 'end':
									return _context3.stop();
							}
					}, _callee3);
				})
			);
			function getAccounts(_x6) {
				return _getAccounts.apply(this, arguments);
			}
			return getAccounts;
		})(),
		connect: (function () {
			var _connect = (0, _asyncToGenerator2['default'])(
				/*#__PURE__*/ _regenerator['default'].mark(function _callee4(_) {
					var provider, installedSnaps;
					return _regenerator['default'].wrap(function _callee4$(_context4) {
						while (1)
							switch ((_context4.prev = _context4.next)) {
								case 0:
									_context4.next = 2;
									return (0, _utils.getSnapEthereumProvider)();
								case 2:
									provider = _context4.sent;
									_context4.next = 5;
									return provider.request({
										method: 'wallet_getSnaps'
									});
								case 5:
									installedSnaps = _context4.sent;
									if (!(!installedSnaps || !installedSnaps[snapId])) {
										_context4.next = 9;
										break;
									}
									_context4.next = 9;
									return provider.request({
										method: 'wallet_requestSnaps',
										params: (0, _defineProperty2['default'])({}, snapId, {})
									});
								case 9:
								case 'end':
									return _context4.stop();
							}
					}, _callee4);
				})
			);
			function connect(_x7) {
				return _connect.apply(this, arguments);
			}
			return connect;
		})(),
		disconnect: (function () {
			var _disconnect = (0, _asyncToGenerator2['default'])(
				/*#__PURE__*/ _regenerator['default'].mark(function _callee5(_) {
					return _regenerator['default'].wrap(function _callee5$(_context5) {
						while (1)
							switch ((_context5.prev = _context5.next)) {
								case 0:
									throw new Error('Not implemented');
								case 1:
								case 'end':
									return _context5.stop();
							}
					}, _callee5);
				})
			);
			function disconnect(_x8) {
				return _disconnect.apply(this, arguments);
			}
			return disconnect;
		})(),
		getOfflineSigner: (function () {
			var _getOfflineSigner = (0, _asyncToGenerator2['default'])(
				/*#__PURE__*/ _regenerator['default'].mark(function _callee6(chainId) {
					return _regenerator['default'].wrap(function _callee6$(_context6) {
						while (1)
							switch ((_context6.prev = _context6.next)) {
								case 0:
									return _context6.abrupt('return', new _cosmjs.CosmJSOfflineSigner(chainId, snapId));
								case 1:
								case 'end':
									return _context6.stop();
							}
					}, _callee6);
				})
			);
			function getOfflineSigner(_x9) {
				return _getOfflineSigner.apply(this, arguments);
			}
			return getOfflineSigner;
		})(),
		getOfflineSignerAmino: (function () {
			var _getOfflineSignerAmino = (0, _asyncToGenerator2['default'])(
				/*#__PURE__*/ _regenerator['default'].mark(function _callee7(chainId) {
					return _regenerator['default'].wrap(function _callee7$(_context7) {
						while (1)
							switch ((_context7.prev = _context7.next)) {
								case 0:
									return _context7.abrupt('return', new _cosmjs.CosmJSOfflineSigner(chainId, snapId));
								case 1:
								case 'end':
									return _context7.stop();
							}
					}, _callee7);
				})
			);
			function getOfflineSignerAmino(_x10) {
				return _getOfflineSignerAmino.apply(this, arguments);
			}
			return getOfflineSignerAmino;
		})(),
		signArbitrary: (function () {
			var _signArbitrary = (0, _asyncToGenerator2['default'])(
				/*#__PURE__*/ _regenerator['default'].mark(function _callee8(chainId, signer, message) {
					var offlineSigner;
					return _regenerator['default'].wrap(function _callee8$(_context8) {
						while (1)
							switch ((_context8.prev = _context8.next)) {
								case 0:
									offlineSigner = new _cosmjs.CosmJSOfflineSigner(chainId, snapId);
									return _context8.abrupt('return', offlineSigner.signArbitrary(signer, message));
								case 2:
								case 'end':
									return _context8.stop();
							}
					}, _callee8);
				})
			);
			function signArbitrary(_x11, _x12, _x13) {
				return _signArbitrary.apply(this, arguments);
			}
			return signArbitrary;
		})(),
		verifyArbitrary: (function () {
			var _verifyArbitrary2 = (0, _asyncToGenerator2['default'])(
				/*#__PURE__*/ _regenerator['default'].mark(function _callee9(_, signingAddress, data, signature) {
					return _regenerator['default'].wrap(function _callee9$(_context9) {
						while (1)
							switch ((_context9.prev = _context9.next)) {
								case 0:
									if (!(!signingAddress || !data)) {
										_context9.next = 2;
										break;
									}
									throw new Error('Invalid params');
								case 2:
									_context9.next = 4;
									return (0, _utils2.verifyArbitrary)(signingAddress, data, signature);
								case 4:
									return _context9.abrupt('return', _context9.sent);
								case 5:
								case 'end':
									return _context9.stop();
							}
					}, _callee9);
				})
			);
			function verifyArbitrary(_x14, _x15, _x16, _x17) {
				return _verifyArbitrary2.apply(this, arguments);
			}
			return verifyArbitrary;
		})(),
		walletInfo: {
			windowKey: 'ethereum',
			name: 'Sei Metamask Snap',
			website: 'https://metamask.io/',
			icon: 'https://github.com/MetaMask/brand-resources/raw/master/SVG/SVG_MetaMask_Icon_Color.svg'
		},
		isMobileSupported: true
	};
});
//# sourceMappingURL=snapWallet.js.map
