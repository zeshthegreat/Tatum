'use strict';

var _interopRequireDefault = require('@babel/runtime/helpers/interopRequireDefault');
Object.defineProperty(exports, '__esModule', {
	value: true
});
exports.makeADR36AminoSignDoc = makeADR36AminoSignDoc;
exports.verifyArbitrary = void 0;
var _regenerator = _interopRequireDefault(require('@babel/runtime/regenerator'));
var _asyncToGenerator2 = _interopRequireDefault(require('@babel/runtime/helpers/asyncToGenerator'));
var _encoding = require('@cosmjs/encoding');
var _address = require('./address');
var _hash = require('./hash');
var _serialize = require('./serialize');
function checkAndValidateADR36AminoSignDoc(signDoc) {
	var hasOnlyMsgSignData = (function () {
		if (signDoc && signDoc.msgs && Array.isArray(signDoc.msgs) && signDoc.msgs.length === 1) {
			var _msg = signDoc.msgs[0];
			return _msg.type === 'sign/MsgSignData';
		} else {
			return false;
		}
	})();
	if (!hasOnlyMsgSignData) {
		return false;
	}
	if (signDoc.chain_id !== '') {
		throw new Error('Chain id should be empty string for ADR-36 signing');
	}
	if (signDoc.memo !== '') {
		throw new Error('Memo should be empty string for ADR-36 signing');
	}
	if (signDoc.account_number !== '0') {
		throw new Error('Account number should be "0" for ADR-36 signing');
	}
	if (signDoc.sequence !== '0') {
		throw new Error('Sequence should be "0" for ADR-36 signing');
	}
	if (signDoc.fee.gas !== '0') {
		throw new Error('Gas should be "0" for ADR-36 signing');
	}
	if (signDoc.fee.amount.length !== 0) {
		throw new Error('Fee amount should be empty array for ADR-36 signing');
	}
	var msg = signDoc.msgs[0];
	if (msg.type !== 'sign/MsgSignData') {
		throw new Error('Invalid type of ADR-36 sign msg: '.concat(msg.type));
	}
	if (!msg.value) {
		throw new Error('Empty value in the msg');
	}
	var signer = msg.value.signer;
	if (!signer) {
		throw new Error('Empty signer in the ADR-36 msg');
	}
	(0, _address.isValidSeiAddress)(signer);
	var data = msg.value.data;
	if (!data) {
		throw new Error('Empty data in the ADR-36 msg');
	}
	var rawData = Buffer.from(data, 'base64');
	// Validate the data is encoded as base64.
	if (rawData.toString('base64') !== data) {
		throw new Error('Data is not encoded by base64');
	}
	if (rawData.length === 0) {
		throw new Error('Empty data in the ADR-36 msg');
	}
	return true;
}
function makeADR36AminoSignDoc(signer, data) {
	// If data is already a base64 string, convert it to a Buffer and back to a string.
	data = Buffer.from(data).toString('base64');

	//According to ADR-36 specifications https://github.com/cosmos/cosmos-sdk/blob/main/docs/architecture/adr-036-arbitrary-signature.md
	return {
		// chain-id must be equal to “”
		chain_id: '',
		// must be invalid value
		account_number: '0',
		// nonce, sequence number must be equal to 0
		sequence: '0',
		fee: {
			// fee gas must be equal to 0
			gas: '0',
			//fee amount must be an empty array
			amount: []
		},
		msgs: [
			{
				type: 'sign/MsgSignData',
				value: {
					signer: signer,
					// Data is arbitrary bytes which can represent text, files, objects. It's applications developers decision how Data should be deserialized, serialized and the object it can represent in their context
					// It's applications developers decision how Data should be treated, by treated we mean the serialization and deserialization process and the Object Data should represent.
					data: data
				}
			}
		],
		// the memo must be empty
		memo: ''
	};
}
function verifyADR36AminoSignDoc(signDoc, pubKey, signature) {
	if (!checkAndValidateADR36AminoSignDoc(signDoc)) {
		throw new Error('Invalid sign doc for ADR-36');
	}
	var expectedSigner = (0, _address.compressedPubKeyToAddress)(pubKey);
	var signer = signDoc.msgs[0].value.signer;
	if (expectedSigner !== signer) {
		throw new Error('Unmatched signer');
	}
	var msg = (0, _serialize.serializeAminoSignDoc)(signDoc);
	return (0, _address.verifyDigest32)((0, _hash.sha256)(msg), signature, pubKey);
}
function verifyADR36Amino(signer, data, pubKey, signature) {
	var signDoc = makeADR36AminoSignDoc(signer, data);
	return verifyADR36AminoSignDoc(signDoc, pubKey, signature);
}
var verifyArbitrary = (exports.verifyArbitrary = /*#__PURE__*/ (function () {
	var _ref = (0, _asyncToGenerator2['default'])(
		/*#__PURE__*/ _regenerator['default'].mark(function _callee(signerAddress, expectedMessage, signatureToVerify) {
			var pubKey, signature;
			return _regenerator['default'].wrap(
				function _callee$(_context) {
					while (1)
						switch ((_context.prev = _context.next)) {
							case 0:
								_context.prev = 0;
								(pubKey = signatureToVerify.pub_key), (signature = signatureToVerify.signature);
								return _context.abrupt(
									'return',
									verifyADR36Amino(signerAddress, expectedMessage, (0, _encoding.fromBase64)(pubKey.value), (0, _encoding.fromBase64)(signature))
								);
							case 5:
								_context.prev = 5;
								_context.t0 = _context['catch'](0);
								console.log('error verifying signature', _context.t0);
								return _context.abrupt('return', false);
							case 9:
							case 'end':
								return _context.stop();
						}
				},
				_callee,
				null,
				[[0, 5]]
			);
		})
	);
	return function verifyArbitrary(_x, _x2, _x3) {
		return _ref.apply(this, arguments);
	};
})());
//# sourceMappingURL=signing.js.map
