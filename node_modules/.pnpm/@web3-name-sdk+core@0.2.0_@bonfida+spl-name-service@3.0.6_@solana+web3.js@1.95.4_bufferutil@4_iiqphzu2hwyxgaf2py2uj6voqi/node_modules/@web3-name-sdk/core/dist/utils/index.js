// src/utils/index.ts
import { namehash as namehash2 } from "viem";

// src/utils/labels.ts
import { labelhash as _labelhash } from "viem";
function isEncodedLabelhash(hash) {
  return hash.startsWith("[") && hash.endsWith("]") && hash.length === 66;
}
function labelhash(unnormalizedLabelOrLabelhash) {
  return _labelhash(unnormalizedLabelOrLabelhash);
}

// src/utils/namehash.ts
import { ens_normalize } from "@adraffy/ens-normalize";
import { namehash, toHex } from "viem";
var normalize = (name) => name ? ens_normalize(name) : name;
function tldNamehash(inputName, identifier) {
  if (!identifier)
    return namehash(inputName);
  const fullNameNode = `${inputName}.[${toHex(identifier, { size: 32 }).slice(2)}]`;
  return namehash(fullNameNode);
}

// src/constants/whitelist.ts
var whitelist_default = [
  "cz.bnb",
  "id.bnb",
  "sm.bnb",
  "yg.bnb",
  "cz.eth.bnb",
  "id.eth.bnb",
  "sm.eth.bnb",
  "yg.eth.bnb",
  "go.arb"
];

// src/utils/validate.ts
import { ens_normalize as ens_normalize2 } from "@adraffy/ens-normalize";
import { validate as ensValidate } from "@ensdomains/ens-validation";

// src/utils/common.ts
import { createPublicClient, http } from "viem";
import { mainnet, goerli, sepolia } from "viem/chains";
var v2Tlds = /* @__PURE__ */ new Set(["bnb", "arb", "eth"]);
function isV2Tld(tld) {
  return v2Tlds.has(tld);
}

// src/utils/validate.ts
function validateName(name) {
  if (!name) {
    throw new Error("Invalid name");
  }
  const labelArr = name.split(".");
  let domain = name;
  let suffix = "";
  if (labelArr.length > 1) {
    domain = labelArr.slice(0, labelArr.length - 1).join(".");
    suffix = labelArr[labelArr.length - 1];
  }
  if (labelArr.length === 3 && suffix.toLowerCase() === "bnb" && labelArr[1].toLowerCase() === "eth") {
    domain = labelArr[0];
  }
  const hasEmptyLabels = labelArr.filter((e) => e.length < 1).length > 0;
  if (hasEmptyLabels)
    throw new Error("Domain cannot have empty labels");
  if (!validateLabelLength(domain, !isV2Tld(suffix)) && !whitelist_default.includes(name.toLowerCase())) {
    throw new Error("Invalid name");
  }
  if (!validateDomains(domain))
    throw new Error("Invalid name");
  const normalizedArray = labelArr.map((label) => {
    return isEncodedLabelhash(label) ? label : normalize(label);
  });
  try {
    return normalizedArray.join(".");
  } catch (e) {
    throw e;
  }
}
function validateLabelLength(name, allowShortLabel = false) {
  if (!name) {
    return false;
  }
  const len = countCharacters(name);
  if (len > 512 || !allowShortLabel && len < 3) {
    return false;
  }
  let normalizedValue;
  try {
    normalizedValue = normalize(name);
  } catch (e) {
    normalizedValue = name;
  }
  if (normalizedValue.length > 512 || !allowShortLabel && len < 3) {
    return false;
  }
  return true;
}
function validateDomains(value) {
  const nospecial = /^[^*|\\":<>[\]{}`\\\\()';@&$]+$/u;
  const blackList = /[\u0000-\u002c\u002e-\u002f\u003a-\u005e\u0060\u007b-\u007f\u200b\u200c\u200d\ufeff]/g;
  return nospecial.test(value) && !blackList.test(value) && ensValidate(value);
}
function countCharacters(str) {
  const normalizedStr = ens_normalize2(str);
  const regex = /[\u0000-\uffff]|\p{L}|\p{Emoji}(?!\p{M})/gu;
  const matches = normalizedStr.match(regex);
  return matches ? matches.length : 0;
}
export {
  countCharacters,
  labelhash,
  namehash2 as namehash,
  normalize,
  tldNamehash,
  validateName
};
