"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Nft = exports.NftTezos = void 0;
const typedi_1 = require("typedi");
const tatum_connector_1 = require("../../connector/tatum.connector");
const util_1 = require("../../util");
const ipfs_1 = require("../ipfs");
let NftTezos = class NftTezos {
    constructor(id) {
        this.id = id;
        this.config = typedi_1.Container.of(this.id).get(util_1.CONFIG);
        this.connector = typedi_1.Container.of(this.id).get(tatum_connector_1.TatumConnector);
    }
    /**
     * Create new NFT collection (Tzip12 compatible smart contract). This operation deploys a new smart contract to the blockchain and sets the owner of the collection.
     * You don't need to specify the default minter of the collection, as the owner of the collection is the default minter.
     * You don't have to have any funds on the address, as the smart contract is deployed by Tatum.
     * @param body Body of the request.
     * @returns ResponseDto<{txId: string}> Transaction ID of the deployment transaction. You can get the contract address from the transaction details using rpc.getContractAddress(transactionId) function, once transaction is included in the block.
     */
    async createNftCollection(body) {
        return util_1.ErrorUtils.tryFail(() => this.connector.post({
            path: `contract/deploy`,
            body: {
                ...body,
                chain: this.config.network,
                contractType: 'nft',
            },
        }));
    }
};
exports.NftTezos = NftTezos;
exports.NftTezos = NftTezos = __decorate([
    (0, typedi_1.Service)({
        factory: (data) => {
            return new NftTezos(data.id);
        },
        transient: true,
    }),
    __metadata("design:paramtypes", [String])
], NftTezos);
let Nft = class Nft {
    constructor(id) {
        this.id = id;
        this.config = typedi_1.Container.of(this.id).get(util_1.CONFIG);
        this.connector = typedi_1.Container.of(this.id).get(tatum_connector_1.TatumConnector);
        this.ipfs = typedi_1.Container.of(this.id).get(ipfs_1.Ipfs);
    }
    /**
     * Create new NFT collection (ERC-721 compatible smart contract). This operation deploys new smart contract to the blockchain and sets the owner of the collection.
     * You don't need to specify the default minter of the collection, as the owner of the collection is the default minter.
     * You don't have to have any funds on the address, as the smart contract is deployed by Tatum.
     * @param body Body of the request.
     * @returns ResponseDto<{txId: string}> Transaction ID of the deployment transaction. You can get the contract address from the transaction details using rpc.getContractAddress(transactionId) function, once transaction is included in the block.
     */
    async createNftCollection(body) {
        return util_1.ErrorUtils.tryFail(() => this.connector.post({
            path: `contract/deploy`,
            body: {
                ...body,
                chain: this.config.network,
                contractType: 'nft',
            },
        }));
    }
    /**
     * Create new MultiToken NFT collection (ERC-1155 compatible smart contract). This operation deploys new smart contract to the blockchain and sets the owner of the collection.
     * You don't need to specify the default minter of the collection, as the owner of the collection is the default minter.
     * You don't have to have any funds on the address, as the smart contract is deployed by Tatum.
     * @param body Body of the request.
     * @returns ResponseDto<{txId: string}> Transaction ID of the deployment transaction. You can get the contract address from the transaction details using rpc.getContractAddress(transactionId) function, once transaction is included in the block.
     */
    async createMultiTokenNftCollection(body) {
        return util_1.ErrorUtils.tryFail(() => this.connector.post({
            path: `contract/deploy`,
            body: {
                ...body,
                chain: this.config.network,
                contractType: 'multitoken',
            },
        }));
    }
    /**
     * Mint new NFT (using ERC-721 compatible smart contract). This operation mints nft using smart contract on blockchain.
     * You don't need to specify the default minter of the collection, as the owner of the collection is the default minter.
     * You don't have to have any funds on the address, as the nft is minted by Tatum.
     * @param body Body of the request.
     * @returns ResponseDto<{txId: string}> Transaction ID of the mint transaction. {
     */
    async mintNft(body) {
        return util_1.ErrorUtils.tryFail(() => this.connector.post({
            path: `contract/erc721/mint`,
            body: {
                ...body,
                chain: this.config.network,
            },
        }));
    }
    /**
     * Mint new NFT (using ERC-721 compatible smart contract).
     * This operation uploads file to IPFS, prepares and uploads metadata to IPFS and mints nft using prepared metadata's IPFS url.
     * You don't need to specify the default minter of the collection, as the owner of the collection is the default minter.
     * You don't have to have any funds on the address, as the nft is minted by Tatum.
     * @param body Body of the request.
     * @returns ResponseDto<{txId: string}> Transaction ID of the mint transaction. {
     */
    async mintNftWithMetadata(body) {
        const imageUpload = await this.ipfs.uploadFile({ file: body.file });
        if (imageUpload.error) {
            return util_1.ErrorUtils.toErrorResponse(imageUpload.error);
        }
        const metadataUpload = await this.ipfs.uploadFile({
            file: Buffer.from(JSON.stringify({
                ...body.metadata,
                image: `ipfs://${imageUpload.data.ipfsHash}`,
            })),
        });
        if (metadataUpload.error) {
            return util_1.ErrorUtils.toErrorResponse(metadataUpload.error);
        }
        return util_1.ErrorUtils.tryFail(() => this.connector.post({
            path: `contract/erc721/mint`,
            body: {
                ...body,
                url: `ipfs://${metadataUpload.data.ipfsHash}`,
                chain: this.config.network,
            },
        }));
    }
    /**
     * Get balance of NFT for given address.
     * You can get balance of multiple addresses in one call.
     */
    async getBalance({ page = 0, pageSize = 50, addresses, }) {
        const chain = this.config.network;
        return util_1.ErrorUtils.tryFail(() => this.connector
            .get({
            path: `data/balances`,
            params: {
                pageSize,
                offset: page,
                chain,
                tokenTypes: 'nft,multitoken',
                addresses: addresses.join(','),
            },
        })
            .then((r) => r.result));
    }
    /**
     * Get all transactions for given NFT.
     * @param nftTransactionsDetails  You can get multiple NFT transactions in one call.
     * @param page
     * @param pageSize
     */
    async getAllNftTransactions({ page = 0, pageSize = 50, tokenId, tokenAddress, transactionType, fromBlock, toBlock, }) {
        const chain = this.config.network;
        return util_1.ErrorUtils.tryFail(() => this.connector
            .get({
            path: `data/transactions`,
            params: {
                pageSize,
                offset: page,
                chain,
                tokenTypes: 'nft,multitoken',
                transactionSubtype: transactionType,
                tokenAddress,
                tokenId,
                blockFrom: fromBlock,
                blockTo: toBlock,
            },
        })
            .then((r) => r.result));
    }
    /**
     * Get all transactions for given NFT.
     * @param nftTransactionsDetails  You can get multiple NFT transactions in one call.
     * @param page
     * @param pageSize
     */
    async getAllNftTransactionsByAddress({ page = 0, pageSize = 50, addresses, tokenId, tokenAddress, transactionType, fromBlock, toBlock, }) {
        const chain = this.config.network;
        return util_1.ErrorUtils.tryFail(() => this.connector
            .get({
            path: `data/transactions`,
            params: {
                pageSize,
                offset: page,
                chain,
                addresses: addresses.join(','),
                tokenTypes: 'nft,multitoken',
                transactionSubtype: transactionType,
                tokenAddress,
                tokenId,
                blockFrom: fromBlock,
                blockTo: toBlock,
            },
        })
            .then((r) => r.result));
    }
    /**
     * Get metadata of NFT.
     */
    async getNftMetadata({ tokenAddress, tokenId, }) {
        const chain = this.config.network;
        return util_1.ErrorUtils.tryFail(async () => {
            const response = await this.connector.get({
                path: `data/metadata`,
                params: {
                    chain,
                    tokenAddress,
                    tokenIds: tokenId,
                },
            });
            if (response?.length) {
                return response[0];
            }
            return null;
        });
    }
    /**
     * Get owner of a specific NFT.
     */
    async getNftOwner({ tokenAddress, tokenId, pageSize, page, }) {
        const chain = this.config.network;
        return util_1.ErrorUtils.tryFail(() => this.connector.get({
            path: `data/owners`,
            params: {
                chain,
                tokenAddress,
                tokenId,
                pageSize,
                offset: page,
            },
        }));
    }
    /**
     * Check if address is owner of a specific NFT.
     */
    async checkNftOwner({ tokenAddress, tokenId, owner }) {
        const chain = this.config.network;
        return this.connector.get({
            path: `data/owners/address`,
            params: {
                chain,
                tokenAddress,
                address: owner,
                tokenId,
            },
        });
    }
    /**
     * Get all NFTs in collection.
     */
    async getNftsInCollection({ collectionAddress, pageSize, excludeMetadata = false, page, }) {
        const chain = this.config.network;
        return util_1.ErrorUtils.tryFail(() => this.connector.get({
            path: `data/collections`,
            params: {
                pageSize,
                offset: page,
                chain,
                collectionAddresses: collectionAddress,
                excludeMetadata,
            },
        }));
    }
};
exports.Nft = Nft;
exports.Nft = Nft = __decorate([
    (0, typedi_1.Service)({
        factory: (data) => {
            return new Nft(data.id);
        },
        transient: true,
    }),
    __metadata("design:paramtypes", [String])
], Nft);
//# sourceMappingURL=nft.js.map