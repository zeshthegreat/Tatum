"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const dto_1 = require("../../../../dto");
const e2e_constant_1 = require("../../../e2e.constant");
const evm_e2e_utils_1 = require("../evm.e2e.utils");
describe('Beacon', () => {
    describe('v1', () => {
        const networks = [dto_1.Network.ETHEREUM_HOLESKY, dto_1.Network.ETHEREUM];
        describe.each(networks)('%s', (network) => {
            const apiKey = network === dto_1.Network.ETHEREUM ? e2e_constant_1.ApiKey.mainnet : e2e_constant_1.ApiKey.testnet;
            it.skip('should get node version', async () => {
                const tatum = await evm_e2e_utils_1.EvmE2eUtils.initTatum(network, apiKey);
                const { data } = await tatum.rpc.beacon.v1.getNodeVersion();
                await tatum.destroy();
                expect(data).toBeDefined();
            });
            it('should get genesis', async () => {
                const tatum = await evm_e2e_utils_1.EvmE2eUtils.initTatum(network, apiKey);
                const { data } = await tatum.rpc.beacon.v1.getGenesis();
                await tatum.destroy();
                expect(data).toBeDefined();
            });
            it('should get state root', async () => {
                const tatum = await evm_e2e_utils_1.EvmE2eUtils.initTatum(network, apiKey);
                const { data } = await tatum.rpc.beacon.v1.getStateRoot({ stateId: 'head' });
                await tatum.destroy();
                expect(data).toBeDefined();
            });
            it('should get block headers', async () => {
                const tatum = await evm_e2e_utils_1.EvmE2eUtils.initTatum(network, apiKey);
                const { data } = await tatum.rpc.beacon.v1.getBlockHeaders({ slot: '1000' });
                await tatum.destroy();
                expect(data).toBeDefined();
            });
            it('should get block root', async () => {
                const tatum = await evm_e2e_utils_1.EvmE2eUtils.initTatum(network, apiKey);
                const { data } = await tatum.rpc.beacon.v1.getBlockRoot({ blockId: 'head' });
                await tatum.destroy();
                expect(data).toBeDefined();
            });
            it('should get state committees', async () => {
                const tatum = await evm_e2e_utils_1.EvmE2eUtils.initTatum(network, apiKey);
                const { data } = await tatum.rpc.beacon.v1.getStateCommittees({ stateId: 'head' });
                await tatum.destroy();
                expect(data).toBeDefined();
            });
            it('should get state finality checkpoints', async () => {
                const tatum = await evm_e2e_utils_1.EvmE2eUtils.initTatum(network, apiKey);
                const { data } = await tatum.rpc.beacon.v1.getStateFinalityCheckpoints({ stateId: 'head' });
                await tatum.destroy();
                expect(data).toBeDefined();
            });
            it('should get state fork', async () => {
                const tatum = await evm_e2e_utils_1.EvmE2eUtils.initTatum(network, apiKey);
                const { data } = await tatum.rpc.beacon.v1.getStateFork({ stateId: 'head' });
                await tatum.destroy();
                expect(data).toBeDefined();
            });
            it('should get state sync committees', async () => {
                const tatum = await evm_e2e_utils_1.EvmE2eUtils.initTatum(network, apiKey);
                const { data } = await tatum.rpc.beacon.v1.getStateSyncCommittees({ stateId: 'head' });
                await tatum.destroy();
                expect(data).toBeDefined();
            });
        });
    });
});
//# sourceMappingURL=tatum.rpc.beacon.spec.js.map