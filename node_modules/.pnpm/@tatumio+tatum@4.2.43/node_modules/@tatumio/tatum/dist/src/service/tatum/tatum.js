"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var TatumSDK_1;
Object.defineProperty(exports, "__esModule", { value: true });
exports.TatumSDK = exports.TatumSdkChain = void 0;
const typedi_1 = require("typedi");
const dto_1 = require("../../dto");
const util_1 = require("../../util");
const extensions_1 = require("../extensions");
const LoadBalancer_1 = require("../rpc/generic/LoadBalancer");
const walletProvider_1 = require("../walletProvider");
const tatum_dto_1 = require("./tatum.dto");
class TatumSdkChain {
    constructor(id) {
        this.id = id;
        this.walletProvider = typedi_1.Container.of(id).get(walletProvider_1.WalletProvider);
    }
    extension(
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    type) {
        return typedi_1.Container.of(this.id).get(type);
    }
    async destroy() {
        const config = typedi_1.Container.of(this.id).get(util_1.CONFIG);
        for (const extensionConfig of config?.configureExtensions ?? []) {
            await this.destroyExtension(extensionConfig, this.id);
        }
        for (const walletProviderConfig of config?.configureWalletProviders ?? []) {
            await this.destroyExtension(walletProviderConfig, this.id);
        }
        // calls destroy on load balancer
        typedi_1.Container.of(this.id).remove(config.network === dto_1.Network.TRON ? LoadBalancer_1.TronLoadBalancer : LoadBalancer_1.LoadBalancer);
    }
    async destroyExtension(extensionConfig, id) {
        let type;
        if ('type' in extensionConfig) {
            type = extensionConfig.type;
        }
        else {
            type = extensionConfig;
        }
        await typedi_1.Container.of(id).get(type)?.destroy();
    }
}
exports.TatumSdkChain = TatumSdkChain;
let TatumSDK = TatumSDK_1 = class TatumSDK {
    /**
     * Initialize Tatum SDK. This method must be called before any other method.
     * Default configuration is used if no configuration is provided.
     * @param config
     */
    static async init(config) {
        const defaultConfig = {
            version: tatum_dto_1.ApiVersion.V4,
            retryCount: 1,
            retryDelay: 1000,
            rpc: {
                oneTimeLoadBalancing: false,
                allowedBlocksBehind: util_1.Constant.OPEN_RPC.ALLOWED_BLOCKS_BEHIND,
            },
        };
        const mergedConfig = util_1.Utils.deepMerge(defaultConfig, config);
        util_1.LoggerUtils.setLoggerForEnv(mergedConfig, util_1.EnvUtils.isDevelopment(), util_1.EnvUtils.isBrowser());
        // TODO: check when rpc is customized if there is allowedBlocksBehind if not throw error or set default
        // TODO: Check if rpc works for other chains and all configurations are set correctly
        const id = TatumSDK_1.generateRandomString();
        typedi_1.Container.of(id).set(util_1.CONFIG, mergedConfig);
        typedi_1.Container.of(id).set(util_1.LOGGER, mergedConfig.logger);
        if (!mergedConfig.apiKey ||
            (typeof mergedConfig.apiKey !== 'string' && !mergedConfig.apiKey.v3 && !mergedConfig.apiKey.v4)) {
            mergedConfig.logger?.warn('API key not provided - only a subset of SDK features will be enabled. Generate an API Key by accessing your Dashboard: https://co.tatum.io/signup');
        }
        if ((0, dto_1.isLoadBalancerNetwork)(mergedConfig.network)) {
            const loadBalancer = typedi_1.Container.of(id).get(mergedConfig.network === dto_1.Network.TRON ? LoadBalancer_1.TronLoadBalancer : LoadBalancer_1.LoadBalancer);
            await loadBalancer.init();
        }
        const containerInstance = new extensions_1.TatumSdkContainer(typedi_1.Container.of(id));
        await this.configureExtensions(config, id, containerInstance);
        await this.addBuiltInExtensions(id, containerInstance);
        return util_1.Utils.getClient(id, mergedConfig.network);
    }
    static async addBuiltInExtensions(id, containerInstance) {
        for (const extension of this.builtInExtensions) {
            const instance = new extension(containerInstance);
            if (instance.supportedNetworks.includes(typedi_1.Container.of(id).get(util_1.CONFIG).network)) {
                await instance.init();
                typedi_1.Container.of(id).set(extension, instance);
            }
        }
    }
    static async configureExtensions(config, id, containerInstance) {
        for (const extensionConfig of config?.configureExtensions ?? []) {
            await this.addExtension(extensionConfig, id, containerInstance);
        }
        for (const walletProviderConfig of config?.configureWalletProviders ?? []) {
            await this.addExtension(walletProviderConfig, id, containerInstance);
        }
    }
    static async addExtension(extensionConfig, id, containerInstance) {
        let type;
        const args = [];
        if ('type' in extensionConfig) {
            type = extensionConfig.type;
            args.push(extensionConfig.config);
        }
        else {
            type = extensionConfig;
        }
        const instance = new type(containerInstance, ...args);
        this.checkIfNetworkSupportedInExtension(instance, id, type);
        await instance.init();
        typedi_1.Container.of(id).set(type, instance);
    }
    static checkIfNetworkSupportedInExtension(instance, id, type) {
        if (!instance.supportedNetworks.includes(typedi_1.Container.of(id).get(util_1.CONFIG).network)) {
            throw new Error(`Extension ${type.name} is not supported on ${typedi_1.Container.of(id).get(util_1.CONFIG).network} network.`);
        }
    }
    static generateRandomString() {
        const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
        let result = '';
        for (let i = 0; i < 60; i++) {
            result += characters.charAt(Math.floor(Math.random() * characters.length));
        }
        return result;
    }
};
exports.TatumSDK = TatumSDK;
TatumSDK.builtInExtensions = [walletProvider_1.MetaMask];
exports.TatumSDK = TatumSDK = TatumSDK_1 = __decorate([
    (0, typedi_1.Service)({ transient: true })
], TatumSDK);
//# sourceMappingURL=tatum.js.map