"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.checkLabels = void 0;
Object.defineProperty(exports, "decodeContenthash", {
  enumerable: true,
  get: function get() {
    return _contents.decodeContenthash;
  }
});
Object.defineProperty(exports, "decodeLabelhash", {
  enumerable: true,
  get: function get() {
    return _labelhash.decodeLabelhash;
  }
});
exports.emptyAddress = void 0;
Object.defineProperty(exports, "encodeContenthash", {
  enumerable: true,
  get: function get() {
    return _contents.encodeContenthash;
  }
});
Object.defineProperty(exports, "encodeLabelhash", {
  enumerable: true,
  get: function get() {
    return _labelhash.encodeLabelhash;
  }
});
exports.getEnsStartBlock = getEnsStartBlock;
Object.defineProperty(exports, "isDecrypted", {
  enumerable: true,
  get: function get() {
    return _labelhash.isDecrypted;
  }
});
Object.defineProperty(exports, "isEncodedLabelhash", {
  enumerable: true,
  get: function get() {
    return _labelhash.isEncodedLabelhash;
  }
});
exports.isLabelValid = isLabelValid;
Object.defineProperty(exports, "isValidContenthash", {
  enumerable: true,
  get: function get() {
    return _contents.isValidContenthash;
  }
});
Object.defineProperty(exports, "labelhash", {
  enumerable: true,
  get: function get() {
    return _labelhash.labelhash;
  }
});
exports.mergeLabels = void 0;
Object.defineProperty(exports, "namehash", {
  enumerable: true,
  get: function get() {
    return _namehash.namehash;
  }
});
exports.normalize = normalize;
exports.uniq = exports.parseSearchTerm = void 0;
exports.validateName = validateName;
var _ethers = require("ethers");
var _ensValidation = require("@ensdomains/ens-validation");
var _lodash = _interopRequireDefault(require("lodash.toarray"));
var _labelhash = require("./labelhash");
var _contents = require("./contents");
var _ethEnsNamehash = _interopRequireDefault(require("@ensdomains/eth-ens-namehash"));
var _namehash = require("./namehash");
var _whitelist = _interopRequireDefault(require("../constants/whitelist"));
//import { checkLabelHash } from '../updaters/preImageDB'

var uniq = function uniq(a, param) {
  return a.filter(function (item, pos) {
    return a.map(function (mapItem) {
      return mapItem[param];
    }).indexOf(item[param]) === pos;
  });
};
exports.uniq = uniq;
var checkLabels = function checkLabels() {
  for (var _len = arguments.length, labelHashes = new Array(_len), _key = 0; _key < _len; _key++) {
    labelHashes[_key] = arguments[_key];
  }
  return labelHashes.map(function (hash) {
    return null;
  });
};
exports.checkLabels = checkLabels;
function getEnsStartBlock(networkId) {
  switch (networkId) {
    case 1:
    case '1':
      return 3327417;
    case 3:
    case '3':
      return 25409;
    default:
      return 0;
  }
}

// export const checkLabels = (...labelHashes) =>
//   labelHashes.map(labelHash => checkLabelHash(labelHash) || null)

var mergeLabels = function mergeLabels(labels1, labels2) {
  return labels1.map(function (label, index) {
    return label ? label : labels2[index];
  });
};
exports.mergeLabels = mergeLabels;
function validateLabelLength(name) {
  if (!name) {
    return false;
  }
  var len = (0, _lodash["default"])(name).length;
  if (len < 3 || len > 512) {
    return false;
  }
  var normalizedValue;
  try {
    normalizedValue = _ethEnsNamehash["default"].normalize(name);
  } catch (e) {
    normalizedValue = name;
  }
  if (normalizedValue.length < 3 || normalizedValue.length > 512) {
    return false;
  }
  return true;
}
function validateDomains(value, tld) {
  var isNotEns = (tld === null || tld === void 0 ? void 0 : tld.toLowerCase()) !== 'eth';
  // black list
  // ASCII中的十进制: 0-44, 46-47, 58-94, 96, 123-127;
  // unicode: \u200b, \u200c, \u200d, \ufeff
  var blackList =
  // eslint-disable-next-line no-control-regex
  /[\u0000-\u002c\u002e-\u002f\u003a-\u0040\u005b-\u005e\u0060\u007b-\u007f\u200b\u200c\u200d\ufeff]/g;
  if (isNotEns && blackList.test(value)) {
    return false;
  } else if (!(0, _ensValidation.validate)(value)) {
    return false;
  }
  return true;
}
function validateName(name) {
  if (!name) {
    throw new Error('Invalid name');
  }
  var labelArr = name.split('.');
  var domain = name;
  var suffix = '';
  if (labelArr.length > 1) {
    domain = labelArr.slice(0, labelArr.length - 1).join('.');
    suffix = labelArr[labelArr.length - 1];
  }
  if (labelArr.length === 3 && suffix.toLowerCase() === 'bnb' && labelArr[1].toLowerCase() === 'eth') {
    domain = labelArr[0];
  }
  var hasEmptyLabels = labelArr.filter(function (e) {
    return e.length < 1;
  }).length > 0;
  if (hasEmptyLabels) throw new Error('Domain cannot have empty labels');
  if (!validateLabelLength(domain) && !_whitelist["default"].includes(name.toLowerCase())) {
    throw new Error('Invalid name');
  }
  if (!validateDomains(domain, suffix)) throw new Error('Invalid name');
  var normalizedArray = labelArr.map(function (label) {
    return (0, _labelhash.isEncodedLabelhash)(label) ? label : _ethEnsNamehash["default"].normalize(label);
  });
  try {
    return normalizedArray.join('.');
  } catch (e) {
    throw e;
  }
}
function normalize(name) {
  var nameArray = name.split('.');
  var normalizedArray = nameArray.map(function (label) {
    return (0, _labelhash.isEncodedLabelhash)(label) ? label : _ethEnsNamehash["default"].normalize(label);
  });
  return normalizedArray.join('.');
}
function isLabelValid(name) {
  try {
    validateName(name);
    if (name.indexOf('.') === -1) {
      return true;
    }
  } catch (e) {
    console.log(e);
    return false;
  }
}
var parseSearchTerm = function parseSearchTerm(term, validTld) {
  var regex = /[^.]+$/;
  try {
    validateName(term);
  } catch (e) {
    return 'invalid';
  }
  if (term.indexOf('.') !== -1) {
    var termArray = term.split('.');
    var tld = term.match(regex) ? term.match(regex)[0] : '';
    if (validTld) {
      if (tld === 'bnb' && termArray[termArray.length - 2].length < 3) {
        return 'short';
      }
      return 'supported';
    }
    return 'unsupported';
  } else if (_ethers.ethers.utils.isAddress(term)) {
    return 'address';
  } else {
    //check if the search term is actually a tld
    if (validTld) {
      return 'tld';
    }
    return 'search';
  }
};
exports.parseSearchTerm = parseSearchTerm;
var emptyAddress = '0x0000000000000000000000000000000000000000';
exports.emptyAddress = emptyAddress;